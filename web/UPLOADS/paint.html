<!DOCTYPE html>
<html lang="en">
<head>
    <title>WTAF ‚Äì Delusional App Generator</title>
    <meta property="og:title" content="WTAF by AF" />
    <meta property="og:description" content="Vibecoded chaos, shipped via SMS." />
    <meta property="og:image" content="https://tqniseocczttrfwtpbdr.supabase.co/storage/v1/object/public/og-images/bart-wave-wood-deconstructing.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:url" content="https://theaf-web.ngrok.io/bart/wave-wood-deconstructing" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>RETRO PAINT 98</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #fefef5;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        * {
            box-sizing: border-box;
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
            padding: 0;
        }

        h1 {
            color: #FF4B4B;
            font-size: 24px;
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: white;
            border: 2px solid #FFD63D;
            border-radius: 12px;
            box-shadow: 4px 4px 0 #C9C2F9;
            padding: 10px;
            margin: 20px auto;
            display: block;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* Desktop only - make container fit canvas better */
        @media (min-width: 768px) {
            .canvas-container {
                display: inline-block;
                max-width: none;
            }
            
            .app-container {
                text-align: center;
            }
        }

        #paintCanvas {
            border: 1px solid #ccc;
            cursor: crosshair;
            background: white;
            touch-action: none;
            display: block;
            max-width: 100%;
            height: auto;
            /* Prevent text selection and touch callouts on mobile */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        button {
            background: #6ECBFF;
            border: none;
            border-radius: 20px;
            color: white;
            padding: 10px 15px;
            font-size: 20px;
            height: 44px;
            cursor: pointer;
            min-width: 44px;
            transition: transform 0.1s;
            flex: 0 0 auto;
        }

        button:active {
            transform: scale(0.95);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 5px 15px;
            border-radius: 20px;
            border: 2px solid #6ECBFF;
        }

        input[type="range"] {
            width: 100px;
        }

        input[type="color"] {
            width: 44px;
            height: 44px;
            padding: 0;
            border: none;
            cursor: pointer;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 40px;
        }

        .gallery-item {
            background: white;
            border: 2px solid #FFD63D;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 4px 4px 0 #C9C2F9;
        }

        .gallery-item img {
            width: 100%;
            border-radius: 8px;
        }

        .gallery-item p {
            margin: 10px 0;
            font-size: 16px;
            color: #666;
        }


        @media (max-width: 600px) {
            .toolbar {
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
            
            .control-group {
                flex: 0 0 100%;
                order: 2;
                margin-top: 10px;
                justify-content: center;
            }
            
            button {
                flex: 0 0 auto;
                width: auto;
            }
        }
    </style>
<script>
// ZAD Helper Functions - Inline version for test apps

// SIMPLIFIED UUID INJECTION: Set window.APP_ID for backup
window.APP_ID = '0ece9480-f6b6-4aa3-bc58-f2cdfd2272e5';
console.log('üÜî SIMPLIFIED UUID INJECTION: window.APP_ID set to:', '0ece9480-f6b6-4aa3-bc58-f2cdfd2272e5');

console.log('üöÄ Loading ZAD Helper Functions (inline)...');

// Auth state - Use existing global currentUser or create zadCurrentUser
let zadCurrentUser = (typeof currentUser !== 'undefined') ? currentUser : null;
let authInitialized = false;

// Get app ID from window.APP_ID (set by system) - ENHANCED DEBUG VERSION
function getAppId() {
    console.log('üÜî SIMPLIFIED UUID INJECTION: window.APP_ID set to:', '0ece9480-f6b6-4aa3-bc58-f2cdfd2272e5');
    return '0ece9480-f6b6-4aa3-bc58-f2cdfd2272e5';
}

                // Get participant ID - return stored ID or generate temporary one
                function getParticipantId() {
                    let participantId = localStorage.getItem('zad_participant_id');
                    if (!participantId) {
                        // Check if demo mode is enabled (multiple detection methods for iframe compatibility)
                        const isDemoMode = 
                            window.location.search.includes('demo=true') ||
                            window.parent?.location?.search?.includes('demo=true') ||
                            window.top?.location?.search?.includes('demo=true') ||
                            document.referrer.includes('demo=true');
                        
                        // Clear demo mode if not detected in current session
                        if (!isDemoMode) {
                            localStorage.removeItem('demo_mode');
                            // Also clear participant_id if it was a demo ID, so user gets fresh normal ID
                            const existingId = localStorage.getItem('zad_participant_id');
                            if (existingId && existingId.startsWith('demo_')) {
                                localStorage.removeItem('zad_participant_id');
                                localStorage.removeItem('zad_username');
                            }
                        }
                        
                        if (isDemoMode) {
                            // Generate demo ID that will trigger backend demo table routing
                            participantId = 'demo_user_' + Math.random().toString(36).substr(2, 8);
                            localStorage.setItem('demo_mode', 'true');
                            localStorage.setItem('zad_username', 'Demo User');
                            console.log('üé≠ Demo mode detected - generated demo participant ID:', participantId);
                        } else {
                            // Generate temporary ID - app's authentication system will set the real one
                            participantId = 'temp_' + Math.random().toString(36).substr(2, 12);
                            localStorage.setItem('zad_username', 'Anonymous');
                        }
                        
                        localStorage.setItem('zad_participant_id', participantId);
                    }
                    return participantId;
                }

                // Get username from current session
                function getUsername() {
                    // Ensure participant ID is initialized first (which sets up localStorage)
                    getParticipantId();
                    return localStorage.getItem('zad_username') || 'Anonymous';
                }

                // Update ZAD helper functions with app's authentication state
                function updateZadAuth(userLabel, participantId) {
                    localStorage.setItem('zad_participant_id', participantId);
                    localStorage.setItem('zad_username', userLabel);
                    zadCurrentUser = {
                        username: userLabel,
                        participantId: participantId
                    };
                    console.log('üîÑ Updated ZAD auth state:', zadCurrentUser);
                }

                // Initialize authentication (simplified)
                function initAuth() {
                    console.log('üîê Initializing authentication...');
                    if (authInitialized) return;
                    authInitialized = true;
                    
                    // Don't clear localStorage or prompt during initialization
                    // Let the app's authentication system handle user setup
                    zadCurrentUser = {
                        username: getUsername(),
                        participantId: localStorage.getItem('zad_participant_id') || null
                    };
                    
                    console.log('‚úÖ Authentication ready:', zadCurrentUser);
                }

                // Get current user (compatible with zad-helpers.ts)
                function getCurrentUser() {
                    if (!zadCurrentUser) return null;
                    
                    return {
                        username: zadCurrentUser.username || getUsername(),
                        id: zadCurrentUser.participantId || getParticipantId(),
                        userLabel: zadCurrentUser.username || getUsername(),
                        participantId: zadCurrentUser.participantId || getParticipantId(),
                        passcode: zadCurrentUser.passcode || null
                    };
                }

// Save data to ZAD API
async function save(type, data) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        const username = getUsername();
        
        const zadData = {
            app_id: app_id,
            participant_id: participant_id,
            participant_data: {
                userLabel: username,
                username: username
            },
            action_type: type,
            content_data: {
                ...data,
                timestamp: data.timestamp || Date.now(),
                author: data.author || username
            }
        };
        
        console.log('üîÑ Saving to ZAD API:', { type, data: zadData });
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(zadData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Save failed: ${errorData.error || response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Saved successfully:', result);
        return result;
        
    } catch (error) {
        console.error('‚ùå Save error:', error);
        alert(`Failed to save: ${error.message}`);
        throw error;
    }
}

// Phase 1 Authentication Backend Helper Functions
// These call the backend API with specific action types

// Backend Helper 1: Check Available Slots
async function checkAvailableSlots(silent = false) {
    try {
        const app_id = getAppId();
        
        console.log('üîç Calling backend checkAvailableSlots for app:', app_id);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'check_slots',
                content_data: {}
            })
        });
        
        if (!response.ok) {
            throw new Error(`Check slots failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend checkAvailableSlots result:', result.slots);
        
        return result.slots;
        
    } catch (error) {
        console.error('‚ùå Check slots error:', error);
        if (!silent) {
            alert(`Failed to check available slots: ${error.message}`);
        }
        return { totalSlots: 5, usedSlots: 0, availableSlots: 5, availableLabels: [], usedLabels: [], isFull: false };
    }
}

// Backend Helper 2: Generate User Credentials
async function generateUser() {
    try {
        const app_id = getAppId();
        
        console.log('üé≤ Calling backend generateUser for app:', app_id);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'generate_user',
                content_data: {}
            })
        });
        
        if (!response.ok) {
            throw new Error(`Generate user failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend generateUser result:', result);
        
        if (!result.success) {
            console.log('Failed to generate user:', result.error);
            return null;
        }
        
        return result.user;
        
    } catch (error) {
        console.error('‚ùå Generate user error:', error);
        return null;
    }
}

// Backend Helper 3: Register User
async function registerUser(userLabel, passcode, participantId) {
    try {
        const app_id = getAppId();
        
        console.log('üìù Calling backend registerUser for app:', app_id, 'user:', userLabel);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'register_user',
                content_data: {
                    userLabel: userLabel,
                    passcode: passcode,
                    participantId: participantId
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Register user failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend registerUser result:', result);
        
        if (!result.success) {
            console.log('Registration failed:', result.result?.error);
            return { success: false, error: result.result?.error };
        }
        
        return result.result;
        
    } catch (error) {
        console.error('‚ùå Register user error:', error);
        return { success: false, error: error.message };
    }
}

// Backend Helper 4: Authenticate User
async function authenticateUser(userLabel, passcode) {
    try {
        const app_id = getAppId();
        
        console.log('üîê Calling backend authenticateUser for app:', app_id, 'user:', userLabel);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'authenticate_user',
                content_data: {
                    userLabel: userLabel,
                    passcode: passcode
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Authentication failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend authenticateUser result:', result);
        
        if (!result.success) {
            alert(result.result?.error || 'Authentication failed');
            return { success: false, error: result.result?.error };
        }
        
        return result.result;
        
    } catch (error) {
        console.error('‚ùå Authentication error:', error);
        alert(`Authentication failed: ${error.message}`);
        return { success: false, error: error.message };
    }
}

// Backend Helper Function Test: greet(name)
// This demonstrates how backend helper functions work - all logic happens on server
async function greet(name) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        const username = getUsername();
        
        console.log('ü§ñ Calling backend greet function for:', name);
        
        // Simple client call - all logic happens on backend
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                participant_id: participant_id,
                participant_data: { userLabel: username, username: username },
                action_type: 'greet',
                content_data: { name: name }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Greet failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend greet function result:', result);
        
        // Return the backend-generated greeting
        return result.greeting;
        
    } catch (error) {
        console.error('‚ùå Greet error:', error);
        alert(`Greet failed: ${error.message}`);
        return 'Error generating greeting';
    }
}

// Backend Helper Function: generateImage(prompt, style)
// Generate AI images from text descriptions
async function generateImage(prompt, style) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        const username = getUsername();
        
        console.log('üé® Calling backend generateImage function for:', prompt);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                participant_id: participant_id,
                participant_data: { userLabel: username, username: username },
                action_type: 'generate_image',
                content_data: { 
                    prompt: prompt,
                    style: style || 'realistic'
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Image generation failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend generateImage function result:', result);
        
        return result.imageUrl;
        
    } catch (error) {
        console.error('‚ùå GenerateImage error:', error);
        alert(`Image generation failed: ${error.message}`);
        return '';
    }
}

// Backend Helper Function: generateText(prompt, options)
// Generate AI text responses
async function generateText(prompt, options = {}) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        const username = getUsername();
        
        console.log('ü§ñ Calling backend generateText function for:', prompt);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                participant_id: participant_id,
                participant_data: { userLabel: username, username: username },
                action_type: 'generate_text',
                content_data: { 
                    prompt: prompt,
                    maxTokens: options.maxTokens,
                    temperature: options.temperature,
                    systemPrompt: options.systemPrompt,
                    username: username
                }
            })
        });
        
        if (!response.ok) {
            throw new Error(`Text generation failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend generateText function result:', result);
        
        return result.text;
        
    } catch (error) {
        console.error('‚ùå GenerateText error:', error);
        alert(`Text generation failed: ${error.message}`);
        throw error;
    }
}

// Load data from ZAD API
async function load(type) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        
        console.log('üîÑ Loading from ZAD API:', { app_id, type, participant_id });
        
        const url = `/api/zad/load?app_id=${encodeURIComponent(app_id)}&action_type=${encodeURIComponent(type)}&participant_id=${encodeURIComponent(participant_id)}`;
        console.log('üîç ZAD load URL:', url);
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Load failed: ${errorData.error || response.statusText}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ Loaded successfully:', data);
        
        // Transform ZAD data back to simple format
        return data.map(item => ({
            id: item.id,
            ...item.content_data,
            author: item.content_data.author || item.participant_data?.username || 'Unknown',
            created_at: item.created_at
        }));
        
    } catch (error) {
        console.error('‚ùå Load error:', error);
        // Don't show alert for load errors - just return empty array
        // This prevents annoying alerts on initial page load
        return [];
    }
}

// Query data from ZAD API with flexible filtering
async function query(type, options = {}) {
    try {
        const app_id = getAppId();
        
        console.log('üîç Querying ZAD API:', { app_id, type, options });
        
        const queryData = {
            app_id: app_id,
            action_type: 'query',
            content_data: {
                type: type,
                ...options
            }
        };
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(queryData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Query failed: ${errorData.error || response.statusText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ Query completed successfully:', result);
        
        // Transform ZAD data back to simple format
        return result.data.map(item => ({
            id: item.id,
            ...item.content_data,
            author: item.content_data.author || item.participant_data?.username || 'Unknown',
            created_at: item.created_at
        }));
        
    } catch (error) {
        console.error('‚ùå Query error:', error);
        alert(`Failed to query: ${error.message}`);
        return [];
    }
}

                // Make functions globally available
                window.initAuth = initAuth;
                window.save = save;
                window.load = load;
                window.query = query;
                window.getAppId = getAppId;
                window.getParticipantId = getParticipantId;
                window.getUsername = getUsername;
                window.getCurrentUser = getCurrentUser;
                window.updateZadAuth = updateZadAuth;
                window.greet = greet; // Add greet function to window object
                window.generateImage = generateImage; // Add generateImage function to window object
                window.generateText = generateText; // Add generateText function to window object
                window.checkAvailableSlots = checkAvailableSlots;
                window.generateUser = generateUser;
                window.registerUser = registerUser;
                window.authenticateUser = authenticateUser;

console.log('üöÄ ZAD Helper Functions loaded successfully');
                console.log('Available functions: initAuth(), save(type, data), load(type), query(type, options), updateZadAuth(userLabel, participantId), greet(name), generateImage(prompt, style), generateText(prompt, options)');
console.log('üîë Phase 1 Auth functions: checkAvailableSlots(), generateUser(), registerUser(label, code, id), authenticateUser(label, code)');

// DEMO MODE: Complete demo mode implementation with localStorage isolation
if (window.location.search.includes('demo=true')) {
    console.log('üé≠ DEMO MODE - Activating complete demo mode');
    
    // Create fake demo user credentials
    let demoUser = {
        userLabel: 'Demo User',
        participantId: 'demo-user-' + Math.random().toString(36).substr(2, 8),
        username: 'Demo User'
    };
    
    // Override ZAD helper functions to use localStorage instead of backend
    const originalSave = window.save;
    window.save = async function(type, data) {
        try {
            const demoKey = `demo_${type}_${demoUser.participantId}`;
            const existing = JSON.parse(localStorage.getItem(demoKey) || '[]');
            
            const newItem = {
                id: Date.now(),
                created_at: new Date().toISOString(),
                author: data.author || demoUser.userLabel,
                ...data
            };
            
            existing.push(newItem);
            localStorage.setItem(demoKey, JSON.stringify(existing));
            
            console.log('üé≠ Demo save:', { type, data: newItem });
            return { success: true, data: newItem };
            
        } catch (error) {
            console.error('‚ùå Demo save error:', error);
            return { success: false, error: error.message };
        }
    };
    
    const originalLoad = window.load;
    window.load = async function(type) {
        try {
            const demoKey = `demo_${type}_${demoUser.participantId}`;
            const data = JSON.parse(localStorage.getItem(demoKey) || '[]');
            
            // Transform demo data to match real ZAD API structure
            const transformedData = data.map(item => {
                // Extract metadata fields
                const { id, created_at, author, ...contentData } = item;
                
                // Return in same format as real ZAD API: content_data contains the actual data
                return {
                    id: id,
                    created_at: created_at,
                    content_data: contentData,
                    author: author || demoUser.userLabel
                };
            });
            
            console.log('üé≠ Demo load:', { type, count: transformedData.length });
            return transformedData;
            
        } catch (error) {
            console.error('‚ùå Demo load error:', error);
            return [];
        }
    };
    
    // Override authentication functions to work with demo user
    window.getCurrentUser = function() {
        return demoUser;
    };
    
    window.getUsername = function() {
        return demoUser.userLabel;
    };
    
    window.getParticipantId = function() {
        return demoUser.participantId;
    };
    
    // Set global currentUser for apps that expect it
    if (typeof window.currentUser === 'undefined') {
        window.currentUser = demoUser;
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        // Hide welcome/auth screens and show main screen
        const welcomeScreen = document.getElementById('welcome-screen');
        const mainScreen = document.getElementById('main-screen');
        
        if (welcomeScreen && mainScreen) {
            welcomeScreen.style.display = 'none';
            mainScreen.style.display = 'block';
            console.log('üé≠ Auth screens bypassed for demo mode');
        }
        
        // Add demo banner if user status exists
        const userStatus = document.getElementById('user-status');
        if (userStatus) {
            userStatus.innerHTML = 'üé≠ DEMO MODE - Try it out! Data saved locally.';
        }
        
        // Update user display elements
        const userLabelElements = document.querySelectorAll('#current-user-label, .current-user-label');
        userLabelElements.forEach(elem => {
            elem.textContent = demoUser.userLabel;
        });
        
        // Auto-initialize demo user authentication state
        if (typeof window.updateZadAuth === 'function') {
            window.updateZadAuth(demoUser.userLabel, demoUser.participantId);
        }
        
        console.log('üé≠ Demo mode fully activated:', demoUser);
    });
}

// IMMEDIATE GALLERY LOADING: Wait for DOM then load gallery immediately
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('üé® Loading gallery immediately on page load...');
        // Ensure we have a participant ID for loading (temp one is fine)
        getParticipantId();
        
        const artworks = await load('artwork');
        const gallery = document.getElementById('gallery');
        if (gallery) {
            gallery.innerHTML = '';
            
            artworks.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .forEach(artwork => {
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    item.innerHTML = `
                        <img src="${artwork.image}" alt="Artwork">
                        <p>By: ${artwork.name}</p>
                    `;
                    gallery.appendChild(item);
                });
            
            console.log('‚úÖ Gallery loaded immediately with', artworks.length, 'artworks');
        }
    } catch (error) {
        console.log('‚ö†Ô∏è Initial gallery load failed, will retry after auth:', error);
    }
});

</script>
</head>
<body>
    <div class="app-container">
        <h1>RETRO PAINT 98</h1>

        <div class="canvas-container">
            <canvas id="paintCanvas" width="400" height="400"></canvas>
        </div>

        <div class="toolbar">
            <button id="pencilBtn">‚úèÔ∏è</button>
            <button id="brushBtn">üñåÔ∏è</button>
            <button id="mysteryBtn">üé≤</button>
            <button id="undoBtn">‚Ü©Ô∏è</button>
            <div class="control-group">
                <input type="color" id="colorPicker" value="#000000">
                <input type="range" id="sizeSlider" min="1" max="50" value="5">
                <div id="sizePreview" style="width: 20px; height: 20px; background: #333; border-radius: 50%; transition: all 0.2s;"></div>
            </div>
            <button id="saveBtn">üíæ</button>
        </div>

        <h2 style="color: #FF4B4B; margin-top: 40px;">GALLERY WALL</h2>
        <div id="gallery" class="gallery"></div>
    </div>

    <script>
        let currentUser = null;
        let isDrawing = false;
        let currentTool = 'pencil';
        let mysteryMode = 'neon';
        let lastX = 0;
        let lastY = 0;
        let hue = 0;
        let poolingTime = 0;
        let poolingColor = 0;
        let lastPoolX = 0;
        let lastPoolY = 0;
        
        // Progressive spray chaos tracking
        let dragTime = 0;
        let dragStartTime = 0;
        let sprayBaseColor = 0;
        
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d');
        const undoStack = [];
        
        // Resize canvas to fit mobile viewport
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const containerWidth = container.clientWidth - 20; // Account for padding
            const maxCanvasSize = Math.min(containerWidth, 400); // Max 400px or container width
            
            // Set canvas display size
            canvas.style.width = maxCanvasSize + 'px';
            canvas.style.height = maxCanvasSize + 'px';
            
            // Set actual canvas resolution (keep it at 400x400 for drawing quality)
            // This maintains drawing quality while scaling display
        }
        
        // Initialize canvas
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        saveCanvasState();
        
        // Size preview functionality
        const sizeSlider = document.getElementById('sizeSlider');
        const sizePreview = document.getElementById('sizePreview');
        const colorPicker = document.getElementById('colorPicker');
        
        function updateSizePreview() {
            const size = Math.min(parseInt(sizeSlider.value), 30); // Cap preview at 30px for UI
            sizePreview.style.width = size + 'px';
            sizePreview.style.height = size + 'px';
            sizePreview.style.background = colorPicker.value;
        }
        
        sizeSlider.addEventListener('input', updateSizePreview);
        colorPicker.addEventListener('input', updateSizePreview);
        updateSizePreview(); // Initial update

        // Tool selection
        document.getElementById('pencilBtn').onclick = () => {
            currentTool = 'pencil';
            ctx.globalCompositeOperation = 'source-over';
        };
        
        document.getElementById('brushBtn').onclick = () => {
            currentTool = 'brush';
            ctx.globalCompositeOperation = 'source-over';
        };
        
        document.getElementById('mysteryBtn').onclick = () => {
            currentTool = 'mystery';
            mysteryMode = mysteryMode === 'neon' ? 'rainbow' : 'neon';
            ctx.globalCompositeOperation = 'lighter';
        };
        
        document.getElementById('undoBtn').onclick = () => {
            if (undoStack.length > 1) {
                undoStack.pop();
                const lastState = undoStack[undoStack.length - 1];
                const img = new Image();
                img.onload = () => {
                    // Clear canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // Reset composite operation to default
                    ctx.globalCompositeOperation = 'source-over';
                    // Draw the saved state
                    ctx.drawImage(img, 0, 0);
                };
                img.src = lastState;
            }
        };

        // Drawing functions
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getCoords(e);
            // Reset drag tracking for new stroke
            dragStartTime = Date.now();
            dragTime = 0;
            sprayBaseColor = Math.random() * 360;
        }

        function draw(e) {
            if (!isDrawing) return;

            const [currentX, currentY] = getCoords(e);
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);

            if (currentTool === 'pencil') {
                ctx.lineWidth = document.getElementById('sizeSlider').value;
                ctx.strokeStyle = document.getElementById('colorPicker').value;
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
            } else if (currentTool === 'brush') {
                ctx.lineWidth = document.getElementById('sizeSlider').value * 2;
                ctx.strokeStyle = document.getElementById('colorPicker').value;
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
            } else if (currentTool === 'mystery') {
                if (mysteryMode === 'neon') {
                    // PROGRESSIVE CHAOS SPRAY - Gets wilder the longer you drag!
                    dragTime = (Date.now() - dragStartTime) / 100; // Convert to deciseconds
                    
                    // Everything grows with drag time
                    const chaosLevel = Math.min(dragTime / 10, 3); // Max 3x chaos
                    const sprayRadius = document.getElementById('sizeSlider').value * (4 + chaosLevel * 4);
                    const density = Math.floor(40 + chaosLevel * 40);
                    const baseHue = sprayBaseColor;
                    
                    // Save current composite mode
                    const prevComposite = ctx.globalCompositeOperation;
                    
                    // First pass: Solid color center (gets messier with time)
                    ctx.globalCompositeOperation = 'source-over';
                    for (let i = 0; i < density / 2; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * sprayRadius * (0.3 + Math.random() * 0.4);
                        const dotX = currentX + Math.cos(angle) * distance;
                        const dotY = currentY + Math.sin(angle) * distance;
                        
                        const hueVariation = (Math.random() - 0.5) * (30 + chaosLevel * 20);
                        const dotHue = (baseHue + hueVariation + 360) % 360;
                        const dotSize = (Math.random() * 8 + 4) * (1 + chaosLevel * 0.3);
                        
                        ctx.beginPath();
                        ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
                        ctx.fillStyle = `hsl(${dotHue}, 100%, ${50 - chaosLevel * 10}%)`; // Darker as chaos increases
                        ctx.fill();
                    }
                    
                    // Second pass: Outer spray with glow effect
                    ctx.globalCompositeOperation = prevComposite; // Back to 'lighter'
                    for (let i = 0; i < density / 2; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * sprayRadius * (0.5 + Math.random() * 0.5);
                        const dotX = currentX + Math.cos(angle) * distance;
                        const dotY = currentY + Math.sin(angle) * distance;
                        
                        const hueVariation = (Math.random() - 0.5) * 60;
                        const dotHue = (baseHue + hueVariation + 360) % 360;
                        const dotSize = Math.random() * 8 + 2;
                        
                        ctx.beginPath();
                        ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${dotHue}, 100%, 50%, ${0.6 + Math.random() * 0.4})`;
                        ctx.fill();
                    }
                    
                    // DRIPS GET CRAZIER WITH TIME!
                    const dripChance = Math.min(0.1 + chaosLevel * 0.3, 0.8); // Up to 80% drip chance
                    const maxDrips = Math.floor(1 + chaosLevel * 3); // Up to 4 drips at max chaos
                    
                    for (let d = 0; d < maxDrips; d++) {
                        if (Math.random() < dripChance) {
                            const dripX = currentX + (Math.random() - 0.5) * sprayRadius;
                            const dripLength = (Math.random() * 50 + 30) * (1 + chaosLevel);
                            ctx.beginPath();
                            ctx.moveTo(dripX, currentY);
                            
                            // Multiple drip segments for more organic look
                            let dripY = currentY;
                            for (let seg = 0; seg < 3; seg++) {
                                dripY += dripLength / 3;
                                const wiggle = (Math.random() - 0.5) * 20 * chaosLevel;
                                ctx.lineTo(dripX + wiggle, dripY);
                            }
                            
                            ctx.lineWidth = (Math.random() * 8 + 4) * (1 + chaosLevel * 0.5);
                            ctx.strokeStyle = `hsla(${baseHue + (Math.random() - 0.5) * 30}, 100%, 50%, 0.8)`;
                            ctx.stroke();
                        }
                    }
                } else {
                    ctx.lineWidth = document.getElementById('sizeSlider').value * 2;
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    hue = (hue + 2) % 360;
                }
            }

            [lastX, lastY] = [currentX, currentY];
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveCanvasState();
            }
        }

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            return [x, y];
        }

        function saveCanvasState() {
            undoStack.push(canvas.toDataURL());
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        // Simplified touch event handlers
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent any default touch behaviors
            startDrawing(e);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopDrawing();
        });

        // Save artwork
        document.getElementById('saveBtn').onclick = async () => {
            const name = prompt("What's your name, artist?");
            if (name) {
                const artwork = {
                    image: canvas.toDataURL(),
                    name: name,
                    timestamp: new Date().toISOString()
                };
                await save('artwork', artwork);
                loadLatestData();
                
                // Clear canvas
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                undoStack.length = 0;
                saveCanvasState();
            }
        };

        // Load and display gallery
        async function loadLatestData() {
            const artworks = await load('artwork');
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            
            artworks.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .forEach(artwork => {
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    item.innerHTML = `
                        <img src="${artwork.image}" alt="Artwork">
                        <p>By: ${artwork.name}</p>
                    `;
                    gallery.appendChild(item);
                });
        }

        // Generate anonymous user for public mode
        async function generateAnonymousUser() {
            // Anonymous user labels (auto-rotating)
            const ANON_LABELS = [
                'Anon1üéØ', 'Anon2‚ö°', 'Anon3üåü', 'Anon4üî•', 'Anon5üíé', 'Anon6üöÄ', 'Anon7üé®', 'Anon8üåô',
                'Guest1üé≠', 'Guest2üé™', 'Guest3üé®', 'Guest4üéµ', 'Visitor1üåä', 'Visitor2üåà', 'Visitor3‚≠ê',
                'User1üé≤', 'User2üéØ', 'User3üéÆ', 'User4üé™', 'Someone1üåü', 'Someone2üí´', 'Someone3üîÆ'
            ];
            
            // Pick a random anonymous label
            const userLabel = ANON_LABELS[Math.floor(Math.random() * ANON_LABELS.length)];
            const participantId = 'anon_' + Math.random().toString(36).substr(2, 12);
            
            return {
                success: true,
                userLabel: userLabel,
                participantId: participantId,
                username: userLabel
            };
        }

        // Initialize public mode and start auto-refresh
        async function initPublicMode() {
            // Generate anonymous user immediately
            currentUser = await generateAnonymousUser();
            if (currentUser?.success) {
                updateZadAuth(currentUser.userLabel, currentUser.participantId);
            }
            
            // Start polling for gallery updates
            startPolling();
            
            // Load initial gallery data
            loadLatestData();
        }

        let pollingInterval;
        function startPolling() {
            pollingInterval = setInterval(() => loadLatestData(), 2000);
        }

        // Initialize the app
        initPublicMode();
    </script>
</body>
</html>