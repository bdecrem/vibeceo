<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Tap Beats ğŸµ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; 
      height: 100%; 
      overflow: hidden;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      background: #09090b;
    }
    canvas { 
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TAP BEATS â€” A Tap Tap Revenge tribute
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    // â”€â”€â”€ THEME (INDIE BITE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const THEME = {
      void: '#09090b',
      lane0: '#22d3ee',  // cyan - left
      lane1: '#ec4899',  // pink - center
      lane2: '#facc15',  // gold - right
      perfect: '#a3e635', // slime green
      good: '#22d3ee',    // cyan
      miss: '#ef4444',    // red
      text: '#f8fafc',
    };
    
    const LANE_COLORS = [THEME.lane0, THEME.lane1, THEME.lane2];
    
    // â”€â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioCtx = null;
    let masterGain = null;
    let musicStartTime = 0;
    
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5;
      masterGain.connect(audioCtx.destination);
      
      // Resume on iOS
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }
    
    // Play a synth note
    function playNote(freq, duration = 0.1, type = 'square', volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    
    // Play feedback sounds
    function playPerfect() {
      playNote(880, 0.1, 'sine', 0.4);
      playNote(1108, 0.15, 'sine', 0.3);
    }
    
    function playGood() {
      playNote(660, 0.1, 'sine', 0.3);
    }
    
    function playMiss() {
      playNote(150, 0.2, 'sawtooth', 0.2);
    }
    
    // â”€â”€â”€ SONGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const SONGS = [
      {
        id: 'robot-rave-lite',
        name: 'ROBOT RAVE LITE',
        artist: 'PixelPit',
        bpm: 150,
        duration: 56000,
        difficulty: 'â˜…â˜…â˜†',
        locked: false,
        description: 'Part 1 - Learn the moves',
      },
      {
        id: 'ddr-rave',
        name: 'DDR RAVE',
        artist: 'PixelPit',
        bpm: 170,
        duration: 60000,
        difficulty: 'â˜…â˜…â˜…',
        locked: true, // Unlock by beating Part 1 with grade C or better
        description: 'Part 2 - Full rave chaos',
      },
    ];
    
    let currentSongIndex = 0;
    let song2Unlocked = localStorage.getItem('tapBeats_song2Unlocked') === 'true';
    if (song2Unlocked) SONGS[1].locked = false;
    
    // â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let w, h;
    let gameState = 'songSelect'; // songSelect, playing, results
    
    const NUM_LANES = 3;
    const HIT_ZONE_Y = 0.85; // 85% down the screen
    const NOTE_SPEED = 400; // pixels per second
    const PERFECT_WINDOW = 50; // ms
    const GOOD_WINDOW = 150; // ms
    
    // Timing
    let songTime = 0; // Current position in song (ms)
    let bpm = 150;
    let beatInterval = 60000 / bpm;
    
    // Notes
    let notes = []; // Active notes on screen
    let nextNoteIndex = 0;
    
    // Score
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let perfects = 0;
    let goods = 0;
    let misses = 0;
    
    // Visual feedback
    let hitEffects = []; // { x, y, color, alpha, scale, text }
    let screenFlash = 0;
    let lanePulse = [0, 0, 0]; // Per-lane pulse intensity
    
    // â”€â”€â”€ BEATMAP (Song 1: Robot Rave Lite @ 150 BPM) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // time = ms from song start, lane = 0/1/2
    
    function generateBeatmapSong1() {
      const beat = 60000 / 150; // 150 BPM = 400ms per beat
      const map = [];
      
      // INTRO (0-3.2s): Quick intro - hit on beats
      for (let t = 1200; t < 3200; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      
      // VERSE 1 (3.2-9.6s): Fast alternating, 8th notes - DDR style
      let lane = 0;
      for (let t = 3200; t < 9600; t += beat / 2) {
        map.push({ time: t, lane: lane });
        lane = (lane + 1) % 3;
      }
      
      // BUILD 1 (9.6-12.8s): Sparse, building tension
      for (let t = 9600; t < 12800; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      
      // DROP 1 (12.8-22.4s): INTENSE - melody pattern + offbeats
      const melodyPattern = [1, 2, 1, 0, 2, 0, 1, 2]; // More varied DDR pattern
      for (let t = 12800; t < 22400; t += beat / 2) {
        const beatInPhrase = Math.floor((t - 12800) / (beat / 2)) % 8;
        const noteLane = melodyPattern[beatInPhrase];
        map.push({ time: t, lane: noteLane });
        // Add doubles on strong beats
        if (beatInPhrase % 4 === 0 && Math.random() < 0.4) {
          map.push({ time: t, lane: (noteLane + 1) % 3 });
        }
      }
      
      // VERSE 2 (22.4-28.8s): Wave pattern
      for (let t = 22400; t < 28800; t += beat / 2) {
        const pos = Math.floor((t - 22400) / (beat / 2));
        const wave = Math.floor(1.5 + Math.sin(pos * 0.5) * 1.5);
        map.push({ time: t, lane: wave });
      }
      
      // BUILD 2 (28.8-32s): Accelerating
      let interval = beat;
      for (let t = 28800; t < 32000; t += interval) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        interval = Math.max(interval * 0.9, beat / 4);
      }
      
      // (continued) DROP 2 - intensity!
        map.push({ time: t, lane: noteLane });
        
        // 35% chance of double for harder difficulty
        if (Math.random() < 0.35) {
          const otherLane = (noteLane + 1 + Math.floor(Math.random() * 2)) % 3;
          map.push({ time: t, lane: otherLane });
        }
      }
      
      // OUTRO (48-56s): Cool down - quarter notes
      for (let t = 48000; t < 54000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      // Final triple hit
      map.push({ time: 55000, lane: 0 });
      map.push({ time: 55000, lane: 1 });
      map.push({ time: 55000, lane: 2 });
      
      // Sort by time
      map.sort((a, b) => a.time - b.time);
      
      return map;
    }
    
    // â”€â”€â”€ BEATMAP (Song 2: DDR Rave @ 170 BPM) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function generateBeatmapSong2() {
      const beat = 60000 / 170; // 170 BPM = 353ms per beat - FAST!
      const map = [];
      
      // INTRO (0-4s): Kick only - get ready
      for (let t = 1000; t < 4000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      
      // VERSE 1 (4-12s): 8th notes, alternating
      let lane = 0;
      for (let t = 4000; t < 12000; t += beat / 2) {
        map.push({ time: t, lane: lane });
        lane = (lane + 1) % 3;
      }
      
      // BUILD 1 (12-16s): Tension
      for (let t = 12000; t < 16000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      
      // DROP 1 (16-28s): INTENSE - pentatonic pattern
      const pentaPattern = [0, 1, 2, 1, 0, 2, 1, 0];
      for (let t = 16000; t < 28000; t += beat / 2) {
        const idx = Math.floor((t - 16000) / (beat / 2)) % 8;
        map.push({ time: t, lane: pentaPattern[idx] });
        // Add doubles frequently
        if (Math.random() < 0.3) {
          map.push({ time: t, lane: (pentaPattern[idx] + 1) % 3 });
        }
      }
      
      // VERSE 2 (28-36s): Wave pattern
      for (let t = 28000; t < 36000; t += beat / 2) {
        const wave = Math.floor(1.5 + Math.sin((t - 28000) * 0.003) * 1.5);
        map.push({ time: t, lane: wave });
      }
      
      // BUILD 2 (36-40s): Accelerating chaos
      let interval = beat;
      for (let t = 36000; t < 40000; t += interval) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        interval = Math.max(interval * 0.85, beat / 4);
      }
      
      // DROP 2 (40-56s): MAXIMUM RAVE - 16th notes + doubles
      for (let t = 40000; t < 56000; t += beat / 2) {
        const idx = Math.floor((t - 40000) / (beat / 2)) % 8;
        map.push({ time: t, lane: pentaPattern[idx] });
        // 40% doubles - it's chaos!
        if (Math.random() < 0.4) {
          map.push({ time: t, lane: (pentaPattern[idx] + 1 + Math.floor(Math.random() * 2)) % 3 });
        }
      }
      
      // OUTRO (56-60s): Cool down
      for (let t = 56000; t < 59000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      // Final triple
      map.push({ time: 59500, lane: 0 });
      map.push({ time: 59500, lane: 1 });
      map.push({ time: 59500, lane: 2 });
      
      map.sort((a, b) => a.time - b.time);
      return map;
    }
    
    // â”€â”€â”€ PROCEDURAL MUSIC (Song 1: Robot Rave Lite @ 150 BPM) â”€â”€â”€â”€â”€â”€â”€â”€
    let musicNodes = [];
    
    // Note frequencies
    const NOTE = {
      A2: 110, E2: 82.41, F2: 87.31, G2: 98, D2: 73.42,
      A1: 55, D1: 36.71,
      G4: 392, A4: 440, B4: 493.88, C5: 523.25, D5: 587.33, E5: 659.25,
      A3: 220, C4: 261.63, E4: 329.63, D4: 293.66,
    };
    
    // Song structure - Robot Rave DDR style (faster, harder)
    const SONG = {
      intro: { start: 0, end: 3.2 },    // 8 beats @ 150 BPM
      verse1: { start: 3.2, end: 9.6 },  // Driving groove
      build1: { start: 9.6, end: 12.8 }, // Rising tension
      drop1: { start: 12.8, end: 22.4 }, // MASSIVE DROP
      verse2: { start: 22.4, end: 28.8 },// Breathing room
      build2: { start: 28.8, end: 32 },  // Final build
      drop2: { start: 32, end: 48 },     // EXTENDED DROP - party time
      outro: { start: 48, end: 56 },     // Cool down
    };
    
    // DDR-style melodic hook - more notes, more energy
    const MELODY = [
      { note: NOTE.A4, beat: 0 },
      { note: NOTE.C5, beat: 0.5 },
      { note: NOTE.A4, beat: 1 },
      { note: NOTE.E5, beat: 1.5 },
      { note: NOTE.D5, beat: 2 },
      { note: NOTE.C5, beat: 2.5 },
      { note: NOTE.A4, beat: 3 },
      { note: NOTE.G4, beat: 3.5 },
    ];
    
    // Robot Rave bass: A - A - D - A (driving techno)
    const BASS = [
      { note: NOTE.A1, bar: 0 },
      { note: NOTE.A1, bar: 1 },
      { note: NOTE.D2, bar: 2 },
      { note: NOTE.A1, bar: 3 },
    ];
    
    function startMusicSong1() {
      if (!audioCtx) return;
      musicStartTime = audioCtx.currentTime;
      
      const beatSec = 60 / 150; // 150 BPM - DDR speed!
      const barSec = beatSec * 4;
      
      // Schedule all music - Robot Rave DDR style
      scheduleKicks(beatSec);
      scheduleHiHats(beatSec);
      scheduleClaps(beatSec);
      scheduleBass(beatSec, barSec);
      scheduleRaveSynth(beatSec);    // Robot rave lead
      scheduleArpeggio(beatSec);     // Fast arpeggio
      scheduleRiser(beatSec);
    }
    
    function inSection(timeSec, section) {
      return timeSec >= section.start && timeSec < section.end;
    }
    
    function isDrumSection(timeSec) {
      // Drums play except during builds
      return !inSection(timeSec, SONG.build1) && !inSection(timeSec, SONG.build2);
    }
    
    function isDropSection(timeSec) {
      return inSection(timeSec, SONG.drop1) || inSection(timeSec, SONG.drop2);
    }
    
    function scheduleKicks(beatSec) {
      for (let t = 0; t < 60; t += beatSec) {
        if (isDrumSection(t)) {
          scheduleKick(musicStartTime + t, isDropSection(t) ? 0.5 : 0.35);
        }
      }
    }
    
    function scheduleKick(time, volume = 0.4) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(35, time + 0.12);
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.25);
    }
    
    function scheduleHiHats(beatSec) {
      for (let t = 0; t < 60; t += beatSec / 2) {
        if (isDrumSection(t) && t >= SONG.verse1.start) {
          const isOffbeat = Math.round(t / beatSec * 2) % 2 === 1;
          scheduleHiHat(musicStartTime + t, isOffbeat ? 0.08 : 0.12);
        }
      }
    }
    
    function scheduleHiHat(time, volume = 0.1) {
      const bufferSize = audioCtx.sampleRate * 0.04;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 9000;
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      noise.start(time);
      noise.stop(time + 0.04);
    }
    
    function scheduleClaps(beatSec) {
      for (let t = 0; t < 60; t += beatSec) {
        const beatInBar = Math.round(t / beatSec) % 4;
        // Clap on beats 2 and 4 - modern pop style
        if ((beatInBar === 1 || beatInBar === 3) && isDrumSection(t) && t >= SONG.verse1.start) {
          scheduleClap(musicStartTime + t, isDropSection(t) ? 0.4 : 0.3);
        }
      }
    }
    
    function scheduleClap(time, volume = 0.3) {
      // Layered clap sound - more pop, less harsh
      for (let i = 0; i < 3; i++) {
        const bufferSize = audioCtx.sampleRate * 0.08;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          data[j] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1500 + i * 500; // Spread across frequencies
        filter.Q.value = 2;
        
        const gain = audioCtx.createGain();
        const offset = i * 0.01; // Slight timing spread for thickness
        gain.gain.setValueAtTime(volume * 0.4, time + offset);
        gain.gain.exponentialRampToValueAtTime(0.001, time + offset + 0.1);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        noise.start(time + offset);
        noise.stop(time + offset + 0.1);
      }
    }
    
    function scheduleBass(beatSec, barSec) {
      for (let t = SONG.verse1.start; t < 60; t += barSec) {
        if (t >= SONG.build1.start && t < SONG.drop1.start) continue;
        if (t >= SONG.build2.start && t < SONG.drop2.start) continue;
        
        const barIndex = Math.floor((t - SONG.verse1.start) / barSec) % 4;
        const bassNote = BASS[barIndex].note;
        const volume = isDropSection(t) ? 0.3 : 0.2;
        
        // Play bass on beat 1 and 3 of each bar
        scheduleBassNote(musicStartTime + t, bassNote, beatSec * 1.5, volume);
        scheduleBassNote(musicStartTime + t + beatSec * 2, bassNote, beatSec * 1.5, volume);
      }
    }
    
    function scheduleBassNote(time, freq, duration, volume = 0.25) {
      // Modern sub bass - clean sine with subtle saturation
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.type = 'sine';
      osc.frequency.value = freq;
      osc2.type = 'sine';
      osc2.frequency.value = freq * 2; // Subtle harmonic
      
      const subGain = audioCtx.createGain();
      const harmGain = audioCtx.createGain();
      subGain.gain.value = 1;
      harmGain.gain.value = 0.3;
      
      // Punchy envelope
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(volume, time + 0.02);
      gain.gain.exponentialRampToValueAtTime(volume * 0.6, time + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
      
      osc.connect(subGain);
      osc2.connect(harmGain);
      subGain.connect(gain);
      harmGain.connect(gain);
      gain.connect(masterGain);
      
      osc.start(time);
      osc2.start(time);
      osc.stop(time + duration);
      osc2.stop(time + duration);
    }
    
    function scheduleRaveSynth(beatSec) {
      // Robot Rave style lead - plays during drops with 8th note melody
      const sections = [SONG.drop1, SONG.drop2];
      
      for (const section of sections) {
        for (let t = section.start; t < section.end; t += beatSec / 2) {
          const beatInRiff = ((t - section.start) / (beatSec / 2)) % 8;
          const melodyNote = MELODY.find(m => Math.abs(m.beat - beatInRiff) < 0.1);
          
          if (melodyNote && melodyNote.note) {
            scheduleRaveNote(musicStartTime + t, melodyNote.note, beatSec * 0.4, 0.2);
          }
        }
      }
    }
    
    function scheduleRaveNote(time, freq, duration, volume) {
      // Aggressive sawtooth lead with filter
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc1.type = 'sawtooth';
      osc1.frequency.value = freq;
      osc2.type = 'sawtooth';
      osc2.frequency.value = freq * 1.01; // Slight detune for thickness
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(3000, time);
      filter.frequency.exponentialRampToValueAtTime(800, time + duration);
      filter.Q.value = 5; // Resonance for that rave sound
      
      // Punchy envelope
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
      
      osc1.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc1.start(time);
      osc2.start(time);
      osc1.stop(time + duration);
      osc2.stop(time + duration);
    }
    
    function scheduleArpeggio(beatSec) {
      // Fast 16th note arpeggio during drops - classic DDR feel
      const arpNotes = [NOTE.A3, NOTE.C4, NOTE.E4, NOTE.A4, NOTE.E4, NOTE.C4];
      
      for (const section of [SONG.drop1, SONG.drop2]) {
        let noteIndex = 0;
        for (let t = section.start; t < section.end; t += beatSec / 4) {
          const freq = arpNotes[noteIndex % arpNotes.length];
          scheduleArpNote(musicStartTime + t, freq, beatSec / 4, 0.1);
          noteIndex++;
        }
      }
      
      // Also during verses but quieter
      for (let t = SONG.verse1.start; t < SONG.build1.start; t += beatSec / 4) {
        const freq = arpNotes[Math.floor((t - SONG.verse1.start) / (beatSec / 4)) % arpNotes.length];
        scheduleArpNote(musicStartTime + t, freq, beatSec / 4, 0.05);
      }
      for (let t = SONG.verse2.start; t < SONG.build2.start; t += beatSec / 4) {
        const freq = arpNotes[Math.floor((t - SONG.verse2.start) / (beatSec / 4)) % arpNotes.length];
        scheduleArpNote(musicStartTime + t, freq, beatSec / 4, 0.05);
      }
    }
    
    function scheduleArpNote(time, freq, duration, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration * 0.8);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + duration);
    }
    
    function scheduleSynthStabs(beatSec) {
      // Offbeat stabs during drops (on the "and" of 2 and 4)
      for (const section of [SONG.drop1, SONG.drop2]) {
        for (let t = section.start; t < section.end; t += beatSec) {
          const beatInBar = Math.round((t - section.start) / beatSec) % 4;
          // Stab on offbeat after beat 2 and 4
          if (beatInBar === 1 || beatInBar === 3) {
            scheduleSynthStab(musicStartTime + t + beatSec / 2);
          }
        }
      }
    }
    
    function scheduleSynthStab(time) {
      // Am chord: A3, C4, E4
      const chord = [NOTE.A3, NOTE.C4, NOTE.E4];
      for (const freq of chord) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500;
        
        gain.gain.setValueAtTime(0.08, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + 0.1);
      }
    }
    
    function scheduleRiser(beatSec) {
      // Rising synth during builds
      for (const build of [SONG.build1, SONG.build2]) {
        const duration = build.end - build.start;
        const time = musicStartTime + build.start;
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, time);
        osc.frequency.exponentialRampToValueAtTime(800, time + duration);
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(500, time);
        filter.frequency.exponentialRampToValueAtTime(4000, time + duration);
        
        gain.gain.setValueAtTime(0.05, time);
        gain.gain.linearRampToValueAtTime(0.2, time + duration - 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + duration);
      }
    }
    
    function stopMusic() {
      musicNodes.forEach(node => {
        try { node.stop(); } catch(e) {}
        try { node.disconnect(); } catch(e) {}
      });
      musicNodes = [];
    }
    
    // â”€â”€â”€ PROCEDURAL MUSIC (Song 2: DDR Rave @ 170 BPM) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DDR Rave melody notes (pentatonic - always sounds good)
    const DDR_MELODY = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
    const DDR_MELODY_PATTERN = [0, 2, 4, 2, 5, 4, 2, 0, 3, 5, 7, 5, 4, 2, 0, 2];
    const DDR_CHORDS = [
      [261.63, 329.63, 392.00], // C major
      [293.66, 369.99, 440.00], // D minor
      [349.23, 440.00, 523.25], // F major
      [392.00, 493.88, 587.33], // G major
    ];
    const DDR_BASS = [130.81, 130.81, 146.83, 164.81]; // C3, C3, D3, E3
    
    let song2Beat = 0;
    let song2BeatInterval = null;
    let song2MelodyPhase = 0;
    
    function startMusicSong2() {
      if (!audioCtx) return;
      musicStartTime = audioCtx.currentTime;
      song2Beat = 0;
      song2MelodyPhase = 0;
      
      const beatMs = 60000 / 170; // 170 BPM
      
      // Use setInterval for the rave feel (like ddr-rave.html)
      song2BeatInterval = setInterval(() => {
        song2Beat++;
        
        // Kick on 1 and 3
        if (song2Beat % 4 === 0 || song2Beat % 4 === 2) playDDRKick();
        
        // Snare on 2 and 4
        if (song2Beat % 4 === 1 || song2Beat % 4 === 3) playDDRSnare();
        
        // Hi-hat on every beat + offbeats
        playDDRHihat();
        setTimeout(() => playDDRHihat(), beatMs / 2);
        
        // Bass on every beat
        playDDRBass();
        
        // Melody
        playDDRMelody();
        
        // Arpeggio every 2 beats
        if (song2Beat % 2 === 0) playDDRArpeggio();
        
        // Chord stabs every 4 beats
        if (song2Beat % 4 === 0) playDDRChord();
        
      }, beatMs);
    }
    
    function playDDRKick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(180, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(35, audioCtx.currentTime + 0.08);
      gain.gain.setValueAtTime(0.7, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    }
    
    function playDDRSnare() {
      const bufferSize = audioCtx.sampleRate * 0.1;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
      }
      const source = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 3000;
      source.buffer = buffer;
      gain.gain.value = 0.35;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      source.start();
      
      // Tone
      const osc = audioCtx.createOscillator();
      const oscGain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.value = 200;
      oscGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
      oscGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
      osc.connect(oscGain);
      oscGain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.08);
    }
    
    function playDDRHihat() {
      const bufferSize = audioCtx.sampleRate * 0.03;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.08));
      }
      const source = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 8000;
      source.buffer = buffer;
      gain.gain.value = 0.1;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      source.start();
    }
    
    function playDDRBass() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      const note = DDR_BASS[song2Beat % 4];
      osc.type = 'sawtooth';
      osc.frequency.value = note;
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(800, audioCtx.currentTime);
      filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    }
    
    function playDDRMelody() {
      song2MelodyPhase++;
      const noteIndex = DDR_MELODY_PATTERN[song2MelodyPhase % DDR_MELODY_PATTERN.length];
      const note = DDR_MELODY[noteIndex];
      
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = 'square';
      osc.frequency.value = note;
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    }
    
    function playDDRArpeggio() {
      const chordIndex = Math.floor(song2Beat / 8) % DDR_CHORDS.length;
      const chord = DDR_CHORDS[chordIndex];
      const beatMs = 60000 / 170 / 4;
      
      chord.forEach((note, i) => {
        setTimeout(() => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'triangle';
          osc.frequency.value = note * 2;
          gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
          osc.connect(gain);
          gain.connect(masterGain);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
        }, i * beatMs);
      });
    }
    
    function playDDRChord() {
      const chordIndex = Math.floor(song2Beat / 4) % DDR_CHORDS.length;
      const chord = DDR_CHORDS[chordIndex];
      
      chord.forEach(note => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = note;
        gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      });
    }
    
    // Update stopMusic to also clear song2 interval
    const originalStopMusic = stopMusic;
    stopMusic = function() {
      if (song2BeatInterval) {
        clearInterval(song2BeatInterval);
        song2BeatInterval = null;
      }
      originalStopMusic();
    };
    
    // â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function resize() {
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      w = window.innerWidth;
      h = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // â”€â”€â”€ GAME FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let currentBeatmap = [];
    
    function startGame() {
      gameState = 'playing';
      notes = [];
      nextNoteIndex = 0;
      score = 0;
      combo = 0;
      maxCombo = 0;
      perfects = 0;
      goods = 0;
      misses = 0;
      hitEffects = [];
      songTime = -2000; // 2 second lead-in
      
      // Set BPM based on selected song
      const song = SONGS[currentSongIndex];
      bpm = song.bpm;
      beatInterval = 60000 / bpm;
      
      // Generate beatmap for selected song
      currentBeatmap = currentSongIndex === 0 ? generateBeatmapSong1() : generateBeatmapSong2();
      
      initAudio();
      
      // Delay music start by 2 seconds
      setTimeout(() => {
        if (gameState === 'playing') {
          if (currentSongIndex === 0) {
            startMusicSong1();
          } else {
            startMusicSong2();
          }
        }
      }, 2000);
    }
    
    function endGame() {
      gameState = 'results';
      stopMusic();
    }
    
    function getLaneX(lane) {
      const laneWidth = w / NUM_LANES;
      return laneWidth * lane + laneWidth / 2;
    }
    
    function getHitZoneY() {
      return h * HIT_ZONE_Y;
    }
    
    // Calculate Y position based on time until hit
    function getNoteY(noteTime) {
      const timeUntilHit = noteTime - songTime;
      const travelTime = (h * HIT_ZONE_Y) / NOTE_SPEED * 1000; // Time to travel from top to hit zone
      const progress = 1 - (timeUntilHit / travelTime);
      return progress * h * HIT_ZONE_Y;
    }
    
    function hitNote(lane) {
      const hitZoneY = getHitZoneY();
      const hitY = hitZoneY;
      
      // Find the closest note in this lane within hit window
      let closestNote = null;
      let closestDist = Infinity;
      
      for (let i = 0; i < notes.length; i++) {
        const note = notes[i];
        if (note.lane !== lane || note.hit) continue;
        
        const timeDiff = Math.abs(note.time - songTime);
        if (timeDiff < closestDist && timeDiff < GOOD_WINDOW) {
          closestDist = timeDiff;
          closestNote = note;
        }
      }
      
      if (closestNote) {
        closestNote.hit = true;
        const x = getLaneX(lane);
        
        if (closestDist <= PERFECT_WINDOW) {
          // Perfect!
          score += 100 * (1 + combo * 0.1);
          combo++;
          perfects++;
          playPerfect();
          screenFlash = 0.3;
          hitEffects.push({
            x, y: hitZoneY,
            color: THEME.perfect,
            alpha: 1, scale: 1,
            text: 'PERFECT'
          });
        } else {
          // Good
          score += 50 * (1 + combo * 0.1);
          combo++;
          goods++;
          playGood();
          hitEffects.push({
            x, y: hitZoneY,
            color: THEME.good,
            alpha: 1, scale: 0.8,
            text: 'GOOD'
          });
        }
        
        maxCombo = Math.max(maxCombo, combo);
        lanePulse[lane] = 1;
      }
    }
    
    function missNote(note) {
      if (note.missed) return;
      note.missed = true;
      misses++;
      combo = 0;
      playMiss();
      
      const x = getLaneX(note.lane);
      hitEffects.push({
        x, y: getHitZoneY(),
        color: THEME.miss,
        alpha: 1, scale: 0.6,
        text: 'MISS'
      });
    }
    
    // â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function update(dt) {
      if (gameState !== 'playing') return;
      
      // Update song time
      songTime += dt * 1000;
      
      // Spawn new notes
      const spawnAheadTime = (h * HIT_ZONE_Y) / NOTE_SPEED * 1000 + 100;
      while (nextNoteIndex < currentBeatmap.length && 
             currentBeatmap[nextNoteIndex].time < songTime + spawnAheadTime) {
        const noteData = currentBeatmap[nextNoteIndex];
        notes.push({
          time: noteData.time,
          lane: noteData.lane,
          hit: false,
          missed: false,
        });
        nextNoteIndex++;
      }
      
      // Check for missed notes (past hit zone by GOOD_WINDOW)
      for (const note of notes) {
        if (!note.hit && !note.missed && note.time < songTime - GOOD_WINDOW) {
          missNote(note);
        }
      }
      
      // Remove old notes
      notes = notes.filter(n => {
        const y = getNoteY(n.time);
        return y < h + 50;
      });
      
      // Update effects
      for (let i = hitEffects.length - 1; i >= 0; i--) {
        hitEffects[i].alpha -= dt * 2;
        hitEffects[i].scale += dt * 2;
        hitEffects[i].y -= dt * 50;
        if (hitEffects[i].alpha <= 0) {
          hitEffects.splice(i, 1);
        }
      }
      
      // Decay screen flash
      screenFlash = Math.max(0, screenFlash - dt * 4);
      
      // Decay lane pulses
      for (let i = 0; i < NUM_LANES; i++) {
        lanePulse[i] = Math.max(0, lanePulse[i] - dt * 5);
      }
      
      // Check for song end
      if (songTime > SONGS[currentSongIndex].duration && notes.length === 0) {
        endGame();
      }
    }
    
    // â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function draw() {
      // Clear
      ctx.fillStyle = THEME.void;
      ctx.fillRect(0, 0, w, h);
      
      // Beat pulse background
      if (gameState === 'playing') {
        const beatProgress = (songTime % beatInterval) / beatInterval;
        const pulse = Math.exp(-beatProgress * 5) * 0.1;
        ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
        ctx.fillRect(0, 0, w, h);
      }
      
      // Lane lines
      const laneWidth = w / NUM_LANES;
      for (let i = 0; i <= NUM_LANES; i++) {
        const x = i * laneWidth;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      
      // Lane glow when hit
      for (let i = 0; i < NUM_LANES; i++) {
        if (lanePulse[i] > 0) {
          const x = getLaneX(i);
          const gradient = ctx.createRadialGradient(x, getHitZoneY(), 0, x, getHitZoneY(), laneWidth);
          gradient.addColorStop(0, `rgba(${hexToRgb(LANE_COLORS[i])}, ${lanePulse[i] * 0.5})`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, w, h);
        }
      }
      
      // Hit zone line
      const hitY = getHitZoneY();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, hitY);
      ctx.lineTo(w, hitY);
      ctx.stroke();
      
      // Hit zone targets
      for (let i = 0; i < NUM_LANES; i++) {
        const x = getLaneX(i);
        ctx.strokeStyle = LANE_COLORS[i];
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5 + lanePulse[i] * 0.5;
        ctx.beginPath();
        ctx.arc(x, hitY, 25, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      
      // Notes
      for (const note of notes) {
        if (note.hit) continue;
        
        const x = getLaneX(note.lane);
        const y = getNoteY(note.time);
        
        if (y < -30 || y > h + 30) continue;
        
        const color = LANE_COLORS[note.lane];
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        
        // Note body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner glow
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        ctx.shadowBlur = 0;
      }
      
      // Hit effects
      for (const effect of hitEffects) {
        ctx.globalAlpha = effect.alpha;
        ctx.fillStyle = effect.color;
        ctx.font = `bold ${24 * effect.scale}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(effect.text, effect.x, effect.y);
        
        // Burst particles
        ctx.beginPath();
        ctx.arc(effect.x, effect.y + 30, 30 * effect.scale, 0, Math.PI * 2);
        ctx.globalAlpha = effect.alpha * 0.3;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      // Screen flash
      if (screenFlash > 0) {
        ctx.fillStyle = THEME.perfect;
        ctx.globalAlpha = screenFlash;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }
      
      // UI
      if (gameState === 'playing') {
        // Score
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`${Math.floor(score)}`, 20, 40);
        
        // Combo
        if (combo > 1) {
          ctx.font = 'bold 32px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${combo}x`, w / 2, 50);
        }
      }
      
      // Song select screen
      if (gameState === 'songSelect') {
        ctx.fillStyle = 'rgba(9, 9, 11, 0.95)';
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 48px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('TAP BEATS', w / 2, 80);
        
        ctx.font = '18px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(248, 250, 252, 0.6)';
        ctx.fillText('SELECT A SONG', w / 2, 120);
        
        // Draw song cards
        const cardHeight = 120;
        const cardWidth = Math.min(400, w - 40);
        const startY = 160;
        
        SONGS.forEach((song, i) => {
          const y = startY + i * (cardHeight + 20);
          const isSelected = i === currentSongIndex;
          const isLocked = song.locked;
          
          // Card background
          ctx.fillStyle = isSelected ? 'rgba(236, 72, 153, 0.2)' : 'rgba(255, 255, 255, 0.05)';
          if (isLocked) ctx.fillStyle = 'rgba(50, 50, 50, 0.3)';
          ctx.fillRect(w / 2 - cardWidth / 2, y, cardWidth, cardHeight);
          
          // Border
          ctx.strokeStyle = isSelected ? THEME.lane1 : 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = isSelected ? 3 : 1;
          ctx.strokeRect(w / 2 - cardWidth / 2, y, cardWidth, cardHeight);
          
          // Song info
          ctx.textAlign = 'left';
          const textX = w / 2 - cardWidth / 2 + 20;
          
          ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
          ctx.fillStyle = isLocked ? '#666' : THEME.text;
          ctx.fillText(isLocked ? 'ğŸ”’ ' + song.name : song.name, textX, y + 35);
          
          ctx.font = '16px system-ui, -apple-system, sans-serif';
          ctx.fillStyle = isLocked ? '#555' : 'rgba(248, 250, 252, 0.7)';
          ctx.fillText(`${song.bpm} BPM  â€¢  ${song.difficulty}`, textX, y + 60);
          
          ctx.font = '14px system-ui, -apple-system, sans-serif';
          ctx.fillStyle = isLocked ? '#444' : 'rgba(248, 250, 252, 0.5)';
          ctx.fillText(song.description, textX, y + 85);
          
          if (isLocked) {
            ctx.fillStyle = THEME.miss;
            ctx.fillText('Beat Part 1 with grade C to unlock', textX, y + 105);
          }
        });
        
        ctx.textAlign = 'center';
        
        // Instructions
        ctx.font = '16px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(248, 250, 252, 0.6)';
        const instructY = startY + SONGS.length * (cardHeight + 20) + 30;
        ctx.fillText('TAP a song to select  â€¢  TAP again to play', w / 2, instructY);
        ctx.fillText('Or use â†‘â†“ arrows + ENTER', w / 2, instructY + 25);
      }
      
      // Results screen
      if (gameState === 'results') {
        ctx.fillStyle = 'rgba(9, 9, 11, 0.95)';
        ctx.fillRect(0, 0, w, h);
        
        // Song name
        ctx.fillStyle = THEME.lane1;
        ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(SONGS[currentSongIndex].name, w / 2, h / 2 - 150);
        
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 36px system-ui, -apple-system, sans-serif';
        ctx.fillText('SONG COMPLETE', w / 2, h / 2 - 110);
        
        ctx.font = 'bold 64px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.perfect;
        ctx.fillText(Math.floor(score).toLocaleString(), w / 2, h / 2 - 30);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.text;
        ctx.fillText(`Max Combo: ${maxCombo}x`, w / 2, h / 2 + 20);
        
        ctx.fillStyle = THEME.perfect;
        ctx.fillText(`Perfect: ${perfects}`, w / 2 - 80, h / 2 + 55);
        ctx.fillStyle = THEME.good;
        ctx.fillText(`Good: ${goods}`, w / 2, h / 2 + 55);
        ctx.fillStyle = THEME.miss;
        ctx.fillText(`Miss: ${misses}`, w / 2 + 80, h / 2 + 55);
        
        // Grade
        const total = perfects + goods + misses;
        const accuracy = total > 0 ? (perfects + goods * 0.5) / total : 0;
        let grade = 'F';
        if (accuracy > 0.95) grade = 'S';
        else if (accuracy > 0.9) grade = 'A';
        else if (accuracy > 0.8) grade = 'B';
        else if (accuracy > 0.7) grade = 'C';
        else if (accuracy > 0.6) grade = 'D';
        
        ctx.font = 'bold 80px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = grade === 'S' ? THEME.perfect : 
                       grade === 'A' ? THEME.good :
                       grade === 'F' ? THEME.miss : THEME.text;
        ctx.fillText(grade, w / 2, h / 2 + 140);
        
        // Check for unlock
        let unlockMessage = null;
        if (currentSongIndex === 0 && ['S', 'A', 'B', 'C'].includes(grade) && SONGS[1].locked) {
          SONGS[1].locked = false;
          localStorage.setItem('tapBeats_song2Unlocked', 'true');
          unlockMessage = 'ğŸ‰ DDR RAVE UNLOCKED! ğŸ‰';
        }
        
        if (unlockMessage) {
          ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
          ctx.fillStyle = THEME.perfect;
          ctx.fillText(unlockMessage, w / 2, h / 2 + 180);
        }
        
        ctx.font = '18px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.lane1;
        ctx.fillText('TAP TO CONTINUE', w / 2, h / 2 + 220);
      }
    }
    
    // Helper: hex to rgb
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? 
        `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
        '255, 255, 255';
    }
    
    // â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastTapOnSong = -1; // Track which song was last tapped for double-tap detection
    
    function handleTap(x, y) {
      initAudio();
      
      if (gameState === 'songSelect') {
        // Check which song card was tapped
        const cardHeight = 120;
        const startY = 160;
        
        for (let i = 0; i < SONGS.length; i++) {
          const cardY = startY + i * (cardHeight + 20);
          if (y >= cardY && y < cardY + cardHeight) {
            if (SONGS[i].locked) return; // Can't select locked songs
            
            if (currentSongIndex === i && lastTapOnSong === i) {
              // Double tap on same song - start game
              startGame();
            } else {
              // First tap - select song
              currentSongIndex = i;
              lastTapOnSong = i;
            }
            return;
          }
        }
        return;
      }
      
      if (gameState === 'results') {
        gameState = 'songSelect';
        return;
      }
      
      if (gameState === 'playing') {
        // Determine which lane was tapped
        const laneWidth = w / NUM_LANES;
        const lane = Math.floor(x / laneWidth);
        if (lane >= 0 && lane < NUM_LANES) {
          hitNote(lane);
        }
      }
    }
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      for (const touch of e.touches) {
        handleTap(touch.clientX, touch.clientY);
      }
    });
    
    canvas.addEventListener('mousedown', (e) => {
      handleTap(e.clientX, e.clientY);
    });
    
    // Keyboard support
    document.addEventListener('keydown', (e) => {
      if (gameState === 'songSelect') {
        if (e.code === 'ArrowUp') {
          e.preventDefault();
          currentSongIndex = Math.max(0, currentSongIndex - 1);
          while (SONGS[currentSongIndex].locked && currentSongIndex > 0) currentSongIndex--;
        } else if (e.code === 'ArrowDown') {
          e.preventDefault();
          currentSongIndex = Math.min(SONGS.length - 1, currentSongIndex + 1);
          if (SONGS[currentSongIndex].locked) currentSongIndex--;
        } else if (e.code === 'Enter' || e.code === 'Space') {
          e.preventDefault();
          if (!SONGS[currentSongIndex].locked) startGame();
        }
        return;
      }
      
      if (gameState === 'results') {
        if (e.code === 'Space' || e.code === 'Enter') {
          e.preventDefault();
          gameState = 'songSelect';
        }
        return;
      }
      
      // Playing - lane controls
      let lane = -1;
      if (e.code === 'KeyA' || e.code === 'KeyJ') lane = 0;
      else if (e.code === 'KeyS' || e.code === 'KeyK') lane = 1;
      else if (e.code === 'KeyD' || e.code === 'KeyL') lane = 2;
      
      if (lane >= 0) {
        e.preventDefault();
        initAudio();
        hitNote(lane);
      }
    });
    
    // â”€â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastTime = 0;
    
    function loop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;
      
      update(dt);
      draw();
      
      requestAnimationFrame(loop);
    }
    
    requestAnimationFrame(loop);
    
  </script>
</body>
</html>
