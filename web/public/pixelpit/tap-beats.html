<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Tap Beats ğŸµ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; 
      height: 100%; 
      overflow: hidden;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      background: #09090b;
    }
    canvas { 
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TAP BEATS â€” A Tap Tap Revenge tribute
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    // â”€â”€â”€ THEME (INDIE BITE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const THEME = {
      void: '#09090b',
      lane0: '#22d3ee',  // cyan - left
      lane1: '#ec4899',  // pink - center
      lane2: '#facc15',  // gold - right
      perfect: '#a3e635', // slime green
      good: '#22d3ee',    // cyan
      miss: '#ef4444',    // red
      text: '#f8fafc',
    };
    
    const LANE_COLORS = [THEME.lane0, THEME.lane1, THEME.lane2];
    
    // â”€â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioCtx = null;
    let masterGain = null;
    let musicStartTime = 0;
    
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5;
      masterGain.connect(audioCtx.destination);
      
      // Resume on iOS
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }
    
    // Play a synth note
    function playNote(freq, duration = 0.1, type = 'square', volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    
    // Play feedback sounds
    function playPerfect() {
      playNote(880, 0.1, 'sine', 0.4);
      playNote(1108, 0.15, 'sine', 0.3);
    }
    
    function playGood() {
      playNote(660, 0.1, 'sine', 0.3);
    }
    
    function playMiss() {
      playNote(150, 0.2, 'sawtooth', 0.2);
    }
    
    // â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let w, h;
    let gameState = 'start'; // start, playing, results
    
    const NUM_LANES = 3;
    const HIT_ZONE_Y = 0.85; // 85% down the screen
    const NOTE_SPEED = 400; // pixels per second
    const PERFECT_WINDOW = 50; // ms
    const GOOD_WINDOW = 150; // ms
    
    // Timing
    let songTime = 0; // Current position in song (ms)
    let bpm = 140;
    let beatInterval = 60000 / bpm; // ms per beat (~428ms)
    
    // Notes
    let notes = []; // Active notes on screen
    let nextNoteIndex = 0;
    
    // Score
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let perfects = 0;
    let goods = 0;
    let misses = 0;
    
    // Visual feedback
    let hitEffects = []; // { x, y, color, alpha, scale, text }
    let screenFlash = 0;
    let lanePulse = [0, 0, 0]; // Per-lane pulse intensity
    
    // â”€â”€â”€ BEATMAP (matches DDR song structure) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // time = ms from song start, lane = 0/1/2
    const BEATMAP = generateBeatmap();
    
    function generateBeatmap() {
      const map = [];
      const beat = beatInterval;
      
      // INTRO (0-4s): Quick intro - 4 beats center, then go
      for (let t = 1500; t < 4000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      
      // VERSE 1 (4-12s): Alternating lanes, 8th notes
      let lane = 0;
      for (let t = 4000; t < 12000; t += beat / 2) {
        map.push({ time: t, lane: lane });
        lane = (lane + 1) % 3;
      }
      
      // BUILD 1 (12-16s): Sparse, building tension - just on beats
      for (let t = 12000; t < 16000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      
      // DROP 1 (16-24s): INTENSE - follow the melody rhythm, doubles allowed
      const melodyPattern = [1, 1, 2, 2, 1, 0, 1, -1]; // -1 = rest
      for (let t = 16000; t < 24000; t += beat) {
        const beatInPhrase = Math.floor((t - 16000) / beat) % 8;
        const noteLane = melodyPattern[beatInPhrase];
        if (noteLane >= 0) {
          map.push({ time: t, lane: noteLane });
          if (Math.random() < 0.3) {
            map.push({ time: t + beat / 2, lane: Math.floor(Math.random() * 3) });
          }
        }
      }
      
      // VERSE 2 (24-32s): Variation - descending pattern
      for (let t = 24000; t < 32000; t += beat / 2) {
        const pos = Math.floor((t - 24000) / (beat / 2));
        map.push({ time: t, lane: (2 - (pos % 3)) });
      }
      
      // BUILD 2 (32-36s): Rising tension - accelerating
      let interval = beat;
      for (let t = 32000; t < 36000; t += interval) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        interval = Math.max(interval * 0.9, beat / 4);
      }
      
      // DROP 2 (36-52s): MAXIMUM INTENSITY - 8th notes + doubles
      for (let t = 36000; t < 52000; t += beat / 2) {
        const beatInPhrase = Math.floor((t - 36000) / beat) % 8;
        const noteLane = melodyPattern[beatInPhrase % melodyPattern.length];
        
        if (noteLane >= 0) {
          map.push({ time: t, lane: noteLane });
        } else {
          map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        }
        
        // 25% chance of double
        if (Math.random() < 0.25) {
          const otherLane = (map[map.length - 1].lane + 1 + Math.floor(Math.random() * 2)) % 3;
          map.push({ time: t, lane: otherLane });
        }
      }
      
      // OUTRO (52-60s): Cool down - quarter notes, slowing
      for (let t = 52000; t < 58000; t += beat) {
        map.push({ time: t, lane: 1 });
      }
      // Final hit
      map.push({ time: 59000, lane: 0 });
      map.push({ time: 59000, lane: 1 });
      map.push({ time: 59000, lane: 2 });
      
      // Sort by time
      map.sort((a, b) => a.time - b.time);
      
      return map;
    }
    
    // â”€â”€â”€ PROCEDURAL MUSIC (DDR STYLE @ 140 BPM) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let musicNodes = [];
    
    // Note frequencies
    const NOTE = {
      A2: 110, E2: 82.41, F2: 87.31, G2: 98,
      G4: 392, A4: 440, B4: 493.88, C5: 523.25,
      A3: 220, C4: 261.63, E4: 329.63,
    };
    
    // Song structure (times in seconds) - 2026 pop structure
    const SONG = {
      intro: { start: 0, end: 4 },      // Short intro - 8 beats only
      verse1: { start: 4, end: 12 },    // Verse with atmosphere
      build1: { start: 12, end: 16 },   // Rising tension
      drop1: { start: 16, end: 24 },    // First drop
      verse2: { start: 24, end: 32 },   // Second verse
      build2: { start: 32, end: 36 },   // Final build
      drop2: { start: 36, end: 52 },    // Big finale drop
      outro: { start: 52, end: 60 },    // Smooth outro
    };
    
    // Main melody riff: A, A, C, B, A, G, A (8 beats)
    const MELODY = [
      { note: NOTE.A4, beat: 0 },
      { note: NOTE.A4, beat: 1 },
      { note: NOTE.C5, beat: 2 },
      { note: NOTE.B4, beat: 3 },
      { note: NOTE.A4, beat: 4 },
      { note: NOTE.G4, beat: 5 },
      { note: NOTE.A4, beat: 6 },
      { note: null, beat: 7 }, // Rest
    ];
    
    // Bass progression: Am - Am/G - F - E (4 bars)
    const BASS = [
      { note: NOTE.A2, bar: 0 },
      { note: NOTE.G2, bar: 1 },
      { note: NOTE.F2, bar: 2 },
      { note: NOTE.E2, bar: 3 },
    ];
    
    function startMusic() {
      if (!audioCtx) return;
      musicStartTime = audioCtx.currentTime;
      
      const beatSec = 60 / 140; // 140 BPM
      const barSec = beatSec * 4;
      
      // Schedule all music - 2026 pop style
      scheduleKicks(beatSec);
      scheduleHiHats(beatSec);
      scheduleClaps(beatSec);        // Claps instead of snares
      scheduleBass(beatSec, barSec);
      scheduleMelody(beatSec);
      schedulePad(beatSec, barSec);  // Atmospheric pad
      scheduleArpShimmer(beatSec);   // Shimmery arpeggios
      scheduleRiser(beatSec);
    }
    
    function inSection(timeSec, section) {
      return timeSec >= section.start && timeSec < section.end;
    }
    
    function isDrumSection(timeSec) {
      // Drums play except during builds
      return !inSection(timeSec, SONG.build1) && !inSection(timeSec, SONG.build2);
    }
    
    function isDropSection(timeSec) {
      return inSection(timeSec, SONG.drop1) || inSection(timeSec, SONG.drop2);
    }
    
    function scheduleKicks(beatSec) {
      for (let t = 0; t < 60; t += beatSec) {
        if (isDrumSection(t)) {
          scheduleKick(musicStartTime + t, isDropSection(t) ? 0.5 : 0.35);
        }
      }
    }
    
    function scheduleKick(time, volume = 0.4) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(35, time + 0.12);
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.25);
    }
    
    function scheduleHiHats(beatSec) {
      for (let t = 0; t < 60; t += beatSec / 2) {
        if (isDrumSection(t) && t >= SONG.verse1.start) {
          const isOffbeat = Math.round(t / beatSec * 2) % 2 === 1;
          scheduleHiHat(musicStartTime + t, isOffbeat ? 0.08 : 0.12);
        }
      }
    }
    
    function scheduleHiHat(time, volume = 0.1) {
      const bufferSize = audioCtx.sampleRate * 0.04;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 9000;
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      noise.start(time);
      noise.stop(time + 0.04);
    }
    
    function scheduleClaps(beatSec) {
      for (let t = 0; t < 60; t += beatSec) {
        const beatInBar = Math.round(t / beatSec) % 4;
        // Clap on beats 2 and 4 - modern pop style
        if ((beatInBar === 1 || beatInBar === 3) && isDrumSection(t) && t >= SONG.verse1.start) {
          scheduleClap(musicStartTime + t, isDropSection(t) ? 0.4 : 0.3);
        }
      }
    }
    
    function scheduleClap(time, volume = 0.3) {
      // Layered clap sound - more pop, less harsh
      for (let i = 0; i < 3; i++) {
        const bufferSize = audioCtx.sampleRate * 0.08;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          data[j] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1500 + i * 500; // Spread across frequencies
        filter.Q.value = 2;
        
        const gain = audioCtx.createGain();
        const offset = i * 0.01; // Slight timing spread for thickness
        gain.gain.setValueAtTime(volume * 0.4, time + offset);
        gain.gain.exponentialRampToValueAtTime(0.001, time + offset + 0.1);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        noise.start(time + offset);
        noise.stop(time + offset + 0.1);
      }
    }
    
    function scheduleBass(beatSec, barSec) {
      for (let t = SONG.verse1.start; t < 60; t += barSec) {
        if (t >= SONG.build1.start && t < SONG.drop1.start) continue;
        if (t >= SONG.build2.start && t < SONG.drop2.start) continue;
        
        const barIndex = Math.floor((t - SONG.verse1.start) / barSec) % 4;
        const bassNote = BASS[barIndex].note;
        const volume = isDropSection(t) ? 0.3 : 0.2;
        
        // Play bass on beat 1 and 3 of each bar
        scheduleBassNote(musicStartTime + t, bassNote, beatSec * 1.5, volume);
        scheduleBassNote(musicStartTime + t + beatSec * 2, bassNote, beatSec * 1.5, volume);
      }
    }
    
    function scheduleBassNote(time, freq, duration, volume = 0.25) {
      // Modern sub bass - clean sine with subtle saturation
      const osc = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.type = 'sine';
      osc.frequency.value = freq;
      osc2.type = 'sine';
      osc2.frequency.value = freq * 2; // Subtle harmonic
      
      const subGain = audioCtx.createGain();
      const harmGain = audioCtx.createGain();
      subGain.gain.value = 1;
      harmGain.gain.value = 0.3;
      
      // Punchy envelope
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(volume, time + 0.02);
      gain.gain.exponentialRampToValueAtTime(volume * 0.6, time + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
      
      osc.connect(subGain);
      osc2.connect(harmGain);
      subGain.connect(gain);
      harmGain.connect(gain);
      gain.connect(masterGain);
      
      osc.start(time);
      osc2.start(time);
      osc.stop(time + duration);
      osc2.stop(time + duration);
    }
    
    function scheduleMelody(beatSec) {
      // Melody plays during drops and verse2
      const sections = [SONG.drop1, SONG.verse2, SONG.drop2];
      
      for (const section of sections) {
        for (let t = section.start; t < section.end; t += beatSec) {
          const beatInRiff = Math.round((t - section.start) / beatSec) % 8;
          const melodyNote = MELODY.find(m => m.beat === beatInRiff);
          
          if (melodyNote && melodyNote.note) {
            const volume = isDropSection(t) ? 0.25 : 0.15;
            scheduleMelodyNote(musicStartTime + t, melodyNote.note, beatSec * 0.8, volume);
          }
        }
      }
    }
    
    function scheduleMelodyNote(time, freq, duration, volume = 0.2) {
      // Modern pluck synth - soft sine with quick attack
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc1.type = 'sine';
      osc1.frequency.value = freq;
      osc2.type = 'triangle';
      osc2.frequency.value = freq * 2; // Octave up for brightness
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(4000, time);
      filter.frequency.exponentialRampToValueAtTime(800, time + duration);
      
      // Plucky envelope
      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(volume, time + 0.01);
      gain.gain.exponentialRampToValueAtTime(volume * 0.3, time + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
      
      osc1.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc1.start(time);
      osc2.start(time);
      osc1.stop(time + duration);
      osc2.stop(time + duration);
    }
    
    function schedulePad(beatSec, barSec) {
      // Atmospheric pad - plays during verses and drops
      for (let t = SONG.verse1.start; t < 60; t += barSec * 2) {
        if (t >= SONG.build1.start && t < SONG.drop1.start) continue;
        if (t >= SONG.build2.start && t < SONG.drop2.start) continue;
        
        const volume = isDropSection(t) ? 0.08 : 0.05;
        schedulePadChord(musicStartTime + t, barSec * 2, volume);
      }
    }
    
    function schedulePadChord(time, duration, volume) {
      // Am chord with shimmer - A3, C4, E4
      const chord = [NOTE.A3, NOTE.C4, NOTE.E4];
      
      for (const freq of chord) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        // Slow attack, sustain, slow release
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(volume, time + 0.3);
        gain.gain.setValueAtTime(volume, time + duration - 0.5);
        gain.gain.linearRampToValueAtTime(0, time + duration);
        
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + duration);
      }
    }
    
    function scheduleArpShimmer(beatSec) {
      // Shimmery arpeggios during drops - high register, quiet
      const shimmerNotes = [NOTE.A4, NOTE.C5, NOTE.E4 * 2, NOTE.A4]; // A minor arp
      
      for (const section of [SONG.drop1, SONG.drop2]) {
        let noteIndex = 0;
        for (let t = section.start; t < section.end; t += beatSec / 4) {
          const freq = shimmerNotes[noteIndex % shimmerNotes.length];
          scheduleShimmerNote(musicStartTime + t, freq, beatSec / 4, 0.04);
          noteIndex++;
        }
      }
    }
    
    function scheduleShimmerNote(time, freq, duration, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration * 0.8);
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 2000;
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + duration);
    }
    
    function scheduleSynthStabs(beatSec) {
      // Offbeat stabs during drops (on the "and" of 2 and 4)
      for (const section of [SONG.drop1, SONG.drop2]) {
        for (let t = section.start; t < section.end; t += beatSec) {
          const beatInBar = Math.round((t - section.start) / beatSec) % 4;
          // Stab on offbeat after beat 2 and 4
          if (beatInBar === 1 || beatInBar === 3) {
            scheduleSynthStab(musicStartTime + t + beatSec / 2);
          }
        }
      }
    }
    
    function scheduleSynthStab(time) {
      // Am chord: A3, C4, E4
      const chord = [NOTE.A3, NOTE.C4, NOTE.E4];
      for (const freq of chord) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500;
        
        gain.gain.setValueAtTime(0.08, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + 0.1);
      }
    }
    
    function scheduleRiser(beatSec) {
      // Rising synth during builds
      for (const build of [SONG.build1, SONG.build2]) {
        const duration = build.end - build.start;
        const time = musicStartTime + build.start;
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, time);
        osc.frequency.exponentialRampToValueAtTime(800, time + duration);
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(500, time);
        filter.frequency.exponentialRampToValueAtTime(4000, time + duration);
        
        gain.gain.setValueAtTime(0.05, time);
        gain.gain.linearRampToValueAtTime(0.2, time + duration - 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + duration);
      }
    }
    
    function stopMusic() {
      musicNodes.forEach(node => {
        try { node.stop(); } catch(e) {}
        try { node.disconnect(); } catch(e) {}
      });
      musicNodes = [];
    }
    
    // â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function resize() {
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      w = window.innerWidth;
      h = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // â”€â”€â”€ GAME FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function startGame() {
      gameState = 'playing';
      notes = [];
      nextNoteIndex = 0;
      score = 0;
      combo = 0;
      maxCombo = 0;
      perfects = 0;
      goods = 0;
      misses = 0;
      hitEffects = [];
      songTime = -2000; // 2 second lead-in
      
      initAudio();
      
      // Delay music start by 2 seconds
      setTimeout(() => {
        if (gameState === 'playing') {
          startMusic();
        }
      }, 2000);
    }
    
    function endGame() {
      gameState = 'results';
      stopMusic();
    }
    
    function getLaneX(lane) {
      const laneWidth = w / NUM_LANES;
      return laneWidth * lane + laneWidth / 2;
    }
    
    function getHitZoneY() {
      return h * HIT_ZONE_Y;
    }
    
    // Calculate Y position based on time until hit
    function getNoteY(noteTime) {
      const timeUntilHit = noteTime - songTime;
      const travelTime = (h * HIT_ZONE_Y) / NOTE_SPEED * 1000; // Time to travel from top to hit zone
      const progress = 1 - (timeUntilHit / travelTime);
      return progress * h * HIT_ZONE_Y;
    }
    
    function hitNote(lane) {
      const hitZoneY = getHitZoneY();
      const hitY = hitZoneY;
      
      // Find the closest note in this lane within hit window
      let closestNote = null;
      let closestDist = Infinity;
      
      for (let i = 0; i < notes.length; i++) {
        const note = notes[i];
        if (note.lane !== lane || note.hit) continue;
        
        const timeDiff = Math.abs(note.time - songTime);
        if (timeDiff < closestDist && timeDiff < GOOD_WINDOW) {
          closestDist = timeDiff;
          closestNote = note;
        }
      }
      
      if (closestNote) {
        closestNote.hit = true;
        const x = getLaneX(lane);
        
        if (closestDist <= PERFECT_WINDOW) {
          // Perfect!
          score += 100 * (1 + combo * 0.1);
          combo++;
          perfects++;
          playPerfect();
          screenFlash = 0.3;
          hitEffects.push({
            x, y: hitZoneY,
            color: THEME.perfect,
            alpha: 1, scale: 1,
            text: 'PERFECT'
          });
        } else {
          // Good
          score += 50 * (1 + combo * 0.1);
          combo++;
          goods++;
          playGood();
          hitEffects.push({
            x, y: hitZoneY,
            color: THEME.good,
            alpha: 1, scale: 0.8,
            text: 'GOOD'
          });
        }
        
        maxCombo = Math.max(maxCombo, combo);
        lanePulse[lane] = 1;
      }
    }
    
    function missNote(note) {
      if (note.missed) return;
      note.missed = true;
      misses++;
      combo = 0;
      playMiss();
      
      const x = getLaneX(note.lane);
      hitEffects.push({
        x, y: getHitZoneY(),
        color: THEME.miss,
        alpha: 1, scale: 0.6,
        text: 'MISS'
      });
    }
    
    // â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function update(dt) {
      if (gameState !== 'playing') return;
      
      // Update song time
      songTime += dt * 1000;
      
      // Spawn new notes
      const spawnAheadTime = (h * HIT_ZONE_Y) / NOTE_SPEED * 1000 + 100;
      while (nextNoteIndex < BEATMAP.length && 
             BEATMAP[nextNoteIndex].time < songTime + spawnAheadTime) {
        const noteData = BEATMAP[nextNoteIndex];
        notes.push({
          time: noteData.time,
          lane: noteData.lane,
          hit: false,
          missed: false,
        });
        nextNoteIndex++;
      }
      
      // Check for missed notes (past hit zone by GOOD_WINDOW)
      for (const note of notes) {
        if (!note.hit && !note.missed && note.time < songTime - GOOD_WINDOW) {
          missNote(note);
        }
      }
      
      // Remove old notes
      notes = notes.filter(n => {
        const y = getNoteY(n.time);
        return y < h + 50;
      });
      
      // Update effects
      for (let i = hitEffects.length - 1; i >= 0; i--) {
        hitEffects[i].alpha -= dt * 2;
        hitEffects[i].scale += dt * 2;
        hitEffects[i].y -= dt * 50;
        if (hitEffects[i].alpha <= 0) {
          hitEffects.splice(i, 1);
        }
      }
      
      // Decay screen flash
      screenFlash = Math.max(0, screenFlash - dt * 4);
      
      // Decay lane pulses
      for (let i = 0; i < NUM_LANES; i++) {
        lanePulse[i] = Math.max(0, lanePulse[i] - dt * 5);
      }
      
      // Check for song end
      if (songTime > 58000 && notes.length === 0) {
        endGame();
      }
    }
    
    // â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function draw() {
      // Clear
      ctx.fillStyle = THEME.void;
      ctx.fillRect(0, 0, w, h);
      
      // Beat pulse background
      if (gameState === 'playing') {
        const beatProgress = (songTime % beatInterval) / beatInterval;
        const pulse = Math.exp(-beatProgress * 5) * 0.1;
        ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
        ctx.fillRect(0, 0, w, h);
      }
      
      // Lane lines
      const laneWidth = w / NUM_LANES;
      for (let i = 0; i <= NUM_LANES; i++) {
        const x = i * laneWidth;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      
      // Lane glow when hit
      for (let i = 0; i < NUM_LANES; i++) {
        if (lanePulse[i] > 0) {
          const x = getLaneX(i);
          const gradient = ctx.createRadialGradient(x, getHitZoneY(), 0, x, getHitZoneY(), laneWidth);
          gradient.addColorStop(0, `rgba(${hexToRgb(LANE_COLORS[i])}, ${lanePulse[i] * 0.5})`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, w, h);
        }
      }
      
      // Hit zone line
      const hitY = getHitZoneY();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, hitY);
      ctx.lineTo(w, hitY);
      ctx.stroke();
      
      // Hit zone targets
      for (let i = 0; i < NUM_LANES; i++) {
        const x = getLaneX(i);
        ctx.strokeStyle = LANE_COLORS[i];
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5 + lanePulse[i] * 0.5;
        ctx.beginPath();
        ctx.arc(x, hitY, 25, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      
      // Notes
      for (const note of notes) {
        if (note.hit) continue;
        
        const x = getLaneX(note.lane);
        const y = getNoteY(note.time);
        
        if (y < -30 || y > h + 30) continue;
        
        const color = LANE_COLORS[note.lane];
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        
        // Note body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner glow
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        ctx.shadowBlur = 0;
      }
      
      // Hit effects
      for (const effect of hitEffects) {
        ctx.globalAlpha = effect.alpha;
        ctx.fillStyle = effect.color;
        ctx.font = `bold ${24 * effect.scale}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(effect.text, effect.x, effect.y);
        
        // Burst particles
        ctx.beginPath();
        ctx.arc(effect.x, effect.y + 30, 30 * effect.scale, 0, Math.PI * 2);
        ctx.globalAlpha = effect.alpha * 0.3;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      // Screen flash
      if (screenFlash > 0) {
        ctx.fillStyle = THEME.perfect;
        ctx.globalAlpha = screenFlash;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }
      
      // UI
      if (gameState === 'playing') {
        // Score
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`${Math.floor(score)}`, 20, 40);
        
        // Combo
        if (combo > 1) {
          ctx.font = 'bold 32px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${combo}x`, w / 2, 50);
        }
      }
      
      // Start screen
      if (gameState === 'start') {
        ctx.fillStyle = 'rgba(9, 9, 11, 0.9)';
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 48px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('TAP BEATS', w / 2, h / 2 - 60);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(248, 250, 252, 0.7)';
        ctx.fillText('Tap the lanes when notes hit the line', w / 2, h / 2);
        
        ctx.font = '24px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.lane1;
        ctx.fillText('TAP TO START', w / 2, h / 2 + 60);
        
        // Show lanes preview
        for (let i = 0; i < NUM_LANES; i++) {
          const x = getLaneX(i);
          ctx.fillStyle = LANE_COLORS[i];
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(x, h * 0.75, 30, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      
      // Results screen
      if (gameState === 'results') {
        ctx.fillStyle = 'rgba(9, 9, 11, 0.95)';
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 36px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('SONG COMPLETE', w / 2, h / 2 - 120);
        
        ctx.font = 'bold 64px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.perfect;
        ctx.fillText(Math.floor(score).toLocaleString(), w / 2, h / 2 - 40);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.text;
        ctx.fillText(`Max Combo: ${maxCombo}x`, w / 2, h / 2 + 20);
        
        ctx.fillStyle = THEME.perfect;
        ctx.fillText(`Perfect: ${perfects}`, w / 2 - 80, h / 2 + 60);
        ctx.fillStyle = THEME.good;
        ctx.fillText(`Good: ${goods}`, w / 2, h / 2 + 60);
        ctx.fillStyle = THEME.miss;
        ctx.fillText(`Miss: ${misses}`, w / 2 + 80, h / 2 + 60);
        
        // Grade
        const total = perfects + goods + misses;
        const accuracy = total > 0 ? (perfects + goods * 0.5) / total : 0;
        let grade = 'F';
        if (accuracy > 0.95) grade = 'S';
        else if (accuracy > 0.9) grade = 'A';
        else if (accuracy > 0.8) grade = 'B';
        else if (accuracy > 0.7) grade = 'C';
        else if (accuracy > 0.6) grade = 'D';
        
        ctx.font = 'bold 80px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = grade === 'S' ? THEME.perfect : 
                       grade === 'A' ? THEME.good :
                       grade === 'F' ? THEME.miss : THEME.text;
        ctx.fillText(grade, w / 2, h / 2 + 150);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.lane1;
        ctx.fillText('TAP TO PLAY AGAIN', w / 2, h / 2 + 200);
      }
    }
    
    // Helper: hex to rgb
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? 
        `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
        '255, 255, 255';
    }
    
    // â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function handleTap(x, y) {
      initAudio();
      
      if (gameState === 'start') {
        startGame();
        return;
      }
      
      if (gameState === 'results') {
        startGame();
        return;
      }
      
      if (gameState === 'playing') {
        // Determine which lane was tapped
        const laneWidth = w / NUM_LANES;
        const lane = Math.floor(x / laneWidth);
        if (lane >= 0 && lane < NUM_LANES) {
          hitNote(lane);
        }
      }
    }
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      for (const touch of e.touches) {
        handleTap(touch.clientX, touch.clientY);
      }
    });
    
    canvas.addEventListener('mousedown', (e) => {
      handleTap(e.clientX, e.clientY);
    });
    
    // Keyboard support (A, S, D or J, K, L)
    document.addEventListener('keydown', (e) => {
      if (gameState === 'start' || gameState === 'results') {
        if (e.code === 'Space') {
          e.preventDefault();
          if (gameState === 'start') startGame();
          else startGame();
        }
        return;
      }
      
      let lane = -1;
      if (e.code === 'KeyA' || e.code === 'KeyJ') lane = 0;
      else if (e.code === 'KeyS' || e.code === 'KeyK') lane = 1;
      else if (e.code === 'KeyD' || e.code === 'KeyL') lane = 2;
      
      if (lane >= 0) {
        e.preventDefault();
        initAudio();
        hitNote(lane);
      }
    });
    
    // â”€â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastTime = 0;
    
    function loop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;
      
      update(dt);
      draw();
      
      requestAnimationFrame(loop);
    }
    
    requestAnimationFrame(loop);
    
  </script>
</body>
</html>
