<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Tap Beats ğŸµ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; 
      height: 100%; 
      overflow: hidden;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      background: #09090b;
    }
    canvas { 
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TAP BEATS â€” A Tap Tap Revenge tribute
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    // â”€â”€â”€ THEME (INDIE BITE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const THEME = {
      void: '#09090b',
      lane0: '#22d3ee',  // cyan - left
      lane1: '#ec4899',  // pink - center
      lane2: '#facc15',  // gold - right
      perfect: '#a3e635', // slime green
      good: '#22d3ee',    // cyan
      miss: '#ef4444',    // red
      text: '#f8fafc',
    };
    
    const LANE_COLORS = [THEME.lane0, THEME.lane1, THEME.lane2];
    
    // â”€â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioCtx = null;
    let masterGain = null;
    let musicStartTime = 0;
    
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5;
      masterGain.connect(audioCtx.destination);
      
      // Resume on iOS
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }
    
    // Play a synth note
    function playNote(freq, duration = 0.1, type = 'square', volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    
    // Play feedback sounds
    function playPerfect() {
      playNote(880, 0.1, 'sine', 0.4);
      playNote(1108, 0.15, 'sine', 0.3);
    }
    
    function playGood() {
      playNote(660, 0.1, 'sine', 0.3);
    }
    
    function playMiss() {
      playNote(150, 0.2, 'sawtooth', 0.2);
    }
    
    // â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let w, h;
    let gameState = 'start'; // start, playing, results
    
    const NUM_LANES = 3;
    const HIT_ZONE_Y = 0.85; // 85% down the screen
    const NOTE_SPEED = 400; // pixels per second
    const PERFECT_WINDOW = 50; // ms
    const GOOD_WINDOW = 150; // ms
    
    // Timing
    let songTime = 0; // Current position in song (ms)
    let bpm = 120;
    let beatInterval = 60000 / bpm; // ms per beat
    
    // Notes
    let notes = []; // Active notes on screen
    let nextNoteIndex = 0;
    
    // Score
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let perfects = 0;
    let goods = 0;
    let misses = 0;
    
    // Visual feedback
    let hitEffects = []; // { x, y, color, alpha, scale, text }
    let screenFlash = 0;
    let lanePulse = [0, 0, 0]; // Per-lane pulse intensity
    
    // â”€â”€â”€ BEATMAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // time = ms from song start, lane = 0/1/2
    const BEATMAP = generateBeatmap();
    
    function generateBeatmap() {
      const map = [];
      const songLength = 60000; // 60 seconds
      
      // Generate a fun pattern
      // Intro: single notes on beat (0-8 sec)
      for (let t = 2000; t < 8000; t += beatInterval) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
      }
      
      // Verse 1: alternating lanes (8-16 sec)
      let lane = 0;
      for (let t = 8000; t < 16000; t += beatInterval / 2) {
        map.push({ time: t, lane: lane });
        lane = (lane + 1) % 3;
      }
      
      // Chorus: busier pattern (16-24 sec)
      for (let t = 16000; t < 24000; t += beatInterval / 2) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        // Add doubles sometimes
        if (Math.random() < 0.3) {
          const otherLane = (map[map.length - 1].lane + 1 + Math.floor(Math.random() * 2)) % 3;
          map.push({ time: t, lane: otherLane });
        }
      }
      
      // Break: sparse (24-28 sec)
      for (let t = 24000; t < 28000; t += beatInterval) {
        map.push({ time: t, lane: 1 }); // Center only
      }
      
      // Build up: accelerating (28-32 sec)
      let interval = beatInterval;
      for (let t = 28000; t < 32000; t += interval) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        interval *= 0.95;
        interval = Math.max(interval, beatInterval / 4);
      }
      
      // Final chorus: intense (32-45 sec)
      for (let t = 32000; t < 45000; t += beatInterval / 2) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
        if (Math.random() < 0.4) {
          const otherLane = (map[map.length - 1].lane + 1 + Math.floor(Math.random() * 2)) % 3;
          map.push({ time: t, lane: otherLane });
        }
      }
      
      // Outro: slowing down (45-55 sec)
      for (let t = 45000; t < 55000; t += beatInterval) {
        map.push({ time: t, lane: Math.floor(Math.random() * 3) });
      }
      
      // Sort by time (in case doubles are out of order)
      map.sort((a, b) => a.time - b.time);
      
      return map;
    }
    
    // â”€â”€â”€ PROCEDURAL MUSIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let musicNodes = [];
    let bassLine = null;
    let drumLoop = null;
    
    function startMusic() {
      if (!audioCtx) return;
      
      musicStartTime = audioCtx.currentTime;
      
      // Bass drone
      const bass = audioCtx.createOscillator();
      const bassGain = audioCtx.createGain();
      bass.type = 'sine';
      bass.frequency.value = 55; // A1
      bassGain.gain.value = 0.15;
      bass.connect(bassGain);
      bassGain.connect(masterGain);
      bass.start();
      musicNodes.push(bass, bassGain);
      
      // Kick drum on every beat
      scheduleDrums();
      
      // Arpeggiated synth
      scheduleArpeggio();
    }
    
    function scheduleDrums() {
      const songLengthSec = 60;
      const beatSec = beatInterval / 1000;
      
      for (let t = 0; t < songLengthSec; t += beatSec) {
        // Kick
        const kickTime = musicStartTime + t;
        scheduleKick(kickTime);
        
        // Hi-hat on off-beats
        scheduleHiHat(kickTime + beatSec / 2);
      }
    }
    
    function scheduleKick(time) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
      gain.gain.setValueAtTime(0.4, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.2);
    }
    
    function scheduleHiHat(time) {
      if (!audioCtx) return;
      const bufferSize = audioCtx.sampleRate * 0.05;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 8000;
      
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.1, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      noise.start(time);
      noise.stop(time + 0.05);
    }
    
    function scheduleArpeggio() {
      const notes = [220, 277.18, 329.63, 440, 329.63, 277.18]; // Am arpeggio
      const songLengthSec = 60;
      const noteDuration = beatInterval / 4000; // 16th notes
      
      let noteIndex = 0;
      for (let t = 0; t < songLengthSec; t += beatInterval / 4000) {
        const time = musicStartTime + t;
        const freq = notes[noteIndex % notes.length];
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.08, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + 0.1);
        
        noteIndex++;
      }
    }
    
    function stopMusic() {
      musicNodes.forEach(node => {
        try { node.stop(); } catch(e) {}
        try { node.disconnect(); } catch(e) {}
      });
      musicNodes = [];
    }
    
    // â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function resize() {
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      w = window.innerWidth;
      h = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // â”€â”€â”€ GAME FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function startGame() {
      gameState = 'playing';
      notes = [];
      nextNoteIndex = 0;
      score = 0;
      combo = 0;
      maxCombo = 0;
      perfects = 0;
      goods = 0;
      misses = 0;
      hitEffects = [];
      songTime = -2000; // 2 second lead-in
      
      initAudio();
      
      // Delay music start by 2 seconds
      setTimeout(() => {
        if (gameState === 'playing') {
          startMusic();
        }
      }, 2000);
    }
    
    function endGame() {
      gameState = 'results';
      stopMusic();
    }
    
    function getLaneX(lane) {
      const laneWidth = w / NUM_LANES;
      return laneWidth * lane + laneWidth / 2;
    }
    
    function getHitZoneY() {
      return h * HIT_ZONE_Y;
    }
    
    // Calculate Y position based on time until hit
    function getNoteY(noteTime) {
      const timeUntilHit = noteTime - songTime;
      const travelTime = (h * HIT_ZONE_Y) / NOTE_SPEED * 1000; // Time to travel from top to hit zone
      const progress = 1 - (timeUntilHit / travelTime);
      return progress * h * HIT_ZONE_Y;
    }
    
    function hitNote(lane) {
      const hitZoneY = getHitZoneY();
      const hitY = hitZoneY;
      
      // Find the closest note in this lane within hit window
      let closestNote = null;
      let closestDist = Infinity;
      
      for (let i = 0; i < notes.length; i++) {
        const note = notes[i];
        if (note.lane !== lane || note.hit) continue;
        
        const timeDiff = Math.abs(note.time - songTime);
        if (timeDiff < closestDist && timeDiff < GOOD_WINDOW) {
          closestDist = timeDiff;
          closestNote = note;
        }
      }
      
      if (closestNote) {
        closestNote.hit = true;
        const x = getLaneX(lane);
        
        if (closestDist <= PERFECT_WINDOW) {
          // Perfect!
          score += 100 * (1 + combo * 0.1);
          combo++;
          perfects++;
          playPerfect();
          screenFlash = 0.3;
          hitEffects.push({
            x, y: hitZoneY,
            color: THEME.perfect,
            alpha: 1, scale: 1,
            text: 'PERFECT'
          });
        } else {
          // Good
          score += 50 * (1 + combo * 0.1);
          combo++;
          goods++;
          playGood();
          hitEffects.push({
            x, y: hitZoneY,
            color: THEME.good,
            alpha: 1, scale: 0.8,
            text: 'GOOD'
          });
        }
        
        maxCombo = Math.max(maxCombo, combo);
        lanePulse[lane] = 1;
      }
    }
    
    function missNote(note) {
      if (note.missed) return;
      note.missed = true;
      misses++;
      combo = 0;
      playMiss();
      
      const x = getLaneX(note.lane);
      hitEffects.push({
        x, y: getHitZoneY(),
        color: THEME.miss,
        alpha: 1, scale: 0.6,
        text: 'MISS'
      });
    }
    
    // â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function update(dt) {
      if (gameState !== 'playing') return;
      
      // Update song time
      songTime += dt * 1000;
      
      // Spawn new notes
      const spawnAheadTime = (h * HIT_ZONE_Y) / NOTE_SPEED * 1000 + 100;
      while (nextNoteIndex < BEATMAP.length && 
             BEATMAP[nextNoteIndex].time < songTime + spawnAheadTime) {
        const noteData = BEATMAP[nextNoteIndex];
        notes.push({
          time: noteData.time,
          lane: noteData.lane,
          hit: false,
          missed: false,
        });
        nextNoteIndex++;
      }
      
      // Check for missed notes (past hit zone by GOOD_WINDOW)
      for (const note of notes) {
        if (!note.hit && !note.missed && note.time < songTime - GOOD_WINDOW) {
          missNote(note);
        }
      }
      
      // Remove old notes
      notes = notes.filter(n => {
        const y = getNoteY(n.time);
        return y < h + 50;
      });
      
      // Update effects
      for (let i = hitEffects.length - 1; i >= 0; i--) {
        hitEffects[i].alpha -= dt * 2;
        hitEffects[i].scale += dt * 2;
        hitEffects[i].y -= dt * 50;
        if (hitEffects[i].alpha <= 0) {
          hitEffects.splice(i, 1);
        }
      }
      
      // Decay screen flash
      screenFlash = Math.max(0, screenFlash - dt * 4);
      
      // Decay lane pulses
      for (let i = 0; i < NUM_LANES; i++) {
        lanePulse[i] = Math.max(0, lanePulse[i] - dt * 5);
      }
      
      // Check for song end
      if (songTime > 58000 && notes.length === 0) {
        endGame();
      }
    }
    
    // â”€â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function draw() {
      // Clear
      ctx.fillStyle = THEME.void;
      ctx.fillRect(0, 0, w, h);
      
      // Beat pulse background
      if (gameState === 'playing') {
        const beatProgress = (songTime % beatInterval) / beatInterval;
        const pulse = Math.exp(-beatProgress * 5) * 0.1;
        ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
        ctx.fillRect(0, 0, w, h);
      }
      
      // Lane lines
      const laneWidth = w / NUM_LANES;
      for (let i = 0; i <= NUM_LANES; i++) {
        const x = i * laneWidth;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      
      // Lane glow when hit
      for (let i = 0; i < NUM_LANES; i++) {
        if (lanePulse[i] > 0) {
          const x = getLaneX(i);
          const gradient = ctx.createRadialGradient(x, getHitZoneY(), 0, x, getHitZoneY(), laneWidth);
          gradient.addColorStop(0, `rgba(${hexToRgb(LANE_COLORS[i])}, ${lanePulse[i] * 0.5})`);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, w, h);
        }
      }
      
      // Hit zone line
      const hitY = getHitZoneY();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, hitY);
      ctx.lineTo(w, hitY);
      ctx.stroke();
      
      // Hit zone targets
      for (let i = 0; i < NUM_LANES; i++) {
        const x = getLaneX(i);
        ctx.strokeStyle = LANE_COLORS[i];
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5 + lanePulse[i] * 0.5;
        ctx.beginPath();
        ctx.arc(x, hitY, 25, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      
      // Notes
      for (const note of notes) {
        if (note.hit) continue;
        
        const x = getLaneX(note.lane);
        const y = getNoteY(note.time);
        
        if (y < -30 || y > h + 30) continue;
        
        const color = LANE_COLORS[note.lane];
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        
        // Note body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner glow
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        ctx.shadowBlur = 0;
      }
      
      // Hit effects
      for (const effect of hitEffects) {
        ctx.globalAlpha = effect.alpha;
        ctx.fillStyle = effect.color;
        ctx.font = `bold ${24 * effect.scale}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(effect.text, effect.x, effect.y);
        
        // Burst particles
        ctx.beginPath();
        ctx.arc(effect.x, effect.y + 30, 30 * effect.scale, 0, Math.PI * 2);
        ctx.globalAlpha = effect.alpha * 0.3;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      // Screen flash
      if (screenFlash > 0) {
        ctx.fillStyle = THEME.perfect;
        ctx.globalAlpha = screenFlash;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }
      
      // UI
      if (gameState === 'playing') {
        // Score
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`${Math.floor(score)}`, 20, 40);
        
        // Combo
        if (combo > 1) {
          ctx.font = 'bold 32px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${combo}x`, w / 2, 50);
        }
      }
      
      // Start screen
      if (gameState === 'start') {
        ctx.fillStyle = 'rgba(9, 9, 11, 0.9)';
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 48px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('TAP BEATS', w / 2, h / 2 - 60);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(248, 250, 252, 0.7)';
        ctx.fillText('Tap the lanes when notes hit the line', w / 2, h / 2);
        
        ctx.font = '24px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.lane1;
        ctx.fillText('TAP TO START', w / 2, h / 2 + 60);
        
        // Show lanes preview
        for (let i = 0; i < NUM_LANES; i++) {
          const x = getLaneX(i);
          ctx.fillStyle = LANE_COLORS[i];
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(x, h * 0.75, 30, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
      
      // Results screen
      if (gameState === 'results') {
        ctx.fillStyle = 'rgba(9, 9, 11, 0.95)';
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = THEME.text;
        ctx.font = 'bold 36px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('SONG COMPLETE', w / 2, h / 2 - 120);
        
        ctx.font = 'bold 64px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.perfect;
        ctx.fillText(Math.floor(score).toLocaleString(), w / 2, h / 2 - 40);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.text;
        ctx.fillText(`Max Combo: ${maxCombo}x`, w / 2, h / 2 + 20);
        
        ctx.fillStyle = THEME.perfect;
        ctx.fillText(`Perfect: ${perfects}`, w / 2 - 80, h / 2 + 60);
        ctx.fillStyle = THEME.good;
        ctx.fillText(`Good: ${goods}`, w / 2, h / 2 + 60);
        ctx.fillStyle = THEME.miss;
        ctx.fillText(`Miss: ${misses}`, w / 2 + 80, h / 2 + 60);
        
        // Grade
        const total = perfects + goods + misses;
        const accuracy = total > 0 ? (perfects + goods * 0.5) / total : 0;
        let grade = 'F';
        if (accuracy > 0.95) grade = 'S';
        else if (accuracy > 0.9) grade = 'A';
        else if (accuracy > 0.8) grade = 'B';
        else if (accuracy > 0.7) grade = 'C';
        else if (accuracy > 0.6) grade = 'D';
        
        ctx.font = 'bold 80px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = grade === 'S' ? THEME.perfect : 
                       grade === 'A' ? THEME.good :
                       grade === 'F' ? THEME.miss : THEME.text;
        ctx.fillText(grade, w / 2, h / 2 + 150);
        
        ctx.font = '20px system-ui, -apple-system, sans-serif';
        ctx.fillStyle = THEME.lane1;
        ctx.fillText('TAP TO PLAY AGAIN', w / 2, h / 2 + 200);
      }
    }
    
    // Helper: hex to rgb
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? 
        `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
        '255, 255, 255';
    }
    
    // â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function handleTap(x, y) {
      initAudio();
      
      if (gameState === 'start') {
        startGame();
        return;
      }
      
      if (gameState === 'results') {
        startGame();
        return;
      }
      
      if (gameState === 'playing') {
        // Determine which lane was tapped
        const laneWidth = w / NUM_LANES;
        const lane = Math.floor(x / laneWidth);
        if (lane >= 0 && lane < NUM_LANES) {
          hitNote(lane);
        }
      }
    }
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      for (const touch of e.touches) {
        handleTap(touch.clientX, touch.clientY);
      }
    });
    
    canvas.addEventListener('mousedown', (e) => {
      handleTap(e.clientX, e.clientY);
    });
    
    // Keyboard support (A, S, D or J, K, L)
    document.addEventListener('keydown', (e) => {
      if (gameState === 'start' || gameState === 'results') {
        if (e.code === 'Space') {
          e.preventDefault();
          if (gameState === 'start') startGame();
          else startGame();
        }
        return;
      }
      
      let lane = -1;
      if (e.code === 'KeyA' || e.code === 'KeyJ') lane = 0;
      else if (e.code === 'KeyS' || e.code === 'KeyK') lane = 1;
      else if (e.code === 'KeyD' || e.code === 'KeyL') lane = 2;
      
      if (lane >= 0) {
        e.preventDefault();
        initAudio();
        hitNote(lane);
      }
    });
    
    // â”€â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastTime = 0;
    
    function loop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;
      
      update(dt);
      draw();
      
      requestAnimationFrame(loop);
    }
    
    requestAnimationFrame(loop);
    
  </script>
</body>
</html>
