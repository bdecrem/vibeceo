<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tap Beats - Robot Rave DDR ðŸŽµ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: linear-gradient(135deg, #0A0908 0%, #1a0a08 100%);
      color: #D4A574;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }
    h1 { font-size: 48px; margin-bottom: 10px; text-shadow: 0 0 20px #B8860B; letter-spacing: 4px; }
    .subtitle { color: #2D9596; font-size: 20px; margin-bottom: 40px; text-transform: uppercase; letter-spacing: 2px; }
    .btn {
      background: linear-gradient(135deg, #D4A574, #B8860B);
      color: #0A0908;
      border: none;
      padding: 20px 60px;
      font-size: 24px;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.2s;
      box-shadow: 0 4px 20px rgba(212, 165, 116, 0.4);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(212, 165, 116, 0.8); }
    .btn:disabled { background: #4a4a4a; cursor: not-allowed; transform: none; box-shadow: none; }
    .timeline { margin-top: 40px; width: 100%; max-width: 600px; }
    .progress-bar { width: 100%; height: 8px; background: #1a1a18; border-radius: 4px; overflow: hidden; margin-bottom: 20px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #2D9596, #D4A574, #B8860B); width: 0%; transition: width 0.1s; }
    .time { text-align: center; font-size: 24px; color: #666; }
    .section { text-align: center; font-size: 32px; margin-top: 20px; min-height: 40px; transition: all 0.3s; }
    .section.drop { color: #D4A574; font-weight: bold; text-shadow: 0 0 20px rgba(212, 165, 116, 0.8); }
    .section.build { color: #B8860B; }
    .section.verse { color: #2D9596; }
    .section.intro { color: #666; }
    .section.outro { color: #666; }
  </style>
</head>
<body>
  <h1>ROBOT RAVE DDR</h1>
  <div class="subtitle">150 BPM /// Faster /// More Melodic</div>
  <button class="btn" id="playBtn">â–¶ PLAY</button>
  <div class="timeline">
    <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
    <div class="time" id="time">0:00 / 0:56</div>
    <div class="section" id="section"></div>
  </div>

  <script>
    let audioCtx = null;
    let masterGain = null;
    let musicStartTime = 0;
    let isPlaying = false;
    
    const NOTE = {
      A2: 110, E2: 82.41, F2: 87.31, G2: 98, D2: 73.42,
      A1: 55, D1: 36.71,
      G4: 392, A4: 440, B4: 493.88, C5: 523.25, D5: 587.33, E5: 659.25,
      A3: 220, C4: 261.63, E4: 329.63, D4: 293.66,
    };
    
    const SONG = {
      intro: { start: 0, end: 3.2, name: 'INTRO', class: 'intro' },
      verse1: { start: 3.2, end: 9.6, name: 'VERSE', class: 'verse' },
      build1: { start: 9.6, end: 12.8, name: '...building...', class: 'build' },
      drop1: { start: 12.8, end: 22.4, name: 'ðŸ”¥ DROP 1 ðŸ”¥', class: 'drop' },
      verse2: { start: 22.4, end: 28.8, name: 'VERSE 2', class: 'verse' },
      build2: { start: 28.8, end: 32, name: '...building...', class: 'build' },
      drop2: { start: 32, end: 48, name: 'ðŸ”¥ðŸ”¥ DROP 2 ðŸ”¥ðŸ”¥', class: 'drop' },
      outro: { start: 48, end: 56, name: 'OUTRO', class: 'outro' },
    };
    
    const MELODY = [
      { note: NOTE.A4, beat: 0 },
      { note: NOTE.C5, beat: 0.5 },
      { note: NOTE.A4, beat: 1 },
      { note: NOTE.E5, beat: 1.5 },
      { note: NOTE.D5, beat: 2 },
      { note: NOTE.C5, beat: 2.5 },
      { note: NOTE.A4, beat: 3 },
      { note: NOTE.G4, beat: 3.5 },
    ];
    
    const BASS = [
      { note: NOTE.A1, bar: 0 },
      { note: NOTE.A1, bar: 1 },
      { note: NOTE.D2, bar: 2 },
      { note: NOTE.A1, bar: 3 },
    ];
    
    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5;
      masterGain.connect(audioCtx.destination);
    }
    
    function inSection(timeSec, section) {
      return timeSec >= section.start && timeSec < section.end;
    }
    
    function isDrumSection(timeSec) {
      return !inSection(timeSec, SONG.build1) && !inSection(timeSec, SONG.build2);
    }
    
    function isDropSection(timeSec) {
      return inSection(timeSec, SONG.drop1) || inSection(timeSec, SONG.drop2);
    }
    
    function startMusic() {
      initAudio();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      
      musicStartTime = audioCtx.currentTime;
      isPlaying = true;
      
      const beatSec = 60 / 150; // 150 BPM!
      const barSec = beatSec * 4;
      
      scheduleKicks(beatSec);
      scheduleHiHats(beatSec);
      scheduleClaps(beatSec);
      scheduleBass(beatSec, barSec);
      scheduleRaveSynth(beatSec);
      scheduleArpeggio(beatSec);
      scheduleRiser(beatSec);
      
      updateUI();
    }
    
    function scheduleKicks(beatSec) {
      for (let t = 0; t < 56; t += beatSec) {
        if (isDrumSection(t)) {
          scheduleKick(musicStartTime + t, isDropSection(t) ? 0.6 : 0.4);
        }
      }
    }
    
    function scheduleKick(time, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.2);
    }
    
    function scheduleHiHats(beatSec) {
      for (let t = 0; t < 56; t += beatSec / 2) {
        if (isDrumSection(t) && t >= SONG.verse1.start) {
          scheduleHiHat(musicStartTime + t, 0.12);
        }
      }
    }
    
    function scheduleHiHat(time, volume) {
      const bufferSize = audioCtx.sampleRate * 0.04;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 7000;
      const gain = audioCtx.createGain();
      gain.gain.value = volume;
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      noise.start(time);
    }
    
    function scheduleClaps(beatSec) {
      for (let t = 0; t < 56; t += beatSec) {
        const beatInBar = Math.round(t / beatSec) % 4;
        if ((beatInBar === 1 || beatInBar === 3) && isDrumSection(t) && t >= SONG.verse1.start) {
          scheduleClap(musicStartTime + t, isDropSection(t) ? 0.4 : 0.3);
        }
      }
    }
    
    function scheduleClap(time, volume) {
      for (let i = 0; i < 3; i++) {
        const bufferSize = audioCtx.sampleRate * 0.08;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) data[j] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1500 + i * 500;
        filter.Q.value = 2;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(volume * 0.4, time + i * 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + i * 0.01 + 0.1);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        noise.start(time + i * 0.01);
        noise.stop(time + i * 0.01 + 0.1);
      }
    }
    
    function scheduleBass(beatSec, barSec) {
      for (let t = SONG.verse1.start; t < 56; t += barSec) {
        if (t >= SONG.build1.start && t < SONG.drop1.start) continue;
        if (t >= SONG.build2.start && t < SONG.drop2.start) continue;
        const barIndex = Math.floor((t - SONG.verse1.start) / barSec) % 4;
        const bassNote = BASS[barIndex].note;
        const volume = isDropSection(t) ? 0.35 : 0.25;
        scheduleBassNote(musicStartTime + t, bassNote, beatSec * 1.5, volume);
        scheduleBassNote(musicStartTime + t + beatSec * 2, bassNote, beatSec * 1.5, volume);
      }
    }
    
    function scheduleBassNote(time, freq, duration, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + duration);
    }
    
    function scheduleRaveSynth(beatSec) {
      const sections = [SONG.drop1, SONG.drop2];
      for (const section of sections) {
        for (let t = section.start; t < section.end; t += beatSec / 2) {
          const beatInRiff = ((t - section.start) / (beatSec / 2)) % 8;
          const melodyNote = MELODY.find(m => Math.abs(m.beat - beatInRiff) < 0.1);
          if (melodyNote && melodyNote.note) {
            scheduleRaveNote(musicStartTime + t, melodyNote.note, beatSec * 0.4, 0.2);
          }
        }
      }
    }
    
    function scheduleRaveNote(time, freq, duration, volume) {
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc1.type = 'sawtooth';
      osc1.frequency.value = freq;
      osc2.type = 'sawtooth';
      osc2.frequency.value = freq * 1.01;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(3000, time);
      filter.frequency.exponentialRampToValueAtTime(800, time + duration);
      filter.Q.value = 5;
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
      osc1.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc1.start(time);
      osc2.start(time);
      osc1.stop(time + duration);
      osc2.stop(time + duration);
    }
    
    function scheduleArpeggio(beatSec) {
      const arpNotes = [NOTE.A3, NOTE.C4, NOTE.E4, NOTE.A4, NOTE.E4, NOTE.C4];
      for (const section of [SONG.drop1, SONG.drop2]) {
        let noteIndex = 0;
        for (let t = section.start; t < section.end; t += beatSec / 4) {
          const freq = arpNotes[noteIndex % arpNotes.length];
          scheduleArpNote(musicStartTime + t, freq, beatSec / 4, 0.1);
          noteIndex++;
        }
      }
      for (let t = SONG.verse1.start; t < SONG.build1.start; t += beatSec / 4) {
        const freq = arpNotes[Math.floor((t - SONG.verse1.start) / (beatSec / 4)) % arpNotes.length];
        scheduleArpNote(musicStartTime + t, freq, beatSec / 4, 0.05);
      }
      for (let t = SONG.verse2.start; t < SONG.build2.start; t += beatSec / 4) {
        const freq = arpNotes[Math.floor((t - SONG.verse2.start) / (beatSec / 4)) % arpNotes.length];
        scheduleArpNote(musicStartTime + t, freq, beatSec / 4, 0.05);
      }
    }
    
    function scheduleArpNote(time, freq, duration, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      gain.gain.setValueAtTime(volume, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + duration * 0.8);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(time);
      osc.stop(time + duration);
    }
    
    function scheduleRiser(beatSec) {
      for (const build of [SONG.build1, SONG.build2]) {
        const duration = build.end - build.start;
        const time = musicStartTime + build.start;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, time);
        osc.frequency.exponentialRampToValueAtTime(800, time + duration);
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(500, time);
        filter.frequency.exponentialRampToValueAtTime(4000, time + duration);
        gain.gain.setValueAtTime(0.05, time);
        gain.gain.linearRampToValueAtTime(0.25, time + duration - 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + duration);
      }
    }
    
    function updateUI() {
      if (!isPlaying) return;
      const elapsed = audioCtx.currentTime - musicStartTime;
      const progress = Math.min(elapsed / 56, 1);
      document.getElementById('progress').style.width = (progress * 100) + '%';
      const mins = Math.floor(elapsed / 60);
      const secs = Math.floor(elapsed % 60);
      document.getElementById('time').textContent = `${mins}:${secs.toString().padStart(2, '0')} / 0:56`;
      let currentSection = '';
      let sectionClass = '';
      for (const [key, section] of Object.entries(SONG)) {
        if (elapsed >= section.start && elapsed < section.end) {
          currentSection = section.name;
          sectionClass = section.class;
          break;
        }
      }
      const sectionEl = document.getElementById('section');
      sectionEl.textContent = currentSection;
      sectionEl.className = 'section ' + sectionClass;
      if (elapsed < 56) {
        requestAnimationFrame(updateUI);
      } else {
        document.getElementById('playBtn').disabled = false;
        document.getElementById('playBtn').textContent = 'â–¶ PLAY AGAIN';
        isPlaying = false;
      }
    }
    
    document.getElementById('playBtn').addEventListener('click', () => {
      document.getElementById('playBtn').disabled = true;
      document.getElementById('playBtn').textContent = 'ðŸŽµ PLAYING...';
      startMusic();
    });
  </script>
</body>
</html>
