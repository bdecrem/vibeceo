<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>NEON PULSE</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#0a0a0f;overflow:hidden;font-family:-apple-system,Helvetica,Arial,sans-serif;touch-action:none;-webkit-tap-highlight-color:transparent;}
canvas{display:block;}
#ui{position:fixed;top:20px;left:20px;color:#00ff88;font-size:20px;z-index:10;text-shadow:0 0 10px #00ff88;}
#score-label{opacity:0.7;font-size:14px;}
#score{font-weight:bold;font-size:32px;display:block;}
#combo{position:fixed;top:20px;right:20px;color:#ff00ff;font-size:22px;text-shadow:0 0 20px #ff00ff;opacity:0;transition:opacity 0.2s;}
#combo.show{opacity:1;}
#high{position:fixed;top:80px;left:20px;color:#ffff00;font-size:14px;text-shadow:0 0 8px #ffff00;opacity:0.8;}
#hint{position:fixed;bottom:40px;left:0;right:0;text-align:center;color:#ffffff;font-size:20px;opacity:0.8;animation:pulse 1.5s infinite;text-shadow:0 0 10px rgba(255,255,255,0.5);}
@keyframes pulse{0%,100%{opacity:0.5;transform:scale(1);}50%{opacity:1;transform:scale(1.02);}}
#game-over{
  position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(10,10,15,0.95);
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  color:white;text-align:center;z-index:100;opacity:0;pointer-events:none;
  transition:opacity 0.3s;
}
#game-over.show{opacity:1;pointer-events:auto;}
#game-over h1{font-size:48px;margin-bottom:10px;color:#ff00ff;text-shadow:0 0 40px #ff00ff;}
#game-over .subtitle{font-size:16px;margin-bottom:30px;opacity:0.6;}
#game-over .final-score{font-size:56px;margin-bottom:10px;color:#00ff88;text-shadow:0 0 30px #00ff88;}
#game-over .final-label{font-size:14px;opacity:0.6;margin-bottom:20px;}
#game-over .high-score{font-size:22px;color:#ffff00;text-shadow:0 0 15px #ffff00;margin-bottom:30px;}
#game-over .new-high{color:#ff00ff;font-size:16px;animation:glow 0.5s infinite alternate;margin-bottom:20px;}
@keyframes glow{from{text-shadow:0 0 10px #ff00ff;}to{text-shadow:0 0 40px #ff00ff,0 0 60px #ff00ff;}}
#restart{padding:20px 60px;font-size:20px;background:linear-gradient(135deg,#00ff88,#00cc66);color:#0a0a0f;border:none;border-radius:30px;cursor:pointer;font-weight:bold;text-transform:uppercase;box-shadow:0 0 40px rgba(0,255,136,0.6);transition:transform 0.1s,box-shadow 0.1s;}
#restart:active{transform:scale(0.95);box-shadow:0 0 20px rgba(0,255,136,0.3);}
</style>
</head>
<body>
<div id="ui">
  <span id="score-label">SCORE</span>
  <span id="score">0</span>
</div>
<div id="combo">x<span id="combo-num">2</span> COMBO!</div>
<div id="high">BEST: <span id="high-score">0</span></div>
<div id="hint">TAP when the ORB hits YOUR CATCHER!</div>
<canvas id="c"></canvas>
<div id="game-over">
  <h1>GAME OVER</h1>
  <div class="subtitle">The rhythm has stopped</div>
  <div class="final-label">FINAL SCORE</div>
  <div class="final-score"><span id="final-score">0</span></div>
  <div class="high-score">BEST: <span id="final-high">0</span></div>
  <div class="new-high" id="new-high" style="display:none;">★ NEW HIGH SCORE! ★</div>
  <button id="restart">TAP TO RETRY</button>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const comboNumEl = document.getElementById('combo-num');
const highEl = document.getElementById('high-score');
const hintEl = document.getElementById('hint');
const gameOverEl = document.getElementById('game-over');
const finalScoreEl = document.getElementById('final-score');
const finalHighEl = document.getElementById('final-high');
const newHighEl = document.getElementById('new-high');
const restartBtn = document.getElementById('restart');

let W, H;
function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  player.x = W * 0.75;
  player.y = H / 2;
  if (target.active) {
    target.y = H / 2;
  }
}
resize();
window.addEventListener('resize', resize);

// Game state
let score = 0;
let combo = 0;
let maxCombo = 0;
let highScore = parseInt(localStorage.getItem('neonpulse_high') || '0');
highEl.textContent = highScore;
let gameRunning = true;
let firstTap = true;
let gameTime = 0;

// Zone around player
const zoneWidth = 140;

// Player (the catcher - always visible at right side)
const player = { x: 0, y: 0, size: 90, pulsePhase: 0, angle: 0 };

// Target orb
let target = { x: 0, y: 0, speed: 2.5, size: 85, active: true };
let baseSpeed = 2.5;
let waitRespawn = false;
let respawnTimer = 0;

// Effects
let particles = [];
let shakeX = 0, shakeY = 0;
let shakeTime = 0, shakeIntensity = 0;
let flashAlpha = 0;
let flashColor = '#00ff88';
let zoneGlow = 0;

// Trail
let trail = [];

// Feedback text
let feedbackText = '';
let feedbackAlpha = 0;
let feedbackColor = '#00ff88';
let feedbackY = 0;

// Audio
let audioCtx = null;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playTone(freq, dur, vol = 0.3, type = 'sine', slide = 0) {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    if (slide) osc.frequency.exponentialRampToValueAtTime(Math.max(freq + slide, 20), audioCtx.currentTime + dur);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
  } catch (e) {}
}

function playSuccess(comboLevel) {
  const baseFreq = 440 + (comboLevel * 50);
  playTone(baseFreq, 0.12, 0.28, 'sine');
  playTone(baseFreq * 1.5, 0.14, 0.2, 'triangle');
  if (comboLevel >= 3) {
    setTimeout(() => playTone(baseFreq * 2, 0.1, 0.15, 'sine'), 50);
  }
  if (comboLevel >= 5) {
    setTimeout(() => playTone(baseFreq * 2.5, 0.08, 0.12, 'sine'), 100);
  }
}

function playFail() {
  playTone(150, 0.35, 0.4, 'sawtooth', -100);
  playTone(80, 0.45, 0.3, 'square');
}

function initTarget() {
  target.x = W * 0.1;
  target.y = H / 2;
  target.speed = baseSpeed + Math.random() * 0.5;
  target.active = true;
  trail = [];
}

function spawnParticles(x, y, count, color, spread = 5) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * spread + 2;
    particles.push({
      x, y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      radius: Math.random() * 8 + 4,
      color,
      life: 1 + Math.random() * 0.5,
      maxLife: 1.5
    });
  }
}

function spawnRing(x, y, color, big = false) {
  particles.push({
    x, y,
    dx: 0, dy: 0,
    radius: 10,
    ringRadius: big ? 30 : 10,
    isRing: true,
    color,
    life: big ? 0.8 : 0.6,
    maxLife: big ? 0.8 : 0.6
  });
}

function showFeedback(text, color) {
  feedbackText = text;
  feedbackColor = color;
  feedbackAlpha = 1;
  feedbackY = H / 2 - 140;
}

function screenShake(intensity, time) {
  shakeIntensity = intensity;
  shakeTime = time;
}

function flash(color) {
  flashColor = color;
  flashAlpha = 0.5;
}

function handleTap(e) {
  initAudio();
  
  if (!gameRunning) return;
  if (!target.active) return;
  
  if (firstTap) {
    firstTap = false;
    hintEl.style.opacity = '0';
  }

  // Zone is centered on player
  const zoneLeft = player.x - zoneWidth / 2;
  const zoneRight = player.x + zoneWidth / 2;
  const orbCenter = target.x;
  const orbInZone = orbCenter >= zoneLeft - target.size / 3 && orbCenter <= zoneRight + target.size / 3;
  
  const distFromCenter = Math.abs(orbCenter - player.x);
  const isPerfect = distFromCenter < zoneWidth / 4;
  
  if (orbInZone) {
    combo++;
    maxCombo = Math.max(maxCombo, combo);
    
    let points = 1;
    if (isPerfect) {
      points = 2;
      showFeedback('PERFECT!', '#ffff00');
    } else {
      showFeedback('GOOD!', '#00ff88');
    }
    points += Math.floor(combo / 3);
    score += points;
    scoreEl.textContent = score;
    
    if (combo >= 2) {
      comboNumEl.textContent = combo;
      comboEl.classList.add('show');
      setTimeout(() => comboEl.classList.remove('show'), 1000);
    }
    
    playSuccess(combo);
    const particleColor = isPerfect ? '#ffff00' : '#00ff88';
    spawnParticles(player.x, player.y, 40 + combo * 8, particleColor, 10 + combo);
    spawnRing(player.x, player.y, particleColor, true);
    screenShake(15 + combo * 3, 0.22);
    flash(particleColor);
    zoneGlow = 1;
    player.pulsePhase = 1;
    
    target.active = false;
    
    baseSpeed += 0.055;
    
    waitRespawn = true;
    respawnTimer = Math.max(0.35, 0.7 - score * 0.008);
  } else {
    if (orbCenter < zoneLeft) {
      showFeedback('TOO EARLY!', '#ff4444');
    } else {
      showFeedback('TOO LATE!', '#ff4444');
    }
    endGame();
  }
}

function endGame() {
  gameRunning = false;
  combo = 0;
  
  playFail();
  spawnParticles(target.x, target.y, 80, '#ff4444', 18);
  spawnParticles(player.x, player.y, 60, '#ff4444', 15);
  spawnRing(player.x, player.y, '#ff4444', true);
  screenShake(50, 0.6);
  flash('#ff4444');
  
  let isNewHigh = false;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('neonpulse_high', highScore.toString());
    isNewHigh = true;
  }
  
  finalScoreEl.textContent = score;
  finalHighEl.textContent = highScore;
  highEl.textContent = highScore;
  newHighEl.style.display = isNewHigh ? 'block' : 'none';
  
  setTimeout(() => {
    gameOverEl.classList.add('show');
  }, 800);
}

function restart() {
  initAudio();
  score = 0;
  combo = 0;
  maxCombo = 0;
  baseSpeed = 2.5;
  gameTime = 0;
  scoreEl.textContent = '0';
  particles = [];
  gameRunning = true;
  firstTap = true;
  hintEl.style.opacity = '0.8';
  gameOverEl.classList.remove('show');
  initTarget();
}

function update(delta) {
  gameTime += delta;
  player.angle += delta * 2;
  
  player.x = W * 0.75;
  player.y = H / 2;
  if (player.pulsePhase > 0) {
    player.pulsePhase -= delta * 2.5;
    if (player.pulsePhase < 0) player.pulsePhase = 0;
  }
  
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.1;
    p.dx *= 0.98;
    p.life -= delta;
    if (p.isRing) {
      p.ringRadius += delta * 450;
    }
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  if (shakeTime > 0) {
    shakeTime -= delta;
    shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
    shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
    if (shakeTime <= 0) {
      shakeX = shakeY = shakeIntensity = 0;
    }
  }
  
  if (flashAlpha > 0) {
    flashAlpha -= delta * 2;
    if (flashAlpha < 0) flashAlpha = 0;
  }
  
  if (zoneGlow > 0) {
    zoneGlow -= delta * 2.5;
    if (zoneGlow < 0) zoneGlow = 0;
  }
  
  if (feedbackAlpha > 0) {
    feedbackAlpha -= delta * 1.5;
    feedbackY -= delta * 80;
    if (feedbackAlpha < 0) feedbackAlpha = 0;
  }
  
  if (!gameRunning) return;
  
  if (target.active) {
    target.x += target.speed * 60 * delta;
    
    if (trail.length === 0 || Math.abs(trail[trail.length - 1].x - target.x) > 15) {
      trail.push({ x: target.x, y: target.y, alpha: 1 });
      if (trail.length > 8) trail.shift();
    }
    
    const zoneRight = player.x + zoneWidth / 2;
    if (target.x - target.size / 2 > zoneRight + 70) {
      showFeedback('TOO LATE!', '#ff4444');
      combo = 0;
      endGame();
    }
  }
  
  for (let t of trail) {
    t.alpha -= delta * 2;
  }
  trail = trail.filter(t => t.alpha > 0);
  
  if (waitRespawn) {
    respawnTimer -= delta;
    if (respawnTimer <= 0) {
      initTarget();
      waitRespawn = false;
    }
  }
}

function draw() {
  ctx.save();
  ctx.translate(shakeX, shakeY);
  
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(-60, -60, W + 120, H + 120);
  
  // Grid
  const gridPulse = Math.sin(gameTime * 2) * 0.5 + 0.5;
  ctx.strokeStyle = `rgba(0,255,136,${0.03 + gridPulse * 0.02})`;
  ctx.lineWidth = 1;
  const gridSize = 50;
  for (let x = 0; x < W; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  for (let y = 0; y < H; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  
  // Track line
  ctx.strokeStyle = `rgba(255,0,255,${0.25 + gridPulse * 0.15})`;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(0, H / 2);
  ctx.lineTo(W, H / 2);
  ctx.stroke();
  
  // Zone around player
  const zoneLeft = player.x - zoneWidth / 2;
  ctx.fillStyle = `rgba(0,255,255,${0.12 + gridPulse * 0.06 + zoneGlow * 0.3})`;
  ctx.fillRect(zoneLeft, H / 2 - 80, zoneWidth, 160);
  
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 30 + zoneGlow * 50;
  ctx.strokeStyle = `rgba(0,255,255,${0.7 + zoneGlow * 0.3})`;
  ctx.lineWidth = 4;
  ctx.strokeRect(zoneLeft, H / 2 - 80, zoneWidth, 160);
  ctx.shadowBlur = 0;
  
  // Trail
  for (let i = 0; i < trail.length; i++) {
    const t = trail[i];
    ctx.globalAlpha = t.alpha * 0.9;
    const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, target.size / 2 * t.alpha);
    gradient.addColorStop(0, 'rgba(255,0,255,1)');
    gradient.addColorStop(1, 'rgba(255,0,255,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(t.x, t.y, target.size / 2 * (0.25 + t.alpha * 0.75), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // Target orb
  if (target.active) {
    const orbPulse = 1 + Math.sin(gameTime * 14) * 0.1;
    const orbSize = target.size / 2 * orbPulse;
    
    ctx.shadowColor = '#ff00ff';
    ctx.shadowBlur = 80;
    
    const gradient = ctx.createRadialGradient(target.x, target.y, 0, target.x, target.y, orbSize);
    gradient.addColorStop(0, '#ffffff');
    gradient.addColorStop(0.1, '#ffccff');
    gradient.addColorStop(0.4, '#ff00ff');
    gradient.addColorStop(1, '#880088');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(target.x, target.y, orbSize, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(255,0,255,0.8)';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(target.x, target.y, orbSize + 20 + Math.sin(gameTime * 12) * 7, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(target.x - orbSize / 3, target.y - orbSize / 3, orbSize / 2.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;
  
  // PLAYER CHARACTER - Large and distinct
  const playerPulse = 1 + player.pulsePhase * 0.5 + Math.sin(gameTime * 5) * 0.08;
  const pSize = player.size / 2 * playerPulse;
  
  // Player glow aura
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 60 + player.pulsePhase * 60;
  
  // Player body (hexagon shape for uniqueness)
  ctx.fillStyle = '#00ffff';
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = player.angle + (i / 6) * Math.PI * 2;
    const x = player.x + Math.cos(angle) * pSize;
    const y = player.y + Math.sin(angle) * pSize;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  
  const pGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, pSize);
  pGradient.addColorStop(0, '#ffffff');
  pGradient.addColorStop(0.15, '#aaffff');
  pGradient.addColorStop(0.5, '#00ffff');
  pGradient.addColorStop(1, '#006666');
  ctx.fillStyle = pGradient;
  ctx.fill();
  
  // Player outer ring
  ctx.strokeStyle = `rgba(0,255,255,${0.8 + player.pulsePhase * 0.2})`;
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.arc(player.x, player.y, pSize + 20 + Math.sin(gameTime * 6) * 6, 0, Math.PI * 2);
  ctx.stroke();
  
  // Player second ring
  ctx.strokeStyle = `rgba(0,255,255,${0.4 + player.pulsePhase * 0.3})`;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(player.x, player.y, pSize + 35 + Math.sin(gameTime * 4 + 1) * 8, 0, Math.PI * 2);
  ctx.stroke();
  
  // Player inner core
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.beginPath();
  ctx.arc(player.x, player.y, pSize / 2.5, 0, Math.PI * 2);
  ctx.fill();
  
  // "YOU" label above player
  ctx.fillStyle = '#00ffff';
  ctx.font = 'bold 18px -apple-system, Helvetica, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('YOU', player.x, player.y - pSize - 45);
  
  // Small arrow pointing down to player
  ctx.beginPath();
  ctx.moveTo(player.x, player.y - pSize - 30);
  ctx.lineTo(player.x - 10, player.y - pSize - 40);
  ctx.lineTo(player.x + 10, player.y - pSize - 40);
  ctx.closePath();
  ctx.fill();
  
  // Particles
  for (const p of particles) {
    ctx.globalAlpha = Math.min(1, p.life / p.maxLife * 1.5);
    if (p.isRing) {
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 8 * (p.life / p.maxLife);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.ringRadius, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 20;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }
  ctx.globalAlpha = 1;
  
  // Feedback
  if (feedbackAlpha > 0) {
    ctx.globalAlpha = feedbackAlpha;
    ctx.fillStyle = feedbackColor;
    ctx.shadowColor = feedbackColor;
    ctx.shadowBlur = 40;
    ctx.font = 'bold 58px -apple-system, Helvetica, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(feedbackText, W / 2, feedbackY);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
  
  // Flash
  if (flashAlpha > 0) {
    ctx.fillStyle = flashColor;
    ctx.globalAlpha = flashAlpha;
    ctx.fillRect(-60, -60, W + 120, H + 120);
    ctx.globalAlpha = 1;
  }
  
  ctx.restore();
}

// Events
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleTap(e); }, { passive: false });
canvas.addEventListener('mousedown', e => { e.preventDefault(); handleTap(e); });
canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
restartBtn.addEventListener('click', restart);
restartBtn.addEventListener('touchend', e => { e.preventDefault(); restart(); });

// Initialize
player.x = W * 0.75;
player.y = H / 2;
initTarget();
draw();

let lastTime = performance.now();
function loop(time) {
  const delta = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>