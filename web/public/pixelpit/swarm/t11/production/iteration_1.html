<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>NEON PULSE</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#0a0a0f;overflow:hidden;font-family:-apple-system,Helvetica,Arial,sans-serif;touch-action:none;-webkit-tap-highlight-color:transparent;}
canvas{display:block;}
#ui{position:fixed;top:20px;left:20px;color:#00ff88;font-size:20px;z-index:10;text-shadow:0 0 10px #00ff88;}
#score-label{opacity:0.7;font-size:14px;}
#score{font-weight:bold;font-size:32px;display:block;}
#combo{position:fixed;top:20px;right:20px;color:#ff00ff;font-size:18px;text-shadow:0 0 10px #ff00ff;opacity:0;transition:opacity 0.2s;}
#combo.show{opacity:1;}
#high{position:fixed;top:80px;left:20px;color:#ffff00;font-size:14px;text-shadow:0 0 8px #ffff00;opacity:0.8;}
#hint{position:fixed;bottom:30px;left:0;right:0;text-align:center;color:#ffffff;font-size:16px;opacity:0.5;animation:pulse 2s infinite;}
@keyframes pulse{0%,100%{opacity:0.3;}50%{opacity:0.7;}}
#game-over{
  position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(10,10,15,0.95);
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  color:white;text-align:center;z-index:100;opacity:0;pointer-events:none;
  transition:opacity 0.3s;
}
#game-over.show{opacity:1;pointer-events:auto;}
#game-over h1{font-size:42px;margin-bottom:10px;color:#ff00ff;text-shadow:0 0 30px #ff00ff;}
#game-over .subtitle{font-size:16px;margin-bottom:30px;opacity:0.6;}
#game-over .final-score{font-size:48px;margin-bottom:10px;color:#00ff88;text-shadow:0 0 20px #00ff88;}
#game-over .final-label{font-size:14px;opacity:0.6;margin-bottom:20px;}
#game-over .high-score{font-size:20px;color:#ffff00;text-shadow:0 0 10px #ffff00;margin-bottom:30px;}
#game-over .new-high{color:#ff00ff;font-size:14px;animation:glow 0.5s infinite alternate;}
@keyframes glow{from{text-shadow:0 0 10px #ff00ff;}to{text-shadow:0 0 30px #ff00ff,0 0 50px #ff00ff;}}
#restart{padding:18px 50px;font-size:18px;background:linear-gradient(135deg,#00ff88,#00cc66);color:#0a0a0f;border:none;border-radius:30px;cursor:pointer;font-weight:bold;text-transform:uppercase;box-shadow:0 0 30px rgba(0,255,136,0.5);transition:transform 0.1s,box-shadow 0.1s;}
#restart:active{transform:scale(0.95);box-shadow:0 0 15px rgba(0,255,136,0.3);}
</style>
</head>
<body>
<div id="ui">
  <span id="score-label">SCORE</span>
  <span id="score">0</span>
</div>
<div id="combo">x<span id="combo-num">2</span> COMBO!</div>
<div id="high">BEST: <span id="high-score">0</span></div>
<div id="hint">TAP when the orb enters the zone</div>
<canvas id="c"></canvas>
<div id="game-over">
  <h1>GAME OVER</h1>
  <div class="subtitle">The rhythm has stopped</div>
  <div class="final-label">FINAL SCORE</div>
  <div class="final-score"><span id="final-score">0</span></div>
  <div class="high-score">BEST: <span id="final-high">0</span></div>
  <div class="new-high" id="new-high" style="display:none;">★ NEW HIGH SCORE! ★</div>
  <button id="restart">TAP TO RETRY</button>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const comboNumEl = document.getElementById('combo-num');
const highEl = document.getElementById('high-score');
const hintEl = document.getElementById('hint');
const gameOverEl = document.getElementById('game-over');
const finalScoreEl = document.getElementById('final-score');
const finalHighEl = document.getElementById('final-high');
const newHighEl = document.getElementById('new-high');
const restartBtn = document.getElementById('restart');

let W, H;
function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Game state
let score = 0;
let combo = 0;
let maxCombo = 0;
let highScore = parseInt(localStorage.getItem('neonpulse_high') || '0');
highEl.textContent = highScore;
let gameRunning = true;
let firstTap = true;

// Zone
const zoneWidth = 80;
const zoneX = () => W / 2;

// Target orb
let target = { x: 0, y: 0, speed: 4, size: 50, active: true };
let baseSpeed = 4;
let waitRespawn = false;
let respawnTimer = 0;

// Effects
let particles = [];
let shakeX = 0, shakeY = 0;
let shakeTime = 0, shakeIntensity = 0;
let flashAlpha = 0;
let flashColor = '#00ff88';
let zoneGlow = 0;

// Trail
let trail = [];

// Audio
let audioCtx = null;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playTone(freq, dur, vol = 0.3, type = 'sine', slide = 0) {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    if (slide) osc.frequency.exponentialRampToValueAtTime(freq + slide, audioCtx.currentTime + dur);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
  } catch (e) {}
}

function playSuccess(comboLevel) {
  const baseFreq = 440 + (comboLevel * 80);
  playTone(baseFreq, 0.1, 0.25, 'sine');
  playTone(baseFreq * 1.5, 0.15, 0.2, 'sine');
  if (comboLevel >= 3) {
    setTimeout(() => playTone(baseFreq * 2, 0.1, 0.15, 'sine'), 50);
  }
}

function playFail() {
  playTone(150, 0.3, 0.4, 'sawtooth', -100);
  playTone(100, 0.4, 0.3, 'square');
}

function initTarget() {
  target.x = -target.size;
  target.y = H / 2 + (Math.random() - 0.5) * (H * 0.4);
  target.speed = baseSpeed + Math.random() * 1;
  target.active = true;
  trail = [];
}

function spawnParticles(x, y, count, color, spread = 5) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * spread + 2;
    particles.push({
      x, y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      radius: Math.random() * 4 + 2,
      color,
      life: 0.6 + Math.random() * 0.3,
      maxLife: 0.9
    });
  }
}

function spawnRing(x, y, color) {
  particles.push({
    x, y,
    dx: 0, dy: 0,
    radius: 10,
    ringRadius: 10,
    isRing: true,
    color,
    life: 0.4,
    maxLife: 0.4
  });
}

function screenShake(intensity, time) {
  shakeIntensity = intensity;
  shakeTime = time;
}

function flash(color) {
  flashColor = color;
  flashAlpha = 0.3;
}

function handleTap(e) {
  initAudio();
  
  if (!gameRunning) return;
  if (!target.active) return;
  
  if (firstTap) {
    firstTap = false;
    hintEl.style.display = 'none';
  }

  const tapX = e.touches ? e.touches[0].clientX : e.clientX;
  
  // Check if orb is in the zone
  const zoneLeft = zoneX() - zoneWidth / 2;
  const zoneRight = zoneX() + zoneWidth / 2;
  const orbInZone = target.x >= zoneLeft - target.size / 2 && target.x <= zoneRight + target.size / 2;
  
  if (orbInZone) {
    // SUCCESS!
    combo++;
    maxCombo = Math.max(maxCombo, combo);
    const comboMultiplier = Math.min(combo, 10);
    const points = 1 + Math.floor((comboMultiplier - 1) * 0.5);
    score += points;
    scoreEl.textContent = score;
    
    // Show combo
    if (combo >= 2) {
      comboNumEl.textContent = combo;
      comboEl.classList.add('show');
      setTimeout(() => comboEl.classList.remove('show'), 800);
    }
    
    // Effects
    playSuccess(combo);
    spawnParticles(target.x, target.y, 15 + combo * 3, '#00ff88', 4 + combo);
    spawnRing(target.x, target.y, '#00ff88');
    screenShake(5 + combo * 2, 0.15);
    flash('#00ff88');
    zoneGlow = 1;
    
    target.active = false;
    
    // Speed up
    baseSpeed += 0.15;
    
    waitRespawn = true;
    respawnTimer = Math.max(0.3, 0.6 - score * 0.01);
  } else {
    // FAIL - tapped outside zone
    endGame();
  }
}

function endGame() {
  gameRunning = false;
  combo = 0;
  
  playFail();
  spawnParticles(target.x, target.y, 30, '#ff4444', 8);
  spawnRing(target.x, target.y, '#ff4444');
  screenShake(25, 0.4);
  flash('#ff4444');
  
  // Update high score
  let isNewHigh = false;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('neonpulse_high', highScore.toString());
    isNewHigh = true;
  }
  
  finalScoreEl.textContent = score;
  finalHighEl.textContent = highScore;
  highEl.textContent = highScore;
  newHighEl.style.display = isNewHigh ? 'block' : 'none';
  
  setTimeout(() => {
    gameOverEl.classList.add('show');
  }, 500);
}

function restart() {
  initAudio();
  score = 0;
  combo = 0;
  maxCombo = 0;
  baseSpeed = 4;
  scoreEl.textContent = '0';
  particles = [];
  gameRunning = true;
  firstTap = true;
  hintEl.style.display = 'block';
  gameOverEl.classList.remove('show');
  initTarget();
}

function update(delta) {
  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.1; // gravity
    p.life -= delta;
    if (p.isRing) {
      p.ringRadius += delta * 200;
    }
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  // Shake decay
  if (shakeTime > 0) {
    shakeTime -= delta;
    shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
    shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
    if (shakeTime <= 0) {
      shakeX = shakeY = shakeIntensity = 0;
    }
  }
  
  // Flash decay
  if (flashAlpha > 0) {
    flashAlpha -= delta * 2;
    if (flashAlpha < 0) flashAlpha = 0;
  }
  
  // Zone glow decay
  if (zoneGlow > 0) {
    zoneGlow -= delta * 3;
    if (zoneGlow < 0) zoneGlow = 0;
  }
  
  if (!gameRunning) return;
  
  // Target movement
  if (target.active) {
    target.x += target.speed * 60 * delta;
    
    // Trail
    if (trail.length === 0 || Math.abs(trail[trail.length - 1].x - target.x) > 5) {
      trail.push({ x: target.x, y: target.y, alpha: 1 });
      if (trail.length > 20) trail.shift();
    }
    
    // Check if passed zone without tap
    const zoneRight = zoneX() + zoneWidth / 2;
    if (target.x - target.size / 2 > zoneRight) {
      combo = 0;
      endGame();
    }
  }
  
  // Trail fade
  for (let t of trail) {
    t.alpha -= delta * 3;
  }
  trail = trail.filter(t => t.alpha > 0);
  
  // Respawn
  if (waitRespawn) {
    respawnTimer -= delta;
    if (respawnTimer <= 0) {
      initTarget();
      waitRespawn = false;
    }
  }
}

function draw() {
  ctx.save();
  ctx.translate(shakeX, shakeY);
  
  // Background
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(-10, -10, W + 20, H + 20);
  
  // Background grid
  ctx.strokeStyle = 'rgba(0,255,136,0.03)';
  ctx.lineWidth = 1;
  const gridSize = 50;
  for (let x = 0; x < W; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  for (let y = 0; y < H; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  
  // Zone
  const zLeft = zoneX() - zoneWidth / 2;
  ctx.fillStyle = `rgba(0,255,136,${0.08 + zoneGlow * 0.2})`;
  ctx.fillRect(zLeft, 0, zoneWidth, H);
  
  // Zone borders
  ctx.strokeStyle = `rgba(0,255,136,${0.5 + zoneGlow * 0.5})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(zLeft, 0);
  ctx.lineTo(zLeft, H);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(zLeft + zoneWidth, 0);
  ctx.lineTo(zLeft + zoneWidth, H);
  ctx.stroke();
  
  // Zone glow effect
  if (zoneGlow > 0) {
    const gradient = ctx.createLinearGradient(zLeft - 30, 0, zLeft + zoneWidth + 30, 0);
    gradient.addColorStop(0, 'transparent');
    gradient.addColorStop(0.3, `rgba(0,255,136,${zoneGlow * 0.3})`);
    gradient.addColorStop(0.7, `rgba(0,255,136,${zoneGlow * 0.3})`);
    gradient.addColorStop(1, 'transparent');
    ctx.fillStyle = gradient;
    ctx.fillRect(zLeft - 30, 0, zoneWidth + 60, H);
  }
  
  // Trail
  for (let i = 0; i < trail.length; i++) {
    const t = trail[i];
    ctx.globalAlpha = t.alpha * 0.5;
    ctx.fillStyle = '#ff00ff';
    ctx.beginPath();
    ctx.arc(t.x, t.y, target.size / 2 * (0.3 + t.alpha * 0.7), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // Target orb
  if (target.active) {
    // Outer glow
    ctx.shadowColor = '#ff00ff';
    ctx.shadowBlur = 30;
    
    // Main orb
    const gradient = ctx.createRadialGradient(target.x, target.y, 0, target.x, target.y, target.size / 2);
    gradient.addColorStop(0, '#ffffff');
    gradient.addColorStop(0.3, '#ff66ff');
    gradient.addColorStop(1, '#ff00ff');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(target.x, target.y, target.size / 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner highlight
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.arc(target.x - target.size / 6, target.y - target.size / 6, target.size / 6, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;
  
  // Particles
  for (const p of particles) {
    ctx.globalAlpha = p.life / p.maxLife;
    if (p.isRing) {
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.ringRadius, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
  
  // Flash overlay
  if (flashAlpha > 0) {
    ctx.fillStyle = flashColor;
    ctx.globalAlpha = flashAlpha;
    ctx.fillRect(-10, -10, W + 20, H + 20);
    ctx.globalAlpha = 1;
  }
  
  ctx.restore();
}

// Event listeners
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleTap(e); }, { passive: false });
canvas.addEventListener('mousedown', e => { e.preventDefault(); handleTap(e); });
canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
restartBtn.addEventListener('click', restart);
restartBtn.addEventListener('touchend', e => { e.preventDefault(); restart(); });

// Game loop
let lastTime = performance.now();
function loop(time) {
  const delta = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}

initTarget();
requestAnimationFrame(loop);
</script>
</body>
</html>