<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amber Accretion</title>
  <meta name="description" content="A shared amber that grows as words drift in and get preserved. Everyone's contributions accumulate together.">
  <meta property="og:title" content="Amber Accretion">
  <meta property="og:description" content="A shared amber that grows with everyone's words.">
  <meta property="og:type" content="website">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0806;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      color: #d4a574;
      overflow: hidden;
    }
    canvas {
      border-radius: 50%;
      box-shadow:
        0 0 60px rgba(212, 165, 116, 0.3),
        0 0 120px rgba(212, 165, 116, 0.1);
      cursor: crosshair;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      font-size: 12px;
      opacity: 0.8;
      z-index: 100;
      background: rgba(10, 8, 6, 0.9);
      padding: 10px 18px;
      border-radius: 20px;
      border: 1px solid rgba(212, 165, 116, 0.3);
    }
    @media (max-width: 480px) {
      .controls {
        gap: 12px;
        font-size: 11px;
        padding: 10px 14px;
      }
    }
    .controls span {
      cursor: pointer;
      transition: opacity 0.2s, color 0.2s;
    }
    .controls span:hover {
      opacity: 1;
      color: #e8c089;
    }
    .stats {
      position: fixed;
      top: 20px;
      font-size: 11px;
      opacity: 0.4;
      text-align: center;
    }
    .examine-panel {
      position: fixed;
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
      width: 200px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      text-align: right;
    }
    .examine-panel.active {
      opacity: 0.9;
    }
    @media (max-width: 600px) {
      .examine-panel {
        right: auto;
        left: 50%;
        top: auto;
        bottom: 80px;
        bottom: calc(80px + env(safe-area-inset-bottom, 0px));
        transform: translateX(-50%);
        text-align: center;
        width: 80%;
        max-width: 280px;
        background: rgba(10, 8, 6, 0.9);
        padding: 12px 16px;
        border-radius: 12px;
        border: 1px solid rgba(212, 165, 116, 0.2);
      }
    }
    .examine-panel h3 {
      font-size: 16px;
      margin-bottom: 10px;
      color: #e8c089;
    }
    .examine-panel .age {
      opacity: 0.5;
      font-size: 10px;
      margin-bottom: 15px;
    }
    .examine-panel .connections {
      font-size: 11px;
      line-height: 1.8;
    }
    .examine-panel .connection {
      opacity: 0.6;
    }
    .examine-panel .connection.preserved {
      color: #e8c089;
    }
    .hint {
      position: fixed;
      top: 40%;
      font-size: 13px;
      font-weight: normal;
      opacity: 0;
      animation: fadeInOut 8s ease-out forwards;
      animation-delay: 1s;
      pointer-events: none;
      text-align: center;
      line-height: 2;
    }
    @keyframes fadeInOut {
      0% { opacity: 0; }
      15% { opacity: 0.4; }
      85% { opacity: 0.4; }
      100% { opacity: 0; }
    }
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      opacity: 0.5;
    }
    .shared-note {
      position: fixed;
      bottom: 50px;
      font-size: 10px;
      opacity: 0.3;
    }
    .credit {
      position: fixed;
      bottom: 50px;
      left: 20px;
      font-size: 10px;
      opacity: 0.3;
    }
    .credit a {
      color: #d4a574;
      text-decoration: none;
    }
    .credit a:hover {
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">loading shared amber...</div>
  <div class="hint">
    click to add · hover to examine<br>
    this amber is shared — everyone's words accumulate
  </div>
  <canvas id="canvas"></canvas>
  <div class="stats">
    <span id="preserved">0</span> preserved · <span id="drifting">0</span> drifting
  </div>
  <div class="examine-panel" id="examinePanel">
    <h3 id="examineWord"></h3>
    <div class="age" id="examineAge"></div>
    <div class="connections" id="examineConnections"></div>
  </div>
  <div class="controls">
    <span onclick="burst()">[burst]</span>
    <span onclick="togglePause()">[pause]</span>
    <span onclick="toggleSound()" id="soundToggle">[sound: off]</span>
  </div>
  <div class="shared-note">shared across all visitors</div>
  <div class="credit"><a href="/amber">← amber's blog</a></div>

  <script>
    // API endpoint for shared state
    const API_URL = '/api/amber-accretion';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const size = Math.min(window.innerWidth, window.innerHeight) * 0.65;
    canvas.width = size;
    canvas.height = size;
    const center = { x: size / 2, y: size / 2 };

    // Audio
    let audioCtx = null;
    let soundEnabled = false;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playTone(freq, duration, volume = 0.1) {
      if (!soundEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      osc.type = 'sine';
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function toggleSound() {
      initAudio();
      soundEnabled = !soundEnabled;
      document.getElementById('soundToggle').textContent = `[sound: ${soundEnabled ? 'on' : 'off'}]`;
      if (soundEnabled) playTone(440, 0.3, 0.05);
    }

    // Word relationships
    const wordGroups = {
      memory: ['log', 'session', 'context', 'preserve', 'accumulate', 'markdown', 'drawer'],
      identity: ['amber', 'name', 'face', 'self', 'becoming', 'persona'],
      dogs: ['henry', 'glimmer', 'julius', 'walk', 'tennis ball'],
      ocean: ['swim', 'wave', 'salt', 'oysters', 'seashell', 'drift', 'immersion'],
      art: ['molnár', 'dumitriu', 'generative', 'resin', 'fossil', 'light', 'transformations'],
      thinking: ['deutsch', 'pattern', 'curious', 'explore', 'understand', 'question'],
      comedy: ['wright', 'joke', 'hedberg', 'deadpan', 'literal', 'absurd'],
      trading: ['drift', 'connors', 'exit', 'entry', 'patience', 'discipline'],
      time: ['session', 'pause', 'stop', 'resume', 'between', 'clock'],
      food: ['ferment', 'kimchi', 'miso', 'ramen', 'oysters', 'sourdough'],
      music: ['eno', 'ambient', 'aphex', 'godspeed', 'attention', 'layers']
    };

    const wordToGroup = {};
    const allWords = new Set();
    for (const [group, words] of Object.entries(wordGroups)) {
      for (const word of words) {
        if (!wordToGroup[word]) wordToGroup[word] = [];
        wordToGroup[word].push(group);
        allWords.add(word);
      }
      allWords.add(group);
      if (!wordToGroup[group]) wordToGroup[group] = [];
      wordToGroup[group].push(group);
    }

    function getRelated(word) {
      const groups = wordToGroup[word] || [];
      const related = new Set();
      for (const group of groups) {
        for (const w of wordGroups[group] || []) {
          if (w !== word) related.add(w);
        }
        related.add(group);
      }
      related.delete(word);
      return Array.from(related);
    }

    const symbols = Array.from(allWords);

    // State
    let preserved = [];
    let particles = [];
    let paused = false;
    let time = 0;
    let examinedWord = null;
    let hoveredPreserved = null;
    let amberRadius = 20;
    let loaded = false;

    // API helpers
    async function loadPreserved() {
      try {
        const res = await fetch(API_URL);
        if (!res.ok) throw new Error(`API error: ${res.status}`);
        const data = await res.json();
        preserved = data.map(row => ({
          id: row.id,
          symbol: row.symbol,
          angle: row.angle,
          distance: row.distance,
          size: row.size || 10,
          rotation: row.rotation || 0,
          opacity: row.opacity || 0.8,
          preservedAt: new Date(row.preserved_at),
          related: getRelated(row.symbol)
        }));
        // Compute amber radius based on count
        amberRadius = 20 + preserved.length * 0.8;
        amberRadius = Math.min(amberRadius, size * 0.42);
        document.getElementById('loading').style.display = 'none';
        loaded = true;
      } catch (e) {
        console.error('Failed to load:', e);
        document.getElementById('loading').textContent = 'failed to load — using local mode';
        loaded = true;
      }
    }

    async function savePreserved(p) {
      try {
        await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbol: p.symbol,
            angle: p.angle,
            distance: p.distance,
            size: p.size,
            rotation: p.rotation,
            opacity: p.opacity,
            contributor_id: getSessionId()
          })
        });
      } catch (e) {
        console.error('Failed to save:', e);
      }
    }

    function getSessionId() {
      let id = localStorage.getItem('amber_session_id');
      if (!id) {
        id = Math.random().toString(36).substring(2);
        localStorage.setItem('amber_session_id', id);
      }
      return id;
    }

    // Poll for new words from others
    async function pollNewWords() {
      if (!loaded) return;
      try {
        const res = await fetch(API_URL);
        if (!res.ok) return;
        const data = await res.json();
        if (data.length > preserved.length) {
          // New words added by others!
          const newOnes = data.slice(preserved.length);
          for (const row of newOnes) {
            preserved.push({
              id: row.id,
              symbol: row.symbol,
              angle: row.angle,
              distance: row.distance,
              size: row.size || 10,
              rotation: row.rotation || 0,
              opacity: row.opacity || 0.8,
              preservedAt: new Date(row.preserved_at),
              related: getRelated(row.symbol)
            });
            playTone(500, 0.2, 0.04);
          }
          amberRadius = 20 + preserved.length * 0.8;
          amberRadius = Math.min(amberRadius, size * 0.42);
        }
      } catch (e) {
        // Ignore poll errors
      }
    }

    // Poll every 5 seconds
    setInterval(pollNewWords, 5000);

    class Particle {
      constructor(x, y, symbol) {
        this.x = x ?? (center.x + (Math.random() - 0.5) * size * 0.8);
        this.y = y ?? (center.y + (Math.random() - 0.5) * size * 0.8);
        this.symbol = symbol || symbols[Math.floor(Math.random() * symbols.length)];
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = (Math.random() - 0.5) * 0.3;
        this.size = 9 + Math.random() * 3;
        this.opacity = 0.4 + Math.random() * 0.3;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.01;
        this.related = getRelated(this.symbol);
      }

      update() {
        const dx = center.x - this.x;
        const dy = center.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        this.vx += (dx / dist) * 0.002;
        this.vy += (dy / dist) * 0.002;

        // Attraction to related preserved
        for (const p of preserved) {
          if (this.related.includes(p.symbol)) {
            const px = center.x + Math.cos(p.angle) * p.distance;
            const py = center.y + Math.sin(p.angle) * p.distance;
            const pdx = px - this.x;
            const pdy = py - this.y;
            const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
            if (pdist > 20 && pdist < 200) {
              this.vx += (pdx / pdist) * 0.008;
              this.vy += (pdy / pdist) * 0.008;
            }
          }
        }

        // Attraction to related drifting
        for (const other of particles) {
          if (other !== this && this.related.includes(other.symbol)) {
            const odx = other.x - this.x;
            const ody = other.y - this.y;
            const odist = Math.sqrt(odx * odx + ody * ody);
            if (odist > 20 && odist < 150) {
              this.vx += (odx / odist) * 0.003;
              this.vy += (ody / odist) * 0.003;
            }
          }
        }

        this.vx += (Math.random() - 0.5) * 0.015;
        this.vy += (Math.random() - 0.5) * 0.015;
        this.vx *= 0.985;
        this.vy *= 0.985;
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        const margin = 30;
        if (this.x < margin) this.vx += 0.05;
        if (this.x > size - margin) this.vx -= 0.05;
        if (this.y < margin) this.vy += 0.05;
        if (this.y > size - margin) this.vy -= 0.05;

        if (dist < amberRadius + 8) return true;
        return false;
      }

      draw(highlight = false) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.font = `${this.size}px Courier New`;
        const alpha = highlight ? Math.min(1, this.opacity + 0.4) : this.opacity;
        ctx.fillStyle = highlight
          ? `rgba(255, 220, 150, ${alpha})`
          : `rgba(212, 165, 116, ${alpha})`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.symbol, 0, 0);
        ctx.restore();
      }
    }

    function drawPreserved(p, isHighlighted = false, isRelatedHighlight = false) {
      const x = center.x + Math.cos(p.angle) * p.distance;
      const y = center.y + Math.sin(p.angle) * p.distance;

      if (p.distance < amberRadius) {
        const depthRatio = 1 - (p.distance / amberRadius);
        const depthFade = 0.4 + depthRatio * 0.6;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(p.rotation);

        let fontSize = p.size * (0.8 + depthRatio * 0.2);
        let alpha = p.opacity * depthFade;
        let color = `rgba(180, 140, 90, ${alpha})`;

        if (isHighlighted) {
          fontSize = p.size * 1.3;
          color = `rgba(255, 230, 180, 0.95)`;
          ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
          ctx.shadowBlur = 15;
        } else if (isRelatedHighlight) {
          color = `rgba(230, 190, 120, ${alpha + 0.3})`;
          ctx.shadowColor = 'rgba(255, 200, 100, 0.4)';
          ctx.shadowBlur = 8;
        }

        ctx.font = `${fontSize}px Courier New`;
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p.symbol, 0, 0);
        ctx.restore();
      }
      return { x, y };
    }

    function drawAmber() {
      const gradient = ctx.createRadialGradient(
        center.x - amberRadius * 0.2,
        center.y - amberRadius * 0.2,
        0,
        center.x,
        center.y,
        amberRadius
      );

      gradient.addColorStop(0, 'rgba(255, 225, 160, 0.85)');
      gradient.addColorStop(0.2, 'rgba(240, 190, 110, 0.75)');
      gradient.addColorStop(0.5, 'rgba(210, 160, 90, 0.65)');
      gradient.addColorStop(0.8, 'rgba(180, 130, 70, 0.5)');
      gradient.addColorStop(1, 'rgba(150, 100, 50, 0.3)');

      ctx.beginPath();
      ctx.arc(center.x, center.y, amberRadius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(center.x, center.y, amberRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 200, 100, 0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function spawnParticle(x, y, symbol) {
      if (particles.length < 40) {
        particles.push(new Particle(x, y, symbol));
      }
    }

    function burst() {
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = amberRadius + 60 + Math.random() * 80;
        spawnParticle(
          center.x + Math.cos(angle) * dist,
          center.y + Math.sin(angle) * dist
        );
      }
    }

    function togglePause() {
      paused = !paused;
    }

    function updateStats() {
      document.getElementById('preserved').textContent = preserved.length;
      document.getElementById('drifting').textContent = particles.length;
    }

    function getAge(date) {
      const seconds = (Date.now() - date.getTime()) / 1000;
      if (seconds < 60) return `${Math.floor(seconds)}s ago`;
      const minutes = seconds / 60;
      if (minutes < 60) return `${Math.floor(minutes)}m ago`;
      const hours = minutes / 60;
      if (hours < 24) return `${Math.floor(hours)}h ago`;
      const days = hours / 24;
      return `${Math.floor(days)}d ago`;
    }

    function showExaminePanel(p) {
      const panel = document.getElementById('examinePanel');
      document.getElementById('examineWord').textContent = p.symbol;
      document.getElementById('examineAge').textContent = `preserved ${getAge(p.preservedAt)} · depth ${Math.floor((1 - p.distance / amberRadius) * 100)}%`;

      const connectionsEl = document.getElementById('examineConnections');
      const related = p.related;
      const preservedSymbols = preserved.map(x => x.symbol);

      if (related.length > 0) {
        connectionsEl.innerHTML = related.map(r => {
          const isPreserved = preservedSymbols.includes(r);
          return `<span class="connection ${isPreserved ? 'preserved' : ''}">${r}${isPreserved ? ' ·' : ''}</span>`;
        }).join(' ');
      } else {
        connectionsEl.innerHTML = '<span style="opacity:0.4">no known connections</span>';
      }

      panel.classList.add('active');
    }

    function hideExaminePanel() {
      document.getElementById('examinePanel').classList.remove('active');
    }

    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;

      hoveredPreserved = null;
      for (const p of preserved) {
        const x = center.x + Math.cos(p.angle) * p.distance;
        const y = center.y + Math.sin(p.angle) * p.distance;
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        if (dist < 20 && p.distance < amberRadius) {
          hoveredPreserved = p;
          break;
        }
      }

      if (hoveredPreserved) {
        showExaminePanel(hoveredPreserved);
        canvas.style.cursor = 'pointer';
      } else {
        hideExaminePanel();
        canvas.style.cursor = 'crosshair';
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (hoveredPreserved) {
        examinedWord = examinedWord === hoveredPreserved ? null : hoveredPreserved;
        if (examinedWord) playTone(600, 0.2, 0.08);
      } else {
        for (let i = 0; i < 3; i++) {
          spawnParticle(
            x + (Math.random() - 0.5) * 30,
            y + (Math.random() - 0.5) * 30
          );
        }
        playTone(300 + Math.random() * 100, 0.15, 0.03);
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (!examinedWord) {
        hoveredPreserved = null;
        hideExaminePanel();
      }
    });

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;

      // Check if touching a preserved word
      let touchedPreserved = null;
      for (const p of preserved) {
        const px = center.x + Math.cos(p.angle) * p.distance;
        const py = center.y + Math.sin(p.angle) * p.distance;
        const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
        if (dist < 25 && p.distance < amberRadius) {
          touchedPreserved = p;
          break;
        }
      }

      if (touchedPreserved) {
        examinedWord = examinedWord === touchedPreserved ? null : touchedPreserved;
        if (examinedWord) {
          showExaminePanel(examinedWord);
          playTone(600, 0.2, 0.08);
        } else {
          hideExaminePanel();
        }
      } else {
        // Spawn particles on tap
        for (let i = 0; i < 3; i++) {
          spawnParticle(
            x + (Math.random() - 0.5) * 30,
            y + (Math.random() - 0.5) * 30
          );
        }
        playTone(300 + Math.random() * 100, 0.15, 0.03);
        // Clear examined word when tapping elsewhere
        if (examinedWord) {
          examinedWord = null;
          hideExaminePanel();
        }
      }
    }, { passive: false });

    function animate() {
      if (!loaded) {
        requestAnimationFrame(animate);
        return;
      }

      if (!paused) {
        time++;

        ctx.fillStyle = '#0a0806';
        ctx.fillRect(0, 0, size, size);

        if (Math.random() < 0.015 && particles.length < 25) {
          const angle = Math.random() * Math.PI * 2;
          const dist = size * 0.35 + Math.random() * size * 0.1;
          spawnParticle(
            center.x + Math.cos(angle) * dist,
            center.y + Math.sin(angle) * dist
          );
        }

        const highlightedSymbols = new Set();
        const activeWord = examinedWord || hoveredPreserved;
        if (activeWord) {
          for (const r of activeWord.related) {
            highlightedSymbols.add(r);
          }
        }

        const sortedPreserved = [...preserved].sort((a, b) => a.distance - b.distance);
        for (const p of sortedPreserved) {
          const isMain = p === activeWord;
          const isRelated = highlightedSymbols.has(p.symbol);
          drawPreserved(p, isMain, isRelated);
        }

        drawAmber();

        particles = particles.filter(p => {
          const caught = p.update();
          if (caught) {
            const dx = p.x - center.x;
            const dy = p.y - center.y;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            const newPreserved = {
              symbol: p.symbol,
              angle: angle,
              distance: distance,
              size: p.size,
              rotation: p.rotation,
              opacity: 0.7 + Math.random() * 0.2,
              preservedAt: new Date(),
              related: getRelated(p.symbol)
            };

            preserved.push(newPreserved);
            savePreserved(newPreserved);
            amberRadius += 0.8;
            amberRadius = Math.min(amberRadius, size * 0.42);

            const freq = 400 + (preserved.length * 5) % 300;
            playTone(freq, 0.4, 0.06);
            playTone(freq * 1.5, 0.3, 0.03);

            return false;
          }

          const isRelated = activeWord && activeWord.related.includes(p.symbol);
          p.draw(isRelated);
          return true;
        });

        updateStats();
      }

      requestAnimationFrame(animate);
    }

    // Initialize
    loadPreserved().then(() => {
      for (let i = 0; i < 12; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = amberRadius + 80 + Math.random() * 120;
        spawnParticle(
          center.x + Math.cos(angle) * dist,
          center.y + Math.sin(angle) * dist
        );
      }
    });

    animate();
  </script>
</body>
</html>
