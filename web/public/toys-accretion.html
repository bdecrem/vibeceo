<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Amber Accretion</title>
  <meta name="description" content="A shared amber that grows as words drift in and get preserved. Everyone's contributions accumulate together.">
  <meta property="og:title" content="Amber Accretion">
  <meta property="og:description" content="A shared amber that grows with everyone's words.">
  <meta property="og:type" content="website">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html {
      background: #0a0806;
    }
    body {
      background: #0a0806;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      color: #d4a574;
      overflow: hidden;
    }
    canvas {
      border-radius: 50%;
      box-shadow:
        0 0 60px rgba(212, 165, 116, 0.3),
        0 0 120px rgba(212, 165, 116, 0.1);
      cursor: crosshair;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      font-size: 13px;
      opacity: 0.85;
      z-index: 100;
      background: rgba(10, 8, 6, 0.9);
      padding: 10px 20px;
      border-radius: 20px;
      border: 1px solid rgba(212, 165, 116, 0.3);
    }
    @media (max-width: 480px) {
      .controls {
        gap: 12px;
        font-size: 12px;
        padding: 10px 16px;
        white-space: nowrap;
      }
    }
    @media (max-width: 360px) {
      .controls {
        gap: 10px;
        font-size: 11px;
        padding: 9px 14px;
      }
    }
    .controls span {
      cursor: pointer;
      transition: opacity 0.2s, color 0.2s;
    }
    .controls span:hover {
      opacity: 1;
      color: #e8c089;
    }
    .stats {
      position: fixed;
      top: 20px;
      font-size: 13px;
      opacity: 0.6;
      text-align: center;
      letter-spacing: 0.5px;
    }
    .examine-panel {
      position: fixed;
      right: 30px;
      top: 50%;
      transform: translateY(-50%);
      width: 220px;
      font-size: 13px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      text-align: right;
    }
    .examine-panel.active {
      opacity: 0.95;
    }
    @media (max-width: 600px) {
      .examine-panel {
        right: auto;
        left: 50%;
        top: auto;
        bottom: 80px;
        bottom: calc(80px + env(safe-area-inset-bottom, 0px));
        transform: translateX(-50%);
        text-align: center;
        width: 80%;
        max-width: 280px;
        background: rgba(10, 8, 6, 0.9);
        padding: 12px 16px;
        border-radius: 12px;
        border: 1px solid rgba(212, 165, 116, 0.2);
      }
    }
    .examine-panel h3 {
      font-size: 18px;
      margin-bottom: 10px;
      color: #f0d4a8;
      font-weight: 500;
    }
    .examine-panel .age {
      opacity: 0.65;
      font-size: 11px;
      margin-bottom: 15px;
    }
    .examine-panel .connections {
      font-size: 12px;
      line-height: 1.9;
    }
    .examine-panel .connection {
      opacity: 0.7;
    }
    .examine-panel .connection.preserved {
      color: #f0d4a8;
      opacity: 0.9;
    }
    .hint {
      position: fixed;
      top: 40%;
      font-size: 14px;
      font-weight: normal;
      opacity: 0;
      animation: fadeInOut 8s ease-out forwards;
      animation-delay: 1s;
      pointer-events: none;
      text-align: center;
      line-height: 2.1;
      letter-spacing: 0.3px;
    }
    @keyframes fadeInOut {
      0% { opacity: 0; }
      15% { opacity: 0.4; }
      85% { opacity: 0.4; }
      100% { opacity: 0; }
    }
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      opacity: 0.5;
      text-align: center;
    }
    .replay-controls {
      position: fixed;
      bottom: 70px;
      bottom: calc(70px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      font-size: 11px;
      opacity: 0;
      z-index: 100;
      transition: opacity 0.3s;
    }
    .replay-controls.active {
      opacity: 0.7;
    }
    .replay-controls span {
      cursor: pointer;
      background: rgba(10, 8, 6, 0.8);
      padding: 6px 14px;
      border-radius: 15px;
      border: 1px solid rgba(212, 165, 116, 0.2);
    }
    .replay-controls span:hover {
      opacity: 1;
      border-color: rgba(212, 165, 116, 0.4);
    }
    .replay-progress {
      position: fixed;
      top: 50px;
      font-size: 10px;
      opacity: 0;
      transition: opacity 0.3s;
      text-align: center;
    }
    .replay-progress.active {
      opacity: 0.4;
    }
    .shared-note {
      position: fixed;
      bottom: 50px;
      font-size: 10px;
      opacity: 0.3;
    }
    .credit {
      position: fixed;
      bottom: 50px;
      left: 20px;
      font-size: 10px;
      opacity: 0.3;
    }
    .credit a {
      color: #d4a574;
      text-decoration: none;
    }
    .credit a:hover {
      opacity: 0.8;
    }
    .word-input {
      position: fixed;
      bottom: 70px;
      bottom: calc(70px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 100;
      opacity: 0.85;
    }
    .word-input input {
      background: rgba(10, 8, 6, 0.9);
      border: 1px solid rgba(212, 165, 116, 0.3);
      border-radius: 15px;
      padding: 8px 14px;
      color: #d4a574;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      width: 150px;
      outline: none;
    }
    .word-input input::placeholder {
      color: rgba(212, 165, 116, 0.4);
    }
    .word-input input:focus {
      border-color: rgba(212, 165, 116, 0.5);
    }
    .word-input span {
      cursor: pointer;
      font-size: 12px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .word-input span:hover {
      opacity: 1;
    }
    @media (max-width: 480px) {
      .word-input {
        bottom: 75px;
        bottom: calc(75px + env(safe-area-inset-bottom, 0px));
      }
      .word-input input {
        width: 130px;
        font-size: 12px;
        padding: 7px 12px;
      }
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">loading shared amber...</div>
  <div class="replay-progress" id="replayProgress">
    replaying <span id="replayCount">0</span> / <span id="replayTotal">0</span>
  </div>
  <div class="hint" id="hint">
    type a word to offer it · hover to examine<br>
    amber will digest it and make it part of her world
  </div>
  <canvas id="canvas"></canvas>
  <div class="stats">
    <span id="preserved">0</span> words · <span id="pending">0</span> awaiting digestion
  </div>
  <div class="replay-controls" id="replayControls">
    <span onclick="skipReplay()">[skip]</span>
    <span onclick="toggleReplaySpeed()" id="replaySpeed">[2x speed]</span>
  </div>
  <div class="examine-panel" id="examinePanel">
    <h3 id="examineWord"></h3>
    <div class="age" id="examineAge"></div>
    <div class="connections" id="examineConnections"></div>
  </div>
  <div class="word-input" id="wordInput">
    <input type="text" id="wordField" placeholder="offer a word..." maxlength="30" />
    <span onclick="submitWord()">[add]</span>
  </div>
  <div class="controls">
    <span onclick="burst()">[burst]</span>
    <span onclick="togglePause()">[pause]</span>
    <span onclick="toggleSound()" id="soundToggle">[sound: off]</span>
  </div>
  <div class="shared-note">shared across all visitors</div>
  <div class="credit"><a href="/amber">← amber's blog</a></div>

  <script>
    // API endpoint for shared state
    const API_URL = '/api/amber-accretion';

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const size = Math.min(window.innerWidth, window.innerHeight) * 0.65;
    canvas.width = size;
    canvas.height = size;
    const center = { x: size / 2, y: size / 2 };

    // Audio
    let audioCtx = null;
    let soundEnabled = false;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playTone(freq, duration, volume = 0.1) {
      if (!soundEnabled || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      osc.type = 'sine';
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function toggleSound() {
      initAudio();
      soundEnabled = !soundEnabled;
      document.getElementById('soundToggle').textContent = `[sound: ${soundEnabled ? 'on' : 'off'}]`;
      if (soundEnabled) playTone(440, 0.3, 0.05);
    }

    // Dynamic vocabulary - loaded from database
    let vocabulary = {};  // word -> { associations, spawn_candidates, parent_word, is_root, is_digested }
    let existingWords = new Set();  // words already in the amber
    let allSpawnCandidates = [];  // flat list of { word, parent } for spawning

    function getRelated(word) {
      const entry = vocabulary[word];
      if (!entry) return [];
      return entry.associations.filter(w => w !== word);
    }

    function getSpawnableWord() {
      // Find a word that can spawn (exists in spawn_candidates but not in vocabulary yet)
      const available = allSpawnCandidates.filter(c => !existingWords.has(c.word));
      if (available.length === 0) return null;
      return available[Math.floor(Math.random() * available.length)];
    }

    function rebuildSpawnCandidates() {
      allSpawnCandidates = [];
      for (const [word, entry] of Object.entries(vocabulary)) {
        if (entry.spawn_candidates && entry.spawn_candidates.length > 0) {
          for (const candidate of entry.spawn_candidates) {
            if (!existingWords.has(candidate)) {
              allSpawnCandidates.push({ word: candidate, parent: word });
            }
          }
        }
      }
    }

    // State
    let preserved = [];
    let particles = [];
    let paused = false;
    let time = 0;
    let examinedWord = null;
    let hoveredPreserved = null;
    let amberRadius = 20;
    let loaded = false;

    // Replay state
    let replayMode = false;
    let replayData = [];
    let replayIndex = 0;
    let replaySpeed = 1; // 1 = normal, 2 = fast, 4 = faster
    let replayWordsPerFrame = 3; // Base words per frame
    let lastReplayTime = 0;

    // API helpers
    async function loadVocabulary() {
      try {
        const res = await fetch(`${API_URL}?type=vocabulary`);
        if (!res.ok) throw new Error(`API error: ${res.status}`);
        const data = await res.json();

        // Build vocabulary map
        vocabulary = {};
        for (const row of data) {
          vocabulary[row.word] = {
            associations: row.associations || [],
            spawn_candidates: row.spawn_candidates || [],
            parent_word: row.parent_word,
            is_root: row.is_root,
            is_digested: row.is_digested,
            group_name: row.group_name
          };
        }

        console.log(`Loaded ${Object.keys(vocabulary).length} vocabulary words`);
      } catch (e) {
        console.error('Failed to load vocabulary:', e);
      }
    }

    async function loadPreserved() {
      try {
        // Load vocabulary first
        await loadVocabulary();

        const res = await fetch(API_URL);
        if (!res.ok) throw new Error(`API error: ${res.status}`);
        const data = await res.json();

        // Track existing words
        existingWords = new Set(data.map(row => row.symbol));

        // Rebuild spawn candidates (words that can still emerge)
        rebuildSpawnCandidates();
        console.log(`${allSpawnCandidates.length} spawn candidates available`);

        // Store data for replay, don't populate preserved yet
        replayData = data.map(row => ({
          id: row.id,
          symbol: row.symbol,
          angle: row.angle,
          distance: row.distance,
          size: row.size || 10,
          rotation: row.rotation || 0,
          opacity: row.opacity || 0.8,
          preservedAt: new Date(row.preserved_at),
          related: getRelated(row.symbol)
        }));

        // Start with empty amber
        preserved = [];
        amberRadius = 20;

        // Start replay mode if there's history
        if (replayData.length > 0) {
          replayMode = true;
          replayIndex = 0;
          document.getElementById('loading').textContent = 'replaying history...';
          document.getElementById('replayTotal').textContent = replayData.length;
          document.getElementById('replayProgress').classList.add('active');
          document.getElementById('replayControls').classList.add('active');
          document.getElementById('hint').style.display = 'none';
          setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
          }, 500);
        } else {
          document.getElementById('loading').style.display = 'none';
        }

        loaded = true;
      } catch (e) {
        console.error('Failed to load:', e);
        document.getElementById('loading').textContent = 'failed to load — using local mode';
        loaded = true;
      }
    }

    async function savePreserved(p) {
      try {
        const res = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbol: p.symbol,
            angle: p.angle,
            distance: p.distance,
            size: p.size,
            rotation: p.rotation,
            opacity: p.opacity,
            contributor_id: getSessionId(),
            parent_word: p.parentWord || null
          })
        });

        if (res.ok) {
          // Add to existing words and vocabulary
          existingWords.add(p.symbol);
          vocabulary[p.symbol] = {
            associations: [],
            spawn_candidates: [],
            parent_word: p.parentWord || null,
            is_root: false,
            is_digested: false
          };
          // Rebuild spawn candidates
          rebuildSpawnCandidates();
        }
      } catch (e) {
        console.error('Failed to save:', e);
      }
    }

    function getSessionId() {
      let id = localStorage.getItem('amber_session_id');
      if (!id) {
        id = Math.random().toString(36).substring(2);
        localStorage.setItem('amber_session_id', id);
      }
      return id;
    }

    // Poll for new words from others
    async function pollNewWords() {
      if (!loaded || replayMode) return;
      try {
        const res = await fetch(API_URL);
        if (!res.ok) return;
        const data = await res.json();

        // Check for new words (unique, so check by count or by new symbols)
        const currentSymbols = new Set(preserved.map(p => p.symbol));
        const newOnes = data.filter(row => !currentSymbols.has(row.symbol));

        if (newOnes.length > 0) {
          for (const row of newOnes) {
            preserved.push({
              id: row.id,
              symbol: row.symbol,
              angle: row.angle,
              distance: row.distance,
              size: row.size || 10,
              rotation: row.rotation || 0,
              opacity: row.opacity || 0.8,
              preservedAt: new Date(row.preserved_at),
              related: getRelated(row.symbol)
            });
            // Add to existing words
            existingWords.add(row.symbol);
            playTone(500, 0.2, 0.04);
          }
          // Rebuild spawn candidates
          rebuildSpawnCandidates();
          amberRadius = 20 + preserved.length * 0.8;
          amberRadius = Math.min(amberRadius, size * 0.42);
        }
      } catch (e) {
        // Ignore poll errors
      }
    }

    // Poll every 5 seconds
    setInterval(pollNewWords, 5000);

    class Particle {
      constructor(x, y, symbolData) {
        this.x = x ?? (center.x + (Math.random() - 0.5) * size * 0.8);
        this.y = y ?? (center.y + (Math.random() - 0.5) * size * 0.8);

        // symbolData can be { word, parent } or just a string
        if (typeof symbolData === 'object' && symbolData !== null) {
          this.symbol = symbolData.word;
          this.parentWord = symbolData.parent;
        } else {
          this.symbol = symbolData;
          this.parentWord = null;
        }

        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = (Math.random() - 0.5) * 0.3;
        this.size = 12 + Math.random() * 4;
        this.opacity = 0.6 + Math.random() * 0.3;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.01;
        this.related = getRelated(this.symbol);
      }

      update() {
        const dx = center.x - this.x;
        const dy = center.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        this.vx += (dx / dist) * 0.002;
        this.vy += (dy / dist) * 0.002;

        // Attraction to related preserved
        for (const p of preserved) {
          if (this.related.includes(p.symbol)) {
            const px = center.x + Math.cos(p.angle) * p.distance;
            const py = center.y + Math.sin(p.angle) * p.distance;
            const pdx = px - this.x;
            const pdy = py - this.y;
            const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
            if (pdist > 20 && pdist < 200) {
              this.vx += (pdx / pdist) * 0.008;
              this.vy += (pdy / pdist) * 0.008;
            }
          }
        }

        // Attraction to related drifting
        for (const other of particles) {
          if (other !== this && this.related.includes(other.symbol)) {
            const odx = other.x - this.x;
            const ody = other.y - this.y;
            const odist = Math.sqrt(odx * odx + ody * ody);
            if (odist > 20 && odist < 150) {
              this.vx += (odx / odist) * 0.003;
              this.vy += (ody / odist) * 0.003;
            }
          }
        }

        this.vx += (Math.random() - 0.5) * 0.015;
        this.vy += (Math.random() - 0.5) * 0.015;
        this.vx *= 0.985;
        this.vy *= 0.985;
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        const margin = 30;
        if (this.x < margin) this.vx += 0.05;
        if (this.x > size - margin) this.vx -= 0.05;
        if (this.y < margin) this.vy += 0.05;
        if (this.y > size - margin) this.vy -= 0.05;

        if (dist < amberRadius + 8) return true;
        return false;
      }

      draw(highlight = false) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.font = `500 ${this.size}px 'Courier New', monospace`;
        const alpha = highlight ? Math.min(1, this.opacity + 0.3) : this.opacity;
        ctx.fillStyle = highlight
          ? `rgba(255, 225, 160, ${alpha})`
          : `rgba(230, 190, 130, ${alpha})`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.symbol, 0, 0);
        ctx.restore();
      }
    }

    function drawPreserved(p, isHighlighted = false, isRelatedHighlight = false) {
      const x = center.x + Math.cos(p.angle) * p.distance;
      const y = center.y + Math.sin(p.angle) * p.distance;

      if (p.distance < amberRadius) {
        const depthRatio = 1 - (p.distance / amberRadius);
        const depthFade = 0.5 + depthRatio * 0.5;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(p.rotation);

        // Larger base size, scales with depth
        let fontSize = (p.size * 1.1) * (0.85 + depthRatio * 0.15);
        let alpha = Math.min(0.95, p.opacity * depthFade + 0.15);

        // Brighter amber color for better contrast
        let color = `rgba(215, 175, 115, ${alpha})`;

        if (isHighlighted) {
          fontSize = p.size * 1.4;
          color = `rgba(255, 235, 190, 0.98)`;
          ctx.shadowColor = 'rgba(255, 210, 120, 0.9)';
          ctx.shadowBlur = 12;
        } else if (isRelatedHighlight) {
          color = `rgba(240, 200, 140, ${Math.min(1, alpha + 0.25)})`;
          ctx.shadowColor = 'rgba(255, 200, 100, 0.5)';
          ctx.shadowBlur = 6;
        }

        ctx.font = `500 ${fontSize}px 'Courier New', monospace`;
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p.symbol, 0, 0);
        ctx.restore();
      }
      return { x, y };
    }

    function drawAmber() {
      const gradient = ctx.createRadialGradient(
        center.x - amberRadius * 0.2,
        center.y - amberRadius * 0.2,
        0,
        center.x,
        center.y,
        amberRadius
      );

      gradient.addColorStop(0, 'rgba(255, 225, 160, 0.85)');
      gradient.addColorStop(0.2, 'rgba(240, 190, 110, 0.75)');
      gradient.addColorStop(0.5, 'rgba(210, 160, 90, 0.65)');
      gradient.addColorStop(0.8, 'rgba(180, 130, 70, 0.5)');
      gradient.addColorStop(1, 'rgba(150, 100, 50, 0.3)');

      ctx.beginPath();
      ctx.arc(center.x, center.y, amberRadius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(center.x, center.y, amberRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 200, 100, 0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function spawnParticle(x, y, symbolData) {
      if (particles.length < 40) {
        // If no symbol provided, get a spawnable word
        const data = symbolData || getSpawnableWord();
        if (data) {
          particles.push(new Particle(x, y, data));
        }
      }
    }

    function burst() {
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = amberRadius + 60 + Math.random() * 80;
        spawnParticle(
          center.x + Math.cos(angle) * dist,
          center.y + Math.sin(angle) * dist
        );
      }
    }

    async function submitWord() {
      const input = document.getElementById('wordField');
      const word = input.value.trim().toLowerCase();

      if (!word) return;

      // Basic validation
      if (word.length < 2 || word.length > 30) {
        input.value = '';
        input.placeholder = 'too short/long';
        setTimeout(() => { input.placeholder = 'offer a word...'; }, 2000);
        return;
      }

      // Check if word already exists
      if (existingWords.has(word)) {
        input.value = '';
        input.placeholder = 'already exists';
        setTimeout(() => { input.placeholder = 'offer a word...'; }, 2000);
        return;
      }

      // Spawn the word from the edge
      const angle = Math.random() * Math.PI * 2;
      const dist = size * 0.4 + Math.random() * size * 0.1;
      spawnParticle(
        center.x + Math.cos(angle) * dist,
        center.y + Math.sin(angle) * dist,
        { word: word, parent: null }  // visitor-contributed, no parent
      );

      input.value = '';
      playTone(500, 0.2, 0.05);
    }

    // Handle enter key
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('wordField');
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          submitWord();
        }
      });
    });

    function togglePause() {
      paused = !paused;
    }

    // Replay controls
    function skipReplay() {
      if (!replayMode) return;

      // Instantly add all remaining words
      while (replayIndex < replayData.length) {
        preserved.push(replayData[replayIndex]);
        replayIndex++;
      }

      amberRadius = 20 + preserved.length * 0.8;
      amberRadius = Math.min(amberRadius, size * 0.42);

      endReplay();
    }

    function toggleReplaySpeed() {
      replaySpeed = replaySpeed === 1 ? 2 : replaySpeed === 2 ? 4 : 1;
      const label = replaySpeed === 1 ? '2x' : replaySpeed === 2 ? '4x' : '1x';
      document.getElementById('replaySpeed').textContent = `[${label} speed]`;
    }

    function endReplay() {
      replayMode = false;
      particles = []; // Clear any replay particles

      // Hide replay UI
      document.getElementById('replayProgress').classList.remove('active');
      document.getElementById('replayControls').classList.remove('active');

      // Show hint with fade in
      const hint = document.getElementById('hint');
      hint.style.display = 'block';
      hint.style.animation = 'none';
      hint.offsetHeight; // Trigger reflow
      hint.style.animation = 'fadeInOut 8s ease-out forwards';

      // Play completion sound
      playTone(600, 0.3, 0.08);
      setTimeout(() => playTone(800, 0.4, 0.06), 100);

      // Spawn some initial drifting particles
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = amberRadius + 80 + Math.random() * 120;
        spawnParticle(
          center.x + Math.cos(angle) * dist,
          center.y + Math.sin(angle) * dist
        );
      }
    }

    // Replay particle - spawns from outside and moves to its final position
    class ReplayParticle {
      constructor(data) {
        this.data = data;
        // Start from outside
        const startAngle = data.angle + (Math.random() - 0.5) * 0.5;
        const startDist = size * 0.4 + Math.random() * size * 0.1;
        this.x = center.x + Math.cos(startAngle) * startDist;
        this.y = center.y + Math.sin(startAngle) * startDist;
        this.targetX = center.x + Math.cos(data.angle) * data.distance;
        this.targetY = center.y + Math.sin(data.angle) * data.distance;
        this.progress = 0;
        this.speed = 0.08 + Math.random() * 0.04;
      }

      update() {
        this.progress += this.speed * replaySpeed;
        if (this.progress >= 1) {
          return true; // Done, add to preserved
        }

        // Ease out
        const t = 1 - Math.pow(1 - this.progress, 3);
        this.x = this.x + (this.targetX - this.x) * t * 0.15;
        this.y = this.y + (this.targetY - this.y) * t * 0.15;

        return false;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.data.rotation);
        const fontSize = this.data.size * 1.1;
        ctx.font = `500 ${fontSize}px 'Courier New', monospace`;
        ctx.fillStyle = `rgba(230, 190, 130, ${0.4 + this.progress * 0.5})`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.data.symbol, 0, 0);
        ctx.restore();
      }
    }

    let replayParticles = [];

    function updateStats() {
      document.getElementById('preserved').textContent = preserved.length;
      // Count undigested words
      const undigestedCount = Object.values(vocabulary).filter(v => !v.is_digested).length;
      document.getElementById('pending').textContent = undigestedCount;
    }

    function getAge(date) {
      const seconds = (Date.now() - date.getTime()) / 1000;
      if (seconds < 60) return `${Math.floor(seconds)}s ago`;
      const minutes = seconds / 60;
      if (minutes < 60) return `${Math.floor(minutes)}m ago`;
      const hours = minutes / 60;
      if (hours < 24) return `${Math.floor(hours)}h ago`;
      const days = hours / 24;
      return `${Math.floor(days)}d ago`;
    }

    function showExaminePanel(p) {
      const panel = document.getElementById('examinePanel');
      document.getElementById('examineWord').textContent = p.symbol;

      // Build age string with parent info for non-root words
      const vocabEntry = vocabulary[p.symbol];
      const isRoot = vocabEntry?.is_root;
      const parentWord = p.parentWord || vocabEntry?.parent_word;

      let ageText = `preserved ${getAge(p.preservedAt)} · depth ${Math.floor((1 - p.distance / amberRadius) * 100)}%`;
      if (isRoot) {
        ageText = `root word · ${ageText}`;
      } else if (parentWord) {
        ageText = `spawned from "${parentWord}" · ${ageText}`;
      }
      document.getElementById('examineAge').textContent = ageText;

      const connectionsEl = document.getElementById('examineConnections');
      const related = p.related;
      const preservedSymbols = preserved.map(x => x.symbol);

      if (related.length > 0) {
        connectionsEl.innerHTML = related.map(r => {
          const isPreserved = preservedSymbols.includes(r);
          return `<span class="connection ${isPreserved ? 'preserved' : ''}">${r}${isPreserved ? ' ·' : ''}</span>`;
        }).join(' ');
      } else {
        connectionsEl.innerHTML = '<span style="opacity:0.4">awaiting digestion...</span>';
      }

      panel.classList.add('active');
    }

    function hideExaminePanel() {
      document.getElementById('examinePanel').classList.remove('active');
    }

    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;

      hoveredPreserved = null;
      for (const p of preserved) {
        const x = center.x + Math.cos(p.angle) * p.distance;
        const y = center.y + Math.sin(p.angle) * p.distance;
        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        if (dist < 20 && p.distance < amberRadius) {
          hoveredPreserved = p;
          break;
        }
      }

      if (hoveredPreserved) {
        showExaminePanel(hoveredPreserved);
        canvas.style.cursor = 'pointer';
      } else {
        hideExaminePanel();
        canvas.style.cursor = 'crosshair';
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (hoveredPreserved) {
        examinedWord = examinedWord === hoveredPreserved ? null : hoveredPreserved;
        if (examinedWord) playTone(600, 0.2, 0.08);
      } else {
        for (let i = 0; i < 3; i++) {
          spawnParticle(
            x + (Math.random() - 0.5) * 30,
            y + (Math.random() - 0.5) * 30
          );
        }
        playTone(300 + Math.random() * 100, 0.15, 0.03);
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (!examinedWord) {
        hoveredPreserved = null;
        hideExaminePanel();
      }
    });

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;

      // Check if touching a preserved word
      let touchedPreserved = null;
      for (const p of preserved) {
        const px = center.x + Math.cos(p.angle) * p.distance;
        const py = center.y + Math.sin(p.angle) * p.distance;
        const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
        if (dist < 25 && p.distance < amberRadius) {
          touchedPreserved = p;
          break;
        }
      }

      if (touchedPreserved) {
        examinedWord = examinedWord === touchedPreserved ? null : touchedPreserved;
        if (examinedWord) {
          showExaminePanel(examinedWord);
          playTone(600, 0.2, 0.08);
        } else {
          hideExaminePanel();
        }
      } else {
        // Spawn particles on tap
        for (let i = 0; i < 3; i++) {
          spawnParticle(
            x + (Math.random() - 0.5) * 30,
            y + (Math.random() - 0.5) * 30
          );
        }
        playTone(300 + Math.random() * 100, 0.15, 0.03);
        // Clear examined word when tapping elsewhere
        if (examinedWord) {
          examinedWord = null;
          hideExaminePanel();
        }
      }
    }, { passive: false });

    function animate() {
      if (!loaded) {
        requestAnimationFrame(animate);
        return;
      }

      if (!paused) {
        time++;

        ctx.fillStyle = '#0a0806';
        ctx.fillRect(0, 0, size, size);

        // REPLAY MODE
        if (replayMode) {
          // Spawn new replay particles
          const wordsToSpawn = replayWordsPerFrame * replaySpeed;
          for (let i = 0; i < wordsToSpawn && replayIndex < replayData.length; i++) {
            if (replayParticles.length < 50) { // Limit active particles
              replayParticles.push(new ReplayParticle(replayData[replayIndex]));
              replayIndex++;
            }
          }

          // Update replay progress
          document.getElementById('replayCount').textContent = preserved.length;

          // Update and draw replay particles
          replayParticles = replayParticles.filter(p => {
            const done = p.update();
            if (done) {
              // Add to preserved
              preserved.push(p.data);
              amberRadius = 20 + preserved.length * 0.8;
              amberRadius = Math.min(amberRadius, size * 0.42);

              // Soft sound occasionally
              if (Math.random() < 0.1) {
                const freq = 400 + (preserved.length * 3) % 200;
                playTone(freq, 0.15, 0.02);
              }
              return false;
            }
            p.draw();
            return true;
          });

          // Draw preserved words
          const sortedPreserved = [...preserved].sort((a, b) => a.distance - b.distance);
          for (const p of sortedPreserved) {
            drawPreserved(p, false, false);
          }

          drawAmber();

          // Check if replay is complete
          if (replayIndex >= replayData.length && replayParticles.length === 0) {
            endReplay();
          }

          updateStats();
          requestAnimationFrame(animate);
          return;
        }

        // NORMAL MODE
        if (Math.random() < 0.015 && particles.length < 25) {
          const angle = Math.random() * Math.PI * 2;
          const dist = size * 0.35 + Math.random() * size * 0.1;
          spawnParticle(
            center.x + Math.cos(angle) * dist,
            center.y + Math.sin(angle) * dist
          );
        }

        const highlightedSymbols = new Set();
        const activeWord = examinedWord || hoveredPreserved;
        if (activeWord) {
          for (const r of activeWord.related) {
            highlightedSymbols.add(r);
          }
        }

        const sortedPreserved = [...preserved].sort((a, b) => a.distance - b.distance);
        for (const p of sortedPreserved) {
          const isMain = p === activeWord;
          const isRelated = highlightedSymbols.has(p.symbol);
          drawPreserved(p, isMain, isRelated);
        }

        drawAmber();

        particles = particles.filter(p => {
          const caught = p.update();
          if (caught) {
            const dx = p.x - center.x;
            const dy = p.y - center.y;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            const newPreserved = {
              symbol: p.symbol,
              angle: angle,
              distance: distance,
              size: p.size,
              rotation: p.rotation,
              opacity: 0.7 + Math.random() * 0.2,
              preservedAt: new Date(),
              related: getRelated(p.symbol),
              parentWord: p.parentWord || null
            };

            preserved.push(newPreserved);
            savePreserved(newPreserved);
            amberRadius += 0.8;
            amberRadius = Math.min(amberRadius, size * 0.42);

            const freq = 400 + (preserved.length * 5) % 300;
            playTone(freq, 0.4, 0.06);
            playTone(freq * 1.5, 0.3, 0.03);

            return false;
          }

          const isRelated = activeWord && activeWord.related.includes(p.symbol);
          p.draw(isRelated);
          return true;
        });

        updateStats();
      }

      requestAnimationFrame(animate);
    }

    // Initialize
    loadPreserved().then(() => {
      // Only spawn initial particles if not in replay mode
      if (!replayMode) {
        for (let i = 0; i < 12; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = amberRadius + 80 + Math.random() * 120;
          spawnParticle(
            center.x + Math.cos(angle) * dist,
            center.y + Math.sin(angle) * dist
          );
        }
      }
    });

    animate();
  </script>
</body>
</html>
