<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/amber/favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stigmergy: Emergent Pathfinding</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            color: #d4a574;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #d4a574;
        }
        .info {
            font-size: 12px;
            margin-bottom: 20px;
            opacity: 0.7;
            max-width: 600px;
            text-align: center;
        }
        canvas {
            border: 1px solid #333;
            background: #000;
            image-rendering: pixelated;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 600px;
        }
        button {
            background: #1a1a1a;
            color: #d4a574;
            border: 1px solid #d4a574;
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        button:hover { background: #2a2a2a; }
        button:active { background: #d4a574; color: #0a0a0a; }
.stats {
            margin-top: 20px;
            font-size: 11px;
            opacity: 0.8;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-width: 400px;
        }
        .stat { text-align: center; }
        .stat-value { font-size: 18px; color: #d4a574; }
        .legend {
            margin-top: 15px;
            font-size: 11px;
            opacity: 0.6;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Stigmergy: Emergent Pathfinding</h1>
    <p class="info">
        Agents follow simple rules: move randomly, prefer stronger pheromone trails, deposit pheromones.
        No memory, no communication. Watch for emergent optimal paths between food sources.
    </p>
    
    <canvas id="canvas" width="600" height="600"></canvas>
    
    <div class="controls">
        <button id="reset">Reset</button>
        <button id="pause">Pause</button>
        <button id="faster">Faster</button>
        <button id="slower">Slower</button>
    </div>
    
    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="generation">0</div>
            <div>Generation</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="efficiency">0%</div>
            <div>Path Efficiency</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="convergence">0%</div>
            <div>Convergence</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="agents">0</div>
            <div>Active Agents</div>
        </div>
    </div>
    
    <p class="legend">
        ðŸŸ¤ Nest â€¢ ðŸŸ¢ Food â€¢ Trail brightness = pheromone strength
    </p>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = 200, H = 200; // Grid size
        const SCALE = canvas.width / W;
        
        // World state
        let pheromones = Array(W).fill(0).map(() => Array(H).fill(0));
        let agents = [];
        let nest = { x: 50, y: 100 };
        let food = [
            { x: 150, y: 50 },
            { x: 150, y: 150 }
        ];
        
        // Parameters
        const AGENT_COUNT = 100;
        const PHEROMONE_DEPOSIT = 10;
        const EVAPORATION_RATE = 0.995;
        const RANDOM_FACTOR = 0.2;
        const SENSING_RADIUS = 5;
        
        let generation = 0;
        let running = true;
        let speed = 1;
        
        class Agent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.hasFood = false;
                this.age = 0;
            }
            
            move() {
                this.age++;
                
                // Goal: if has food, go to nest. Otherwise, go to food.
                const target = this.hasFood ? nest : this.findNearestFood();
                
                // Sense pheromones in nearby cells
                let bestDir = null;
                let bestScore = -Infinity;
                
                const dirs = [
                    {dx: 0, dy: -1}, {dx: 1, dy: -1}, {dx: 1, dy: 0}, {dx: 1, dy: 1},
                    {dx: 0, dy: 1}, {dx: -1, dy: 1}, {dx: -1, dy: 0}, {dx: -1, dy: -1}
                ];
                
                for (let dir of dirs) {
                    const nx = this.x + dir.dx;
                    const ny = this.y + dir.dy;
                    
                    if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;
                    
                    // Score = pheromone strength + bias toward target + randomness
                    const pheromone = pheromones[nx][ny];
                    const distToTarget = Math.hypot(nx - target.x, ny - target.y);
                    const currentDist = Math.hypot(this.x - target.x, this.y - target.y);
                    const targetBias = (currentDist - distToTarget) * 2; // Prefer moves closer to target
                    
                    const score = pheromone * 0.5 + targetBias + Math.random() * RANDOM_FACTOR * 10;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestDir = dir;
                    }
                }
                
                if (bestDir) {
                    this.x += bestDir.dx;
                    this.y += bestDir.dy;
                }
                
                // Deposit pheromones if carrying food
                if (this.hasFood) {
                    pheromones[this.x][this.y] += PHEROMONE_DEPOSIT;
                }
                
                // Check for food pickup
                if (!this.hasFood) {
                    for (let f of food) {
                        if (Math.hypot(this.x - f.x, this.y - f.y) < 3) {
                            this.hasFood = true;
                            break;
                        }
                    }
                }
                
                // Check for nest dropoff
                if (this.hasFood && Math.hypot(this.x - nest.x, this.y - nest.y) < 3) {
                    this.hasFood = false;
                    // Respawn at nest
                    this.x = nest.x + Math.floor(Math.random() * 6) - 3;
                    this.y = nest.y + Math.floor(Math.random() * 6) - 3;
                }
            }
            
            findNearestFood() {
                let nearest = food[0];
                let minDist = Infinity;
                for (let f of food) {
                    const dist = Math.hypot(this.x - f.x, this.y - f.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = f;
                    }
                }
                return nearest;
            }
        }
        
        function init() {
            agents = [];
            pheromones = Array(W).fill(0).map(() => Array(H).fill(0));
            generation = 0;
            
            // Spawn agents at nest
            for (let i = 0; i < AGENT_COUNT; i++) {
                agents.push(new Agent(
                    nest.x + Math.floor(Math.random() * 10) - 5,
                    nest.y + Math.floor(Math.random() * 10) - 5
                ));
            }
        }
        
        function update() {
            if (!running) return;
            
            // Update agents
            for (let agent of agents) {
                agent.move();
            }
            
            // Evaporate pheromones
            for (let x = 0; x < W; x++) {
                for (let y = 0; y < H; y++) {
                    pheromones[x][y] *= EVAPORATION_RATE;
                }
            }
            
            generation++;
        }
        
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw pheromones
            for (let x = 0; x < W; x++) {
                for (let y = 0; y < H; y++) {
                    const strength = Math.min(pheromones[x][y] / 50, 1);
                    if (strength > 0.01) {
                        ctx.fillStyle = `rgba(212, 165, 116, ${strength * 0.6})`;
                        ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);
                    }
                }
            }
            
            // Draw nest
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(nest.x * SCALE, nest.y * SCALE, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw food sources
            ctx.fillStyle = '#4a7c4e';
            for (let f of food) {
                ctx.beginPath();
                ctx.arc(f.x * SCALE, f.y * SCALE, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw agents
            for (let agent of agents) {
                ctx.fillStyle = agent.hasFood ? '#4a7c4e' : '#d4a574';
                ctx.fillRect(agent.x * SCALE, agent.y * SCALE, SCALE * 1.5, SCALE * 1.5);
            }
            
            // Update stats
            document.getElementById('generation').textContent = generation;
            document.getElementById('agents').textContent = agents.length;
            
            // Calculate efficiency: how much pheromone is on optimal paths vs scattered
            const optimalCells = new Set();
            for (let f of food) {
                // Bresenham line from nest to food
                const cells = getLine(nest.x, nest.y, f.x, f.y, 3); // 3 cell width
                cells.forEach(c => optimalCells.add(`${c.x},${c.y}`));
            }
            
            let optimalPheromone = 0;
            let totalPheromone = 0;
            for (let x = 0; x < W; x++) {
                for (let y = 0; y < H; y++) {
                    totalPheromone += pheromones[x][y];
                    if (optimalCells.has(`${x},${y}`)) {
                        optimalPheromone += pheromones[x][y];
                    }
                }
            }
            
            const efficiency = totalPheromone > 0 ? (optimalPheromone / totalPheromone * 100) : 0;
            document.getElementById('efficiency').textContent = efficiency.toFixed(1) + '%';
            
            // Convergence: what % of cells have very low pheromone (trail has converged)
            let lowPheromone = 0;
            for (let x = 0; x < W; x++) {
                for (let y = 0; y < H; y++) {
                    if (pheromones[x][y] < 0.1) lowPheromone++;
                }
            }
            const convergence = (lowPheromone / (W * H) * 100);
            document.getElementById('convergence').textContent = convergence.toFixed(1) + '%';
        }
        
        function getLine(x0, y0, x1, y1, width) {
            const cells = new Set();
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            let x = x0, y = y0;
            while (true) {
                // Add cell and neighbors for width
                for (let wx = -width; wx <= width; wx++) {
                    for (let wy = -width; wy <= width; wy++) {
                        if (x + wx >= 0 && x + wx < W && y + wy >= 0 && y + wy < H) {
                            cells.add({x: x + wx, y: y + wy});
                        }
                    }
                }
                
                if (x === x1 && y === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x += sx; }
                if (e2 < dx) { err += dx; y += sy; }
            }
            return cells;
        }
        
        function loop() {
            for (let i = 0; i < speed; i++) {
                update();
            }
            draw();
            requestAnimationFrame(loop);
        }
        
        // Controls
        document.getElementById('reset').onclick = () => init();
        document.getElementById('pause').onclick = () => {
            running = !running;
            document.getElementById('pause').textContent = running ? 'Pause' : 'Resume';
        };
        document.getElementById('faster').onclick = () => speed = Math.min(speed + 1, 10);
        document.getElementById('slower').onclick = () => speed = Math.max(speed - 1, 1);
        
        init();
        loop();
    </script>
</body>
</html>