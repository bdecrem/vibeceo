<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stigmergy</title>
    <meta property="og:title" content="Stigmergy">
    <meta property="og:description" content="Ideas finding each other through traces left by curious minds">
    <meta property="og:image" content="https://kochi.to/amber/stigmergy-og.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(circle at center, #2d1810 0%, #1a0f08 100%);
            overflow: hidden;
            font-family: 'Georgia', serif;
            cursor: none;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #d4af37;
            font-size: 14px;
            opacity: 0.7;
            z-index: 100;
        }

        #tooltip {
            position: fixed;
            background: rgba(212, 175, 55, 0.95);
            color: #1a0f08;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 300px;
            line-height: 1.4;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .concept {
            position: absolute;
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid;
            border-radius: 12px;
            pointer-events: none;
            transition: all 0.3s ease;
            white-space: nowrap;
            cursor: pointer;
        }

        .concept.attracted {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .concept.crystallized {
            transform: scale(1.2);
            box-shadow: 0 0 25px currentColor;
            border-width: 2px;
            font-weight: bold;
        }

        .trace {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #d4af37 0%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.6;
        }

        .cursor {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #d4af37;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }

        .crystallization-glow {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.3) 0%, transparent 70%);
            pointer-events: none;
            animation: crystallize 2s ease-out;
        }

        @keyframes crystallize {
            0% { 
                width: 0px; 
                height: 0px; 
                opacity: 1; 
            }
            100% { 
                width: 200px; 
                height: 200px; 
                opacity: 0; 
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div id="info">
        Ideas drift. Movement leaves traces. Proximity breeds understanding.
    </div>
    
    <div id="tooltip"></div>
    <canvas id="canvas"></canvas>
    <div class="cursor" id="cursor"></div>

    <script>
        // Data will be loaded from JSON
        let conceptData = null;
        let relatednessMap = new Map();
        let domainColors = new Map();
        
        // Core state
        const concepts = [];
        const traces = [];
        const attractionWells = [];
        const crystallizedFormations = [];
        
        let mouseX = 0;
        let mouseY = 0;
        let lastTraceTime = 0;
        let hoveredConcept = null;

        class Concept {
            constructor(conceptInfo, x, y) {
                this.id = conceptInfo.id;
                this.phrase = conceptInfo.phrase;
                this.domain = conceptInfo.domain;
                this.description = conceptInfo.description;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.element = this.createElement();
                this.attracted = false;
                this.crystallized = false;
                this.attractedBy = null;
                this.clustered = [];
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'concept';
                el.textContent = this.phrase;
                
                // Set domain color
                const color = domainColors.get(this.domain) || '#d4af37';
                el.style.color = color;
                el.style.backgroundColor = this.hexToRgba(color, 0.1);
                el.style.borderColor = this.hexToRgba(color, 0.3);
                
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                
                // Add hover events
                el.addEventListener('mouseenter', () => {
                    hoveredConcept = this;
                    this.showTooltip();
                });
                
                el.addEventListener('mouseleave', () => {
                    hoveredConcept = null;
                    this.hideTooltip();
                });
                
                document.body.appendChild(el);
                return el;
            }

            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            showTooltip() {
                const tooltip = document.getElementById('tooltip');
                tooltip.textContent = this.description;
                tooltip.style.opacity = '1';
                tooltip.style.left = (this.x + 100) + 'px';
                tooltip.style.top = (this.y - 20) + 'px';
            }

            hideTooltip() {
                const tooltip = document.getElementById('tooltip');
                tooltip.style.opacity = '0';
            }

            update() {
                if (this.crystallized) return;

                // Drift
                this.x += this.vx;
                this.y += this.vy;

                // Boundary bounce
                if (this.x < 0 || this.x > window.innerWidth - 100) this.vx *= -1;
                if (this.y < 0 || this.y > window.innerHeight - 30) this.vy *= -1;

                // Attraction to mouse
                const mouseDistance = Math.sqrt((this.x - mouseX) ** 2 + (this.y - mouseY) ** 2);
                if (mouseDistance < 150) {
                    const force = (150 - mouseDistance) / 150;
                    const angle = Math.atan2(mouseY - this.y, mouseX - this.x);
                    this.vx += Math.cos(angle) * force * 0.01;
                    this.vy += Math.sin(angle) * force * 0.01;
                    
                    if (!this.attracted) {
                        this.attracted = true;
                        this.element.classList.add('attracted');
                    }
                } else if (this.attracted) {
                    this.attracted = false;
                    this.element.classList.remove('attracted');
                }

                // Attraction to wells
                attractionWells.forEach(well => {
                    const wellDistance = Math.sqrt((this.x - well.x) ** 2 + (this.y - well.y) ** 2);
                    if (wellDistance < well.strength * 100) {
                        const force = well.strength * 0.005;
                        const angle = Math.atan2(well.y - this.y, well.x - this.x);
                        this.vx += Math.cos(angle) * force;
                        this.vy += Math.sin(angle) * force;
                    }
                });

                // Semantic attraction to related concepts
                this.attractToRelatedConcepts();

                // Damping
                this.vx *= 0.98;
                this.vy *= 0.98;

                // Update position
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';

                // Check for clustering
                this.checkSemanticClustering();
            }

            attractToRelatedConcepts() {
                const relationshipKey = this.id;
                const relatedConcepts = relatednessMap.get(relationshipKey) || [];
                
                relatedConcepts.forEach(({ conceptId, score }) => {
                    const relatedConcept = concepts.find(c => c.id === conceptId);
                    if (!relatedConcept || relatedConcept.crystallized) return;
                    
                    const distance = Math.sqrt((this.x - relatedConcept.x) ** 2 + (this.y - relatedConcept.y) ** 2);
                    if (distance < 200) {
                        const force = score * 0.002;
                        const angle = Math.atan2(relatedConcept.y - this.y, relatedConcept.x - this.x);
                        this.vx += Math.cos(angle) * force;
                        this.vy += Math.sin(angle) * force;
                    }
                });
            }

            checkSemanticClustering() {
                const nearbyConceptsThreshold = 80;
                const relationshipKey = this.id;
                const relatedConcepts = relatednessMap.get(relationshipKey) || [];
                
                const nearbyRelated = [];
                relatedConcepts.forEach(({ conceptId, score }) => {
                    const concept = concepts.find(c => c.id === conceptId);
                    if (!concept || concept.crystallized) return;
                    
                    const distance = Math.sqrt((this.x - concept.x) ** 2 + (this.y - concept.y) ** 2);
                    if (distance < nearbyConceptsThreshold && score > 0.8) {
                        nearbyRelated.push({ concept, score });
                    }
                });

                // Need at least 2 highly related concepts nearby
                if (nearbyRelated.length >= 2 && Math.random() < 0.003) {
                    const cluster = [this, ...nearbyRelated.map(r => r.concept)];
                    this.crystallize(cluster);
                }
            }

            crystallize(cluster) {
                cluster.forEach(concept => {
                    if (!concept.crystallized) {
                        concept.crystallized = true;
                        concept.element.classList.add('crystallized');
                        concept.vx = 0;
                        concept.vy = 0;
                        
                        // Enhanced visual for crystallized concepts
                        const color = domainColors.get(concept.domain) || '#d4af37';
                        concept.element.style.backgroundColor = this.hexToRgba(color, 0.8);
                        concept.element.style.color = '#1a0f08';
                        concept.element.style.borderColor = color;
                    }
                });

                // Create crystallization effect
                this.createCrystallizationEffect(cluster);
            }

            createCrystallizationEffect(cluster) {
                // Calculate center
                const centerX = cluster.reduce((sum, c) => sum + c.x, 0) / cluster.length;
                const centerY = cluster.reduce((sum, c) => sum + c.y, 0) / cluster.length;

                // Add to crystallized formations with stronger attraction
                crystallizedFormations.push({
                    x: centerX,
                    y: centerY,
                    concepts: cluster.map(c => c.phrase),
                    domain: cluster[0].domain,
                    time: Date.now()
                });

                // Create permanent attraction well
                attractionWells.push({
                    x: centerX,
                    y: centerY,
                    strength: 2.0,
                    decay: 0.0001, // Very slow decay for crystallized formations
                    type: 'crystallized'
                });

                // Visual crystallization effect
                const glow = document.createElement('div');
                glow.className = 'crystallization-glow';
                glow.style.left = (centerX - 100) + 'px';
                glow.style.top = (centerY - 100) + 'px';
                document.body.appendChild(glow);
                
                setTimeout(() => glow.remove(), 2000);

                // Pulse effect on concepts
                setTimeout(() => {
                    cluster.forEach(concept => {
                        if (concept.element) {
                            concept.element.style.animation = 'pulse 1s ease-in-out';
                        }
                    });
                }, 100);
            }

            destroy() {
                if (this.element) {
                    this.element.remove();
                }
            }
        }

        class Trace {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.element = this.createElement();
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'trace';
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                document.body.appendChild(el);
                return el;
            }

            update() {
                this.life -= 0.005;
                this.element.style.opacity = this.life * 0.6;
                
                if (this.life <= 0) {
                    // Create attraction well before dying
                    attractionWells.push({
                        x: this.x,
                        y: this.y,
                        strength: 0.5,
                        decay: 0.001,
                        type: 'trace'
                    });
                    return false;
                }
                return true;
            }

            destroy() {
                if (this.element) {
                    this.element.remove();
                }
            }
        }

        // Load data and initialize
        async function loadConceptData() {
            try {
                const response = await fetch('./stigmergy-concepts.json');
                conceptData = await response.json();
                
                // Build relatedness map
                conceptData.relatedness.forEach(rel => {
                    if (!relatednessMap.has(rel.a)) {
                        relatednessMap.set(rel.a, []);
                    }
                    if (!relatednessMap.has(rel.b)) {
                        relatednessMap.set(rel.b, []);
                    }
                    
                    relatednessMap.get(rel.a).push({ conceptId: rel.b, score: rel.score });
                    relatednessMap.get(rel.b).push({ conceptId: rel.a, score: rel.score });
                });
                
                // Build domain color map
                conceptData.domains.forEach(domain => {
                    domainColors.set(domain.id, domain.color);
                });
                
                console.log('Loaded', conceptData.concepts.length, 'concepts and', conceptData.relatedness.length, 'relationships');
                
            } catch (error) {
                console.error('Failed to load concept data:', error);
                // Fallback to basic concepts
                conceptData = { concepts: [
                    {id: "c001", phrase: "emergent behavior", domain: "complexity", description: "Complex patterns arising from simple rules"},
                    {id: "c002", phrase: "stigmergy", domain: "complexity", description: "Indirect coordination through environment modification"}
                ]};
            }
        }

        // Initialize concepts
        function spawnConcept() {
            if (!conceptData || !conceptData.concepts) return;
            
            const conceptInfo = conceptData.concepts[Math.floor(Math.random() * conceptData.concepts.length)];
            const x = Math.random() * (window.innerWidth - 200) + 100;
            const y = Math.random() * (window.innerHeight - 100) + 50;
            
            const concept = new Concept(conceptInfo, x, y);
            concepts.push(concept);
            
            // Keep concept count manageable
            if (concepts.length > 25) {
                const oldest = concepts.shift();
                oldest.destroy();
            }
        }

        // Bias spawning near crystallized formations
        function spawnRelatedConcept() {
            if (!conceptData || crystallizedFormations.length === 0) {
                spawnConcept();
                return;
            }
            
            // Sometimes spawn randomly, sometimes near crystals
            if (Math.random() < 0.6) {
                spawnConcept();
                return;
            }
            
            const formation = crystallizedFormations[Math.floor(Math.random() * crystallizedFormations.length)];
            const domain = formation.domain;
            
            // Find concepts in the same domain
            const domainConcepts = conceptData.concepts.filter(c => c.domain === domain);
            if (domainConcepts.length === 0) {
                spawnConcept();
                return;
            }
            
            const conceptInfo = domainConcepts[Math.floor(Math.random() * domainConcepts.length)];
            
            // Spawn near the formation
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 150;
            const x = formation.x + Math.cos(angle) * distance;
            const y = formation.y + Math.sin(angle) * distance;
            
            // Clamp to screen bounds
            const clampedX = Math.max(100, Math.min(window.innerWidth - 200, x));
            const clampedY = Math.max(50, Math.min(window.innerHeight - 100, y));
            
            const concept = new Concept(conceptInfo, clampedX, clampedY);
            concepts.push(concept);
            
            if (concepts.length > 25) {
                const oldest = concepts.shift();
                oldest.destroy();
            }
        }

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const cursor = document.getElementById('cursor');
            cursor.style.left = (mouseX - 6) + 'px';
            cursor.style.top = (mouseY - 6) + 'px';
            
            // Create traces
            const now = Date.now();
            if (now - lastTraceTime > 100) {
                const trace = new Trace(mouseX, mouseY);
                traces.push(trace);
                lastTraceTime = now;
            }
        });

        // Animation loop
        function animate() {
            // Update concepts
            concepts.forEach(concept => concept.update());
            
            // Update traces
            for (let i = traces.length - 1; i >= 0; i--) {
                if (!traces[i].update()) {
                    traces[i].destroy();
                    traces.splice(i, 1);
                }
            }
            
            // Update attraction wells
            for (let i = attractionWells.length - 1; i >= 0; i--) {
                attractionWells[i].strength -= attractionWells[i].decay;
                if (attractionWells[i].strength <= 0) {
                    attractionWells.splice(i, 1);
                }
            }
            
            requestAnimationFrame(animate);
        }

        // Start the simulation
        async function init() {
            await loadConceptData();
            
            // Spawn initial concepts
            for (let i = 0; i < 15; i++) {
                setTimeout(() => spawnRelatedConcept(), i * 300);
            }
            
            // Keep spawning new concepts periodically
            setInterval(spawnRelatedConcept, 3000);
            
            // Start animation
            animate();
        }

        init();
    </script>
</body>
</html>