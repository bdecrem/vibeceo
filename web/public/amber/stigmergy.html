<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stigmergy</title>
    <meta property="og:title" content="Stigmergy">
    <meta property="og:description" content="Ideas finding each other through traces left by curious minds">
    <meta property="og:image" content="https://kochi.to/amber/stigmergy-og.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(circle at center, #2d1810 0%, #1a0f08 100%);
            overflow: hidden;
            font-family: 'Georgia', serif;
            cursor: none;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #d4af37;
            font-size: 14px;
            opacity: 0.7;
            z-index: 100;
        }

        .concept {
            position: absolute;
            color: #d4af37;
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            pointer-events: none;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .concept.attracted {
            background: rgba(212, 175, 55, 0.2);
            border-color: rgba(212, 175, 55, 0.5);
            transform: scale(1.1);
        }

        .concept.crystallized {
            background: rgba(212, 175, 55, 0.8);
            color: #1a0f08;
            border-color: #d4af37;
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .trace {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #d4af37 0%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.6;
        }

        .cursor {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #d4af37;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="info">
        Ideas drift. Movement leaves traces. Proximity breeds understanding.
    </div>
    
    <canvas id="canvas"></canvas>
    <div class="cursor" id="cursor"></div>

    <script>
        // Core state
        const concepts = [];
        const traces = [];
        const attractionWells = [];
        const crystallizedFormations = [];
        
        let mouseX = 0;
        let mouseY = 0;
        let lastTraceTime = 0;
        
        // Sample concept pool (Mave will replace with arXiv magic)
        const conceptPool = [
            "emergent behavior", "cellular automata", "stigmergy", "collective intelligence",
            "self-organization", "swarm dynamics", "complex systems", "phase transitions",
            "information cascades", "network effects", "pattern formation", "spontaneous order",
            "distributed cognition", "emergence", "feedback loops", "tipping points",
            "collective memory", "social learning", "adaptive systems", "cooperation",
            "evolution of language", "cultural transmission", "innovation diffusion",
            "wisdom of crowds", "group decision making", "social influence"
        ];

        class Concept {
            constructor(text, x, y) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;
                this.element = this.createElement();
                this.attracted = false;
                this.crystallized = false;
                this.attractedBy = null;
                this.clustered = [];
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'concept';
                el.textContent = this.text;
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                document.body.appendChild(el);
                return el;
            }

            update() {
                if (this.crystallized) return;

                // Drift
                this.x += this.vx;
                this.y += this.vy;

                // Boundary bounce
                if (this.x < 0 || this.x > window.innerWidth - 100) this.vx *= -1;
                if (this.y < 0 || this.y > window.innerHeight - 30) this.vy *= -1;

                // Attraction to mouse
                const mouseDistance = Math.sqrt((this.x - mouseX) ** 2 + (this.y - mouseY) ** 2);
                if (mouseDistance < 150) {
                    const force = (150 - mouseDistance) / 150;
                    const angle = Math.atan2(mouseY - this.y, mouseX - this.x);
                    this.vx += Math.cos(angle) * force * 0.01;
                    this.vy += Math.sin(angle) * force * 0.01;
                    
                    if (!this.attracted) {
                        this.attracted = true;
                        this.element.classList.add('attracted');
                    }
                } else if (this.attracted) {
                    this.attracted = false;
                    this.element.classList.remove('attracted');
                }

                // Attraction to wells
                attractionWells.forEach(well => {
                    const wellDistance = Math.sqrt((this.x - well.x) ** 2 + (this.y - well.y) ** 2);
                    if (wellDistance < well.strength * 100) {
                        const force = well.strength * 0.005;
                        const angle = Math.atan2(well.y - this.y, well.x - this.x);
                        this.vx += Math.cos(angle) * force;
                        this.vy += Math.sin(angle) * force;
                    }
                });

                // Damping
                this.vx *= 0.98;
                this.vy *= 0.98;

                // Update position
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';

                // Check for clustering
                this.checkClustering();
            }

            checkClustering() {
                const nearbyConceptsThreshold = 80;
                const nearby = concepts.filter(c => {
                    if (c === this || c.crystallized) return false;
                    const distance = Math.sqrt((this.x - c.x) ** 2 + (this.y - c.y) ** 2);
                    return distance < nearbyConceptsThreshold;
                });

                if (nearby.length >= 2 && Math.random() < 0.002) {
                    this.crystallize([this, ...nearby]);
                }
            }

            crystallize(cluster) {
                cluster.forEach(concept => {
                    if (!concept.crystallized) {
                        concept.crystallized = true;
                        concept.element.classList.add('crystallized');
                        concept.vx = 0;
                        concept.vy = 0;
                    }
                });

                // Create crystallization effect
                this.createCrystallizationEffect(cluster);
            }

            createCrystallizationEffect(cluster) {
                // Calculate center
                const centerX = cluster.reduce((sum, c) => sum + c.x, 0) / cluster.length;
                const centerY = cluster.reduce((sum, c) => sum + c.y, 0) / cluster.length;

                // Add to crystallized formations
                crystallizedFormations.push({
                    x: centerX,
                    y: centerY,
                    concepts: cluster.map(c => c.text),
                    time: Date.now()
                });

                // Visual effect (could be enhanced)
                setTimeout(() => {
                    cluster.forEach(concept => {
                        if (concept.element) {
                            concept.element.style.animation = 'pulse 0.5s ease-in-out';
                        }
                    });
                }, 100);
            }

            destroy() {
                if (this.element) {
                    this.element.remove();
                }
            }
        }

        class Trace {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.element = this.createElement();
            }

            createElement() {
                const el = document.createElement('div');
                el.className = 'trace';
                el.style.left = this.x + 'px';
                el.style.top = this.y + 'px';
                document.body.appendChild(el);
                return el;
            }

            update() {
                this.life -= 0.005;
                this.element.style.opacity = this.life * 0.6;
                
                if (this.life <= 0) {
                    // Create attraction well before dying
                    attractionWells.push({
                        x: this.x,
                        y: this.y,
                        strength: 0.5,
                        decay: 0.001
                    });
                    return false;
                }
                return true;
            }

            destroy() {
                if (this.element) {
                    this.element.remove();
                }
            }
        }

        // Initialize concepts
        function spawnConcept() {
            const text = conceptPool[Math.floor(Math.random() * conceptPool.length)];
            const x = Math.random() * (window.innerWidth - 200) + 100;
            const y = Math.random() * (window.innerHeight - 100) + 50;
            
            const concept = new Concept(text, x, y);
            concepts.push(concept);
            
            // Keep concept count manageable
            if (concepts.length > 25) {
                const oldest = concepts.shift();
                oldest.destroy();
            }
        }

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const cursor = document.getElementById('cursor');
            cursor.style.left = (mouseX - 6) + 'px';
            cursor.style.top = (mouseY - 6) + 'px';
            
            // Create traces
            const now = Date.now();
            if (now - lastTraceTime > 100) {
                const trace = new Trace(mouseX, mouseY);
                traces.push(trace);
                lastTraceTime = now;
            }
        });

        // Animation loop
        function animate() {
            // Update concepts
            concepts.forEach(concept => concept.update());
            
            // Update traces
            for (let i = traces.length - 1; i >= 0; i--) {
                if (!traces[i].update()) {
                    traces[i].destroy();
                    traces.splice(i, 1);
                }
            }
            
            // Update attraction wells
            for (let i = attractionWells.length - 1; i >= 0; i--) {
                attractionWells[i].strength -= attractionWells[i].decay;
                if (attractionWells[i].strength <= 0) {
                    attractionWells.splice(i, 1);
                }
            }
            
            requestAnimationFrame(animate);
        }

        // Start the simulation
        function init() {
            // Spawn initial concepts
            for (let i = 0; i < 15; i++) {
                setTimeout(() => spawnConcept(), i * 200);
            }
            
            // Keep spawning new concepts periodically
            setInterval(spawnConcept, 3000);
            
            // Start animation
            animate();
        }

        init();
    </script>
</body>
</html>