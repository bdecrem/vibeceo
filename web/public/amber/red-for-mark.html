<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/amber/favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RED â€” for Mark</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0000;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        #dedication {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.7;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            pointer-events: none;
            animation: pulse 3s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.9; }
        }
        
        #info {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #660000;
            font-size: 11px;
            letter-spacing: 2px;
            opacity: 0.6;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">CLICK TO REGENERATE</div>
    <div id="dedication">For Mark</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            draw();
        });
        
        // Red color palette
        const reds = [
            '#ff0000', '#cc0000', '#990000', '#ff3333', 
            '#ff1a1a', '#e60000', '#b30000', '#800000',
            '#ff4d4d', '#ff6666', '#cc0000', '#ff0033'
        ];
        
        class RedShape {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 200 + 50;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.01;
                this.color = reds[Math.floor(Math.random() * reds.length)];
                this.type = Math.floor(Math.random() * 4);
                this.opacity = Math.random() * 0.5 + 0.3;
                this.pulseSpeed = Math.random() * 0.02 + 0.01;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }
            
            update(time) {
                this.rotation += this.rotationSpeed;
                this.pulsePhase += this.pulseSpeed;
            }
            
            draw(time) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;
                const size = this.size * pulse;
                
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                
                switch(this.type) {
                    case 0: // Circle
                        ctx.beginPath();
                        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 1: // Triangle
                        ctx.beginPath();
                        ctx.moveTo(0, -size / 2);
                        ctx.lineTo(size / 2, size / 2);
                        ctx.lineTo(-size / 2, size / 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 2: // Square
                        ctx.fillRect(-size / 2, -size / 2, size, size);
                        break;
                    case 3: // Lines
                        ctx.beginPath();
                        for(let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            ctx.moveTo(0, 0);
                            ctx.lineTo(
                                Math.cos(angle) * size,
                                Math.sin(angle) * size
                            );
                        }
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
            }
        }
        
        let shapes = [];
        
        function init() {
            shapes = [];
            const shapeCount = Math.floor(Math.random() * 15) + 20;
            for(let i = 0; i < shapeCount; i++) {
                shapes.push(new RedShape());
            }
        }
        
        function draw() {
            ctx.fillStyle = '#0a0000';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            
            shapes.forEach(shape => {
                shape.update(time);
                shape.draw(time);
            });
        }
        
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        
        canvas.addEventListener('click', init);
        
        init();
        animate();
    </script>
</body>
</html>