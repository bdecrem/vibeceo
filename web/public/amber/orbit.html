<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ORBIT — Amber</title>
  
  <!-- Open Graph -->
  <meta property="og:title" content="ORBIT — Amber">
  <meta property="og:description" content="Touch to create gravity. Watch particles find new paths.">
  <meta property="og:image" content="https://intheamber.com/amber/orbit-og.png">
  <meta property="og:url" content="https://intheamber.com/amber/orbit.html">
  <meta property="og:type" content="website">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="ORBIT — Amber">
  <meta name="twitter:description" content="Touch to create gravity. Watch particles find new paths.">
  <meta name="twitter:image" content="https://intheamber.com/amber/orbit-og.png">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }

    body {
      background: #0a0a0a;
      overflow: hidden;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      touch-action: none;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #FFD700;
      font-size: 11px;
      letter-spacing: 0.5px;
      opacity: 0.6;
      font-family: 'Space Mono', monospace;
      pointer-events: none;
    }

    #stats {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #2D9596;
      font-size: 11px;
      letter-spacing: 0.5px;
      text-align: right;
      font-family: 'Space Mono', monospace;
      pointer-events: none;
    }

    .stat-line {
      margin-bottom: 4px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">TAP TO CREATE GRAVITY</div>
  <div id="stats">
    <div class="stat-line">PARTICLES: <span id="particle-count">0</span></div>
    <div class="stat-line">GRAVITY WELLS: <span id="well-count">0</span></div>
    <div class="stat-line">ORBITS: <span id="orbit-count">0</span></div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });

    // Audio context
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let audioUnlocked = false;

    function unlockAudio() {
      if (!audioUnlocked) {
        const osc = audioCtx.createOscillator();
        osc.connect(audioCtx.destination);
        osc.start(0);
        osc.stop(0);
        audioUnlocked = true;
      }
    }

    function playTone(freq, duration = 0.1, type = 'sine', volume = 0.1) {
      if (!audioUnlocked) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.type = type;
      osc.frequency.value = freq;
      
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + duration);
    }

    // Color palette - bold and saturated for high energy mood
    const colors = {
      amber: '#FFD700',
      gold: '#f59e0b',
      teal: '#2D9596',
      electricBlue: '#3b82f6',
      hotPink: '#ec4899',
      purple: '#8b5cf6',
      coral: '#f97316',
      lime: '#84cc16'
    };

    const colorArray = Object.values(colors);

    // Gravity wells
    class GravityWell {
      constructor(x, y, mass) {
        this.x = x;
        this.y = y;
        this.mass = mass;
        this.radius = Math.sqrt(mass) * 3;
        this.color = colorArray[Math.floor(Math.random() * colorArray.length)];
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.life = 1.0;
        this.maxLife = 300; // frames
        this.age = 0;
      }

      update() {
        this.pulsePhase += 0.05;
        this.age++;
        this.life = 1.0 - (this.age / this.maxLife);
      }

      draw() {
        const pulse = Math.sin(this.pulsePhase) * 0.3 + 1.0;
        
        // Outer glow
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * pulse * 2);
        gradient.addColorStop(0, this.color + '40');
        gradient.addColorStop(0.5, this.color + '20');
        gradient.addColorStop(1, this.color + '00');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * pulse * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Core
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life * 0.8;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }

      isDead() {
        return this.life <= 0;
      }
    }

    // Orbiting particles
    class Particle {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 3 + Math.random() * 2;
        this.color = colorArray[Math.floor(Math.random() * colorArray.length)];
        this.trail = [];
        this.maxTrailLength = 30;
        this.orbitCount = 0;
        this.lastAngle = null;
      }

      applyGravity(wells) {
        wells.forEach(well => {
          const dx = well.x - this.x;
          const dy = well.y - this.y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq);
          
          if (dist > 1) {
            const force = (well.mass * 0.5) / distSq;
            const ax = (dx / dist) * force;
            const ay = (dy / dist) * force;
            
            this.vx += ax;
            this.vy += ay;
          }
        });
      }

      update(wells) {
        // Track orbit completion (simplified: check angle change around nearest well)
        if (wells.length > 0) {
          const nearest = wells.reduce((closest, well) => {
            const dx = well.x - this.x;
            const dy = well.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < closest.dist ? {well, dist} : closest;
          }, {well: null, dist: Infinity});

          if (nearest.well) {
            const dx = this.x - nearest.well.x;
            const dy = this.y - nearest.well.y;
            const angle = Math.atan2(dy, dx);
            
            if (this.lastAngle !== null) {
              const angleDiff = angle - this.lastAngle;
              // Detect orbit completion (angle wraps around)
              if (Math.abs(angleDiff) > Math.PI) {
                this.orbitCount++;
                totalOrbits++;
                playTone(200 + (this.orbitCount % 8) * 50, 0.05, 'sine', 0.02);
              }
            }
            this.lastAngle = angle;
          }
        }

        this.applyGravity(wells);
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Velocity damping (slight friction)
        this.vx *= 0.995;
        this.vy *= 0.995;
        
        // Bounds wrapping
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
        
        // Trail
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
      }

      draw() {
        // Trail
        if (this.trail.length > 1) {
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            const alpha = i / this.trail.length;
            ctx.globalAlpha = alpha * 0.3;
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
        
        // Particle glow
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 3);
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(0.5, this.color + '40');
        gradient.addColorStop(1, this.color + '00');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Core
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // State
    let particles = [];
    let wells = [];
    let totalOrbits = 0;
    
    // Initialize with 3 gravity wells and 60 particles
    function init() {
      // Create initial wells
      wells.push(new GravityWell(width * 0.3, height * 0.5, 100));
      wells.push(new GravityWell(width * 0.7, height * 0.5, 100));
      wells.push(new GravityWell(width * 0.5, height * 0.3, 80));
      
      // Create initial particles with random velocities
      for (let i = 0; i < 60; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        particles.push(new Particle(x, y, vx, vy));
      }
    }

    // Touch/mouse interaction
    function handleInteraction(x, y) {
      unlockAudio();
      
      // Create new gravity well
      const mass = 60 + Math.random() * 40;
      wells.push(new GravityWell(x, y, mass));
      
      // Spawn 5 new particles near the touch point
      for (let i = 0; i < 5; i++) {
        const angle = (Math.PI * 2 * i) / 5;
        const dist = 50 + Math.random() * 50;
        const px = x + Math.cos(angle) * dist;
        const py = y + Math.sin(angle) * dist;
        const speed = 2 + Math.random() * 3;
        const vx = Math.cos(angle + Math.PI / 2) * speed;
        const vy = Math.sin(angle + Math.PI / 2) * speed;
        particles.push(new Particle(px, py, vx, vy));
      }
      
      playTone(400 + Math.random() * 200, 0.2, 'sine', 0.15);
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handleInteraction(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('mousedown', (e) => {
      handleInteraction(e.clientX, e.clientY);
    });

    // Animation loop
    function animate() {
      // Fade effect (not full clear)
      ctx.fillStyle = 'rgba(10, 10, 10, 0.15)';
      ctx.fillRect(0, 0, width, height);
      
      // Update and draw wells
      wells = wells.filter(well => {
        well.update();
        well.draw();
        return !well.isDead();
      });
      
      // Update and draw particles
      particles.forEach(particle => {
        particle.update(wells);
        particle.draw();
      });
      
      // Update stats
      document.getElementById('particle-count').textContent = particles.length;
      document.getElementById('well-count').textContent = wells.length;
      document.getElementById('orbit-count').textContent = totalOrbits;
      
      requestAnimationFrame(animate);
    }

    init();
    animate();
  </script>
</body>
</html>