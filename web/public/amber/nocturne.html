<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Nocturne</title>
  <meta property="og:title" content="Nocturne">
  <meta property="og:description" content="Generative Berlin techno gone existential. Each listen is different.">
  <meta property="og:image" content="https://intheamber.com/amber/nocturne-og.png">
  <meta property="og:url" content="https://kochi.to/amber/nocturne.html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://intheamber.com/amber/nocturne-og.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #050506;
      color: #444;
      font-family: 'Courier New', monospace;
      height: 100vh;
      overflow: hidden;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .ui {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      text-align: center;
    }

    h1 {
      font-size: 0.7rem;
      font-weight: normal;
      letter-spacing: 0.4em;
      text-transform: uppercase;
      margin-bottom: 1rem;
      opacity: 0.4;
    }

    #playBtn {
      background: transparent;
      border: 1px solid #222;
      color: #444;
      padding: 0.8rem 2.5rem;
      font-family: inherit;
      font-size: 0.65rem;
      cursor: pointer;
      transition: all 0.3s ease;
      letter-spacing: 0.25em;
      text-transform: uppercase;
    }

    #playBtn:hover {
      border-color: #444;
      color: #666;
    }

    .bpm-display {
      margin-top: 1rem;
      font-size: 0.6rem;
      opacity: 0.25;
      letter-spacing: 0.15em;
      min-height: 1em;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="ui">
    <h1>Nocturne</h1>
    <button id="playBtn">Enter</button>
    <p class="bpm-display" id="bpmDisplay"></p>
  </div>

  <script>
    // === VISUAL LAYER ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let kickIntensity = 0;
    let hatIntensity = 0;
    let bassIntensity = 0;
    let padIntensity = 0;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Vertical lines that pulse with kick
    let lines = [];
    for (let i = 0; i < 12; i++) {
      lines.push({
        x: Math.random(),
        speed: 0.0001 + Math.random() * 0.0002,
        width: 1 + Math.random() * 2
      });
    }

    function drawVisuals() {
      // Deep fade
      ctx.fillStyle = 'rgba(5, 5, 6, 0.06)';
      ctx.fillRect(0, 0, width, height);

      // Horizontal gradient band that shifts with bass
      const bandY = height * 0.5 + Math.sin(Date.now() * 0.0003) * height * 0.1;
      const bandHeight = 200 + bassIntensity * 100;
      const gradient = ctx.createLinearGradient(0, bandY - bandHeight/2, 0, bandY + bandHeight/2);
      gradient.addColorStop(0, 'transparent');
      gradient.addColorStop(0.5, `rgba(20, 25, 35, ${0.03 + padIntensity * 0.05})`);
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, bandY - bandHeight/2, width, bandHeight);

      // Vertical lines
      lines.forEach(line => {
        line.x += line.speed;
        if (line.x > 1.1) line.x = -0.1;

        const x = line.x * width;
        const alpha = 0.03 + kickIntensity * 0.15;
        const lineHeight = height * (0.3 + kickIntensity * 0.4);

        ctx.strokeStyle = `rgba(40, 50, 70, ${alpha})`;
        ctx.lineWidth = line.width;
        ctx.beginPath();
        ctx.moveTo(x, (height - lineHeight) / 2);
        ctx.lineTo(x, (height + lineHeight) / 2);
        ctx.stroke();
      });

      // Center point that pulses
      if (kickIntensity > 0.1) {
        const size = 2 + kickIntensity * 8;
        ctx.beginPath();
        ctx.arc(width/2, height/2, size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(60, 70, 90, ${kickIntensity * 0.5})`;
        ctx.fill();
      }

      // Hi-hat sparkles
      if (hatIntensity > 0.1) {
        for (let i = 0; i < 3; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          ctx.beginPath();
          ctx.arc(x, y, 1, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(80, 90, 110, ${hatIntensity * 0.3})`;
          ctx.fill();
        }
      }

      // Decay
      kickIntensity *= 0.9;
      hatIntensity *= 0.85;
      bassIntensity *= 0.97;
      padIntensity *= 0.98;

      requestAnimationFrame(drawVisuals);
    }
    drawVisuals();

    // === AUDIO ENGINE ===
    let audioCtx = null;
    let isPlaying = false;
    let masterGain = null;
    let compressor = null;
    let mainFilter = null;
    let reverbNode = null;
    let reverbGain = null;
    let delayNode = null;
    let delayGain = null;

    let currentTempo = 116;
    let currentKey = 0;
    let stepIndex = 0;
    let barIndex = 0;
    let patternIndex = 0;

    // Dark scale (minor pentatonic + flat 2 for tension)
    const SCALE = [0, 1, 3, 5, 7, 10]; // Minor with b2

    function noteToFreq(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }

    function getNote(degree, octave = 3) {
      const idx = ((degree % SCALE.length) + SCALE.length) % SCALE.length;
      const octaveShift = Math.floor(degree / SCALE.length);
      return (octave + octaveShift) * 12 + currentKey + SCALE[idx];
    }

    // Create reverb
    function createReverb() {
      const length = audioCtx.sampleRate * 3.5;
      const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 1.8);
        }
      }
      const conv = audioCtx.createConvolver();
      conv.buffer = impulse;
      return conv;
    }

    // === DRUMS ===

    // Techno kick - punchy with sub tail
    function playKick(time, velocity = 1) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(35, time + 0.07);

      gain.gain.setValueAtTime(0, time);
      gain.gain.linearRampToValueAtTime(0.8 * velocity, time + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.3 * velocity, time + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);

      osc.connect(gain);
      gain.connect(compressor);

      // Click transient
      const click = audioCtx.createOscillator();
      const clickGain = audioCtx.createGain();
      click.type = 'square';
      click.frequency.value = 1500;
      clickGain.gain.setValueAtTime(0.1 * velocity, time);
      clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.015);
      click.connect(clickGain);
      clickGain.connect(compressor);

      osc.start(time);
      osc.stop(time + 0.5);
      click.start(time);
      click.stop(time + 0.02);

      kickIntensity = Math.max(kickIntensity, velocity);
    }

    // Closed hi-hat
    function playHat(time, velocity = 0.3, open = false) {
      const bufferSize = audioCtx.sampleRate * (open ? 0.2 : 0.05);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 7000;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 10000;
      bp.Q.value = 1;

      const gain = audioCtx.createGain();
      const decay = open ? 0.15 : 0.04;
      gain.gain.setValueAtTime(velocity, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + decay);

      noise.connect(hp);
      hp.connect(bp);
      bp.connect(gain);
      gain.connect(masterGain);
      gain.connect(delayGain);

      noise.start(time);
      noise.stop(time + decay + 0.01);

      hatIntensity = Math.max(hatIntensity, velocity * 2);
    }

    // Rimshot / clap (sparse)
    function playRim(time, velocity = 0.2) {
      const bufferSize = audioCtx.sampleRate * 0.1;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 1800;
      bp.Q.value = 3;

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(velocity, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.08);

      noise.connect(bp);
      bp.connect(gain);
      gain.connect(masterGain);
      gain.connect(reverbGain);

      noise.start(time);
      noise.stop(time + 0.1);
    }

    // === SYNTHS ===

    // Deep bass (sub + harmonics)
    function playBass(note, time, duration, velocity = 0.4) {
      const freq = noteToFreq(note);

      // Sub
      const sub = audioCtx.createOscillator();
      const subGain = audioCtx.createGain();
      sub.type = 'sine';
      sub.frequency.value = freq;
      subGain.gain.setValueAtTime(0, time);
      subGain.gain.linearRampToValueAtTime(velocity * 0.5, time + 0.02);
      subGain.gain.setValueAtTime(velocity * 0.5, time + duration - 0.05);
      subGain.gain.linearRampToValueAtTime(0, time + duration);
      sub.connect(subGain);
      subGain.connect(compressor);

      // Saw for grit
      const saw = audioCtx.createOscillator();
      const sawFilter = audioCtx.createBiquadFilter();
      const sawGain = audioCtx.createGain();
      saw.type = 'sawtooth';
      saw.frequency.value = freq;
      sawFilter.type = 'lowpass';
      sawFilter.frequency.setValueAtTime(200, time);
      sawFilter.frequency.linearRampToValueAtTime(800, time + 0.1);
      sawFilter.frequency.linearRampToValueAtTime(150, time + duration);
      sawFilter.Q.value = 4;
      sawGain.gain.setValueAtTime(0, time);
      sawGain.gain.linearRampToValueAtTime(velocity * 0.15, time + 0.01);
      sawGain.gain.setValueAtTime(velocity * 0.15, time + duration - 0.05);
      sawGain.gain.linearRampToValueAtTime(0, time + duration);
      saw.connect(sawFilter);
      sawFilter.connect(sawGain);
      sawGain.connect(mainFilter);

      sub.start(time);
      sub.stop(time + duration + 0.1);
      saw.start(time);
      saw.stop(time + duration + 0.1);

      bassIntensity = Math.max(bassIntensity, velocity);
    }

    // Atmospheric pad
    function playPad(notes, time, duration, velocity = 0.08) {
      notes.forEach((note, i) => {
        const freq = noteToFreq(note);

        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const filter = audioCtx.createBiquadFilter();
        const gain = audioCtx.createGain();

        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq * 1.003;

        filter.type = 'lowpass';
        filter.frequency.value = 600 + Math.random() * 400;
        filter.Q.value = 1;

        const attack = 2 + Math.random();
        const release = 2;

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(velocity, time + attack);
        gain.gain.setValueAtTime(velocity, time + duration - release);
        gain.gain.linearRampToValueAtTime(0, time + duration);

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(reverbGain);
        gain.connect(mainFilter);

        osc1.start(time);
        osc1.stop(time + duration + 0.1);
        osc2.start(time);
        osc2.stop(time + duration + 0.1);
      });

      padIntensity = Math.max(padIntensity, velocity * 5);
    }

    // Stab / chord hit
    function playStab(notes, time, velocity = 0.12) {
      notes.forEach(note => {
        const freq = noteToFreq(note);
        const osc = audioCtx.createOscillator();
        const filter = audioCtx.createBiquadFilter();
        const gain = audioCtx.createGain();

        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, time);
        filter.frequency.exponentialRampToValueAtTime(200, time + 0.3);
        filter.Q.value = 5;

        gain.gain.setValueAtTime(velocity, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(mainFilter);
        gain.connect(reverbGain);

        osc.start(time);
        osc.stop(time + 0.5);
      });
    }

    // === PATTERNS ===

    // Kick patterns (16 steps)
    const kickPatterns = [
      [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0], // 4/4
      [1,0,0,0, 1,0,0,0, 1,0,0,1, 0,0,1,0], // Variation
      [1,0,0,0, 0,0,1,0, 0,0,1,0, 0,0,0,0], // Sparse
      [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,1], // Drive
      [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0], // Breakdown
    ];

    // Hi-hat patterns
    const hatPatterns = [
      [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0], // Offbeat
      [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0], // 8ths
      [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1], // 16ths
      [0,0,1,0, 0,0,1,1, 0,0,1,0, 0,0,1,0], // Syncopated
      [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,1,0], // Minimal
    ];

    // Bass patterns (root note per step, -1 = rest)
    const bassPatterns = [
      [0,-1,-1,-1, -1,-1,-1,-1, 0,-1,-1,-1, -1,-1,-1,-1],
      [0,-1,-1,-1, -1,-1,0,-1, -1,-1,-1,-1, -1,-1,-1,-1],
      [0,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, 0,-1,-1,-1],
      [0,-1,0,-1, -1,-1,-1,-1, 0,-1,-1,-1, -1,-1,0,-1],
    ];

    function generateStep(time) {
      const stepDuration = (60 / currentTempo) / 4;
      const step = stepIndex % 16;
      const bar = Math.floor(stepIndex / 16) % 8;

      // Select patterns based on phrase
      const phrase = Math.floor(barIndex / 8);
      const kickPattern = kickPatterns[phrase % kickPatterns.length];
      const hatPattern = hatPatterns[(phrase + 1) % hatPatterns.length];
      const bassPattern = bassPatterns[phrase % bassPatterns.length];

      // Kick
      if (kickPattern[step]) {
        playKick(time, 0.9 + Math.random() * 0.1);
      }

      // Hats
      if (hatPattern[step]) {
        const isOpen = step === 6 && Math.random() < 0.3;
        playHat(time, 0.15 + Math.random() * 0.1, isOpen);
      }

      // Bass
      if (bassPattern[step] >= 0) {
        const bassNote = getNote(bassPattern[step], 2);
        playBass(bassNote, time, stepDuration * 3, 0.35);
      }

      // Rim on 2 and 4 (sometimes)
      if ((step === 4 || step === 12) && Math.random() < 0.4) {
        playRim(time, 0.15);
      }

      // Pad every 8 bars
      if (step === 0 && bar === 0) {
        const padNotes = [
          getNote(0, 4),
          getNote(2, 4),
          getNote(4, 4)
        ];
        const padDuration = stepDuration * 16 * 4;
        playPad(padNotes, time, padDuration, 0.05 + Math.random() * 0.03);

        // Maybe change key
        if (barIndex > 0 && Math.random() < 0.25) {
          currentKey = (currentKey + [0, 5, 7, -2][Math.floor(Math.random() * 4)] + 12) % 12;
        }

        // Maybe change tempo slightly
        if (Math.random() < 0.2) {
          currentTempo = 108 + Math.floor(Math.random() * 16);
          document.getElementById('bpmDisplay').textContent = currentTempo + ' bpm';
        }
      }

      // Occasional stab
      if (step === 0 && bar === 4 && Math.random() < 0.5) {
        const stabNotes = [getNote(0, 4), getNote(2, 4)];
        playStab(stabNotes, time + stepDuration, 0.08);
      }

      stepIndex++;
      if (step === 15) barIndex++;

      return stepDuration;
    }

    let nextStepTime = 0;
    let schedulerInterval = null;

    function scheduler() {
      while (nextStepTime < audioCtx.currentTime + 0.2) {
        const duration = generateStep(nextStepTime);
        nextStepTime += duration;
      }
    }

    function startMusic() {
      if (isPlaying) return;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Compressor
      compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.value = -12;
      compressor.ratio.value = 6;
      compressor.attack.value = 0.003;
      compressor.release.value = 0.15;
      compressor.connect(audioCtx.destination);

      // Master
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.75;
      masterGain.connect(compressor);

      // Main filter
      mainFilter = audioCtx.createBiquadFilter();
      mainFilter.type = 'lowpass';
      mainFilter.frequency.value = 4000;
      mainFilter.connect(masterGain);

      // Reverb
      reverbNode = createReverb();
      reverbGain = audioCtx.createGain();
      reverbGain.gain.value = 0.25;
      reverbNode.connect(reverbGain);
      reverbGain.connect(masterGain);
      mainFilter.connect(reverbNode);

      // Delay
      delayNode = audioCtx.createDelay(1);
      delayNode.delayTime.value = (60 / currentTempo) * 0.75;
      delayGain = audioCtx.createGain();
      delayGain.gain.value = 0.15;
      const delayFeedback = audioCtx.createGain();
      delayFeedback.gain.value = 0.3;
      delayGain.connect(delayNode);
      delayNode.connect(delayFeedback);
      delayFeedback.connect(delayNode);
      delayNode.connect(masterGain);

      // Init
      currentKey = [0, 2, 5, 7, 10][Math.floor(Math.random() * 5)]; // Dark keys
      currentTempo = 108 + Math.floor(Math.random() * 16);
      stepIndex = 0;
      barIndex = 0;

      document.getElementById('bpmDisplay').textContent = currentTempo + ' bpm';

      nextStepTime = audioCtx.currentTime + 0.1;
      schedulerInterval = setInterval(scheduler, 50);

      isPlaying = true;
      document.getElementById('playBtn').textContent = '· · ·';
      document.getElementById('playBtn').style.opacity = '0.3';
    }

    function stopMusic() {
      if (!isPlaying) return;

      clearInterval(schedulerInterval);
      masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);

      setTimeout(() => {
        audioCtx.close();
        isPlaying = false;
        document.getElementById('playBtn').textContent = 'Enter';
        document.getElementById('playBtn').style.opacity = '1';
        document.getElementById('bpmDisplay').textContent = '';
      }, 2100);
    }

    document.getElementById('playBtn').addEventListener('click', () => {
      isPlaying ? stopMusic() : startMusic();
    });
  </script>
</body>
</html>
