<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AURORA</title>
    
    <!-- OG Tags -->
    <meta property="og:title" content="AURORA">
    <meta property="og:description" content="Shimmering waves of light dance across the northern sky. Touch to disturb the flow.">
    <meta property="og:image" content="https://intheamber.com/amber/aurora-og.png">
    <meta property="og:url" content="https://intheamber.com/amber/aurora.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="AURORA">
    <meta name="twitter:description" content="Shimmering waves of light dance across the northern sky. Touch to disturb the flow.">
    <meta name="twitter:image" content="https://intheamber.com/amber/aurora-og.png">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #000000 0%, #0a0a14 50%, #0d0d1a 100%);
            font-family: 'Space Mono', monospace;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
        }

        .title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(20px, 5vw, 32px);
            color: #FFD700;
            letter-spacing: 8px;
            z-index: 10;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            pointer-events: none;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(10px, 2vw, 14px);
            color: #2D9596;
            letter-spacing: 2px;
            z-index: 10;
            text-align: center;
            pointer-events: none;
            opacity: 0.8;
        }

        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
    </style>
</head>
<body>
    <div class="title">AURORA</div>
    <div class="instructions">TOUCH TO DISTURB THE FLOW</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth * window.devicePixelRatio;
        let height = canvas.height = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth * window.devicePixelRatio;
            height = canvas.height = window.innerHeight * window.devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        });

        // Aurora color palette
        const colors = [
            { r: 59, g: 130, b: 246 },   // electric blue
            { r: 45, g: 149, b: 150 },   // teal
            { r: 132, g: 204, b: 22 },   // lime
            { r: 236, g: 72, b: 153 },   // hot pink
            { r: 139, g: 92, b: 246 },   // purple
            { r: 249, g: 115, b: 22 }    // coral
        ];

        // Aurora ribbons
        class Ribbon {
            constructor(y, speed, colorIndex, wavelength, amplitude) {
                this.y = y;
                this.speed = speed;
                this.colorIndex = colorIndex;
                this.wavelength = wavelength;
                this.amplitude = amplitude;
                this.offset = Math.random() * 1000;
                this.disturbances = [];
            }

            update(time) {
                this.offset += this.speed;
                
                // Update disturbances
                this.disturbances = this.disturbances.filter(d => {
                    d.time += 0.016;
                    d.radius += 2;
                    return d.time < 1.5;
                });
            }

            draw(time) {
                const color = colors[this.colorIndex];
                
                ctx.beginPath();
                
                for (let x = 0; x <= width; x += 2) {
                    // Base wave
                    let wave = Math.sin((x / this.wavelength) + (this.offset / 100)) * this.amplitude;
                    
                    // Add disturbances
                    this.disturbances.forEach(d => {
                        const dist = Math.sqrt((x - d.x) ** 2 + (this.y - d.y) ** 2);
                        if (dist < d.radius) {
                            const influence = 1 - (dist / d.radius);
                            wave += Math.sin(dist * 0.1 - d.time * 5) * 30 * influence;
                        }
                    });
                    
                    const y = this.y + wave;
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                // Create gradient
                const gradient = ctx.createLinearGradient(0, this.y - this.amplitude, 0, this.y + this.amplitude);
                gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
                gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.6)`);
                gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 60;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Add glow
                ctx.shadowBlur = 40;
                ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            addDisturbance(x, y) {
                this.disturbances.push({ x, y, radius: 0, time: 0 });
            }
        }

        // Particles
        class Particle {
            constructor(x, y, colorIndex) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1;
                this.decay = 0.015;
                this.size = Math.random() * 3 + 2;
                this.color = colors[colorIndex];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // gravity
                this.life -= this.decay;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.life})`;
                ctx.fill();
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.life})`;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Create ribbons
        const ribbons = [
            new Ribbon(height * 0.2,0.8, 0, 300, 80),
            new Ribbon(height * 0.3, 1.2, 1, 250, 100),
            new Ribbon(height * 0.4, 0.6, 2, 350, 90),
            new Ribbon(height * 0.5, 1.0, 3, 280, 110),
            new Ribbon(height * 0.6, 0.9, 4, 320, 95),
            new Ribbon(height * 0.7, 1.1, 5, 270, 105),
            new Ribbon(height * 0.35, 0.7, 1, 310, 70),
            new Ribbon(height * 0.55, 1.3, 3, 290, 85)
        ];

        const particles = [];

        // Stars
        const stars = [];
        for (let i = 0; i < 150; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 2,
                twinkle: Math.random() * Math.PI * 2
            });
        }

        // Interaction
        function handleInteraction(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) * window.devicePixelRatio;
            const y = (e.clientY || e.touches[0].clientY) * window.devicePixelRatio;

            // Disturb all ribbons
            ribbons.forEach(ribbon => {
                ribbon.addDisturbance(x, y);
            });

            // Create particle burst
            const nearestRibbon = ribbons.reduce((nearest, ribbon) => {
                const dist = Math.abs(ribbon.y - y);
                return dist < nearest.dist ? { ribbon, dist } : nearest;
            }, { ribbon: ribbons[0], dist: Infinity });

            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y, nearestRibbon.ribbon.colorIndex));
            }
        }

        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);

        // Animation loop
        let time = 0;
        function animate() {
            time += 0.016;

            // Fade trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Draw stars
            stars.forEach(star => {
                star.twinkle += 0.05;
                const opacity = (Math.sin(star.twinkle) + 1) / 2 * 0.5 + 0.3;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fill();
            });

            // Update and draw ribbons
            ribbons.forEach(ribbon => {
                ribbon.update(time);
                ribbon.draw(time);
            });

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>