<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHO CHAMBER — Shout into the void. Hear your voice bounce back.</title>
    <meta name="description" content="Tap and hold to record your voice. Release to hear it echo back with wild effects. Each echo transforms your sound differently.">
    <meta property="og:title" content="ECHO CHAMBER">
    <meta property="og:description" content="Shout into the void. Hear your voice bounce back.">
    <meta property="og:image" content="https://kochi.to/amber/echo-chamber-og.png">
    <meta property="og:url" content="https://kochi.to/amber/echo-chamber.html">
    <meta name="twitter:card" content="summary_large_image">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000;
            color: #D4A574;
            font-family: 'Space Mono', monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
            touch-action: manipulation;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .content {
            position: relative;
            z-index: 1;
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        h1 {
            font-size: clamp(24px, 6vw, 36px);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: clamp(12px, 3vw, 14px);
            color: #D4A574;
            opacity: 0.6;
            margin-bottom: 40px;
        }

        #recordButton {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 3px solid #D4A574;
            background: radial-gradient(circle at center, #D4A574 0%, #000 70%);
            color: #000;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            user-select: none;
        }

        #recordButton:active {
            transform: scale(0.95);
        }

        #recordButton.recording {
            background: radial-gradient(circle at center, #FF0000 0%, #000 70%);
            border-color: #FF0000;
            color: #FFF;
            animation: pulse 1s infinite;
        }

        #recordButton.playing {
            background: radial-gradient(circle at center, #2D9596 0%, #000 70%);
            border-color: #2D9596;
            color: #FFF;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-top: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            color: #FFD700;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.6;
            margin-top: 5px;
        }

        .footer {
            position: fixed;
            bottom: 20px;
            font-size: 11px;
            opacity: 0.4;
            z-index: 1;
        }

        .effect-name {
            font-size: 14px;
            color: #2D9596;
            margin-top: 15px;
            min-height: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .effect-name.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="content">
        <h1>ECHO CHAMBER</h1>
        <p class="subtitle">shout into the void</p>
        
        <button id="recordButton">
            TAP & HOLD<br>TO RECORD
        </button>

        <div class="effect-name" id="effectName"></div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="echoCount">0</div>
                <div class="stat-label">ECHOES</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="longestEcho">0.0s</div>
                <div class="stat-label">LONGEST</div>
            </div>
        </div>
    </div>

    <div class="footer">— Amber</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const recordButton = document.getElementById('recordButton');
        const echoCountEl = document.getElementById('echoCount');
        const longestEchoEl = document.getElementById('longestEcho');
        const effectNameEl = document.getElementById('effectName');

        let width, height;
        let audioContext;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let echoCount = 0;
        let longestEcho = 0;
        let recordStartTime = 0;
        let waveforms = [];

        const effects = [
            { name: 'CAVE REVERB', delay: 0.3, feedback: 0.6, filter: 'lowpass' },
            { name: 'UNDERWATER', delay: 0.5, feedback: 0.4, filter: 'lowpass', detune: -1200 },
            { name: 'ROBOT VOICE', delay: 0.2, feedback: 0.7, filter: 'bandpass', detune: 800 },
            { name: 'GHOSTLY WHISPER', delay: 0.4, feedback: 0.8, filter: 'highpass', detune: 400 },
            { name: 'TIME WARP', delay: 0.6, feedback: 0.5, filter: 'lowpass', detune: -800 },
            { name: 'STADIUM ECHO', delay: 0.8, feedback: 0.3, filter: 'bandpass' },
            { name: 'ALIEN TRANSMISSION', delay: 0.35, feedback: 0.65, filter: 'highpass', detune: 1200 }
        ];

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        async function startRecording() {
            if (isRecording) return;
            
            initAudio();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.addEventListener('dataavailable', event => {
                    audioChunks.push(event.data);
                });
                
                mediaRecorder.addEventListener('stop', processAudio);
                
                mediaRecorder.start();
                isRecording = true;
                recordStartTime = Date.now();
                recordButton.textContent = 'RECORDING...';
                recordButton.classList.add('recording');
            } catch (err) {
                console.error('Microphone access denied:', err);
                recordButton.textContent = 'MIC ACCESS\nDENIED';
                setTimeout(() => {
                    recordButton.textContent = 'TAP & HOLD\nTO RECORD';
                }, 2000);
            }
        }

        function stopRecording() {
            if (!isRecording) return;
            
            const duration = (Date.now() - recordStartTime) / 1000;
            if (duration < 0.1) {
                // Too short, cancel
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                recordButton.textContent = 'TAP & HOLD\nTO RECORD';
                recordButton.classList.remove('recording');
                return;
            }
            
            mediaRecorder.stop();
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
            isRecording = false;
        }

        async function processAudio() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Pick random effect
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            // Show effect name
            effectNameEl.textContent = effect.name;
            effectNameEl.classList.add('show');
            setTimeout(() => effectNameEl.classList.remove('show'), 3000);
            
            // Play with effect
            playWithEffect(audioBuffer, effect);
            
            // Update stats
            echoCount++;
            echoCountEl.textContent = echoCount;
            
            const duration = audioBuffer.duration;
            if (duration > longestEcho) {
                longestEcho = duration;
                longestEchoEl.textContent = duration.toFixed(1) + 's';
            }
            
            recordButton.textContent = 'PLAYING...';
            recordButton.classList.remove('recording');
            recordButton.classList.add('playing');
        }

        function playWithEffect(audioBuffer, effect) {
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            
            // Create effect chain
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            const delay = audioContext.createDelay(2.0);
            const feedback = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            // Configure filter
            filter.type = effect.filter;
            filter.frequency.value = effect.filter === 'lowpass' ? 800 : 
                                   effect.filter === 'highpass' ? 3000 : 1500;
            
            // Configure delay
            delay.delayTime.value = effect.delay;
            feedback.gain.value = effect.feedback;
            
            // Dry signal
            dryGain.gain.value = 0.7;
            source.connect(dryGain);
            dryGain.connect(audioContext.destination);
            
            // Wet signal (delayed)
            wetGain.gain.value = 0.8;
            source.connect(delay);
            delay.connect(filter);
            filter.connect(feedback);
            feedback.connect(delay);
            delay.connect(wetGain);
            wetGain.connect(audioContext.destination);
            
            // Detune if specified
            if (effect.detune) {
                source.detune.value = effect.detune;
            }
            
            // Create waveform visualization
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            const waveform = { analyser, dataArray, x: width / 2, y: height / 2, alpha: 1 };
            waveforms.push(waveform);
            
            source.start();
            
            source.onended = () => {
                recordButton.textContent = 'TAP & HOLD\nTO RECORD';
                recordButton.classList.remove('playing');
            };
        }

        recordButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startRecording();
        });

        recordButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopRecording();
        });

        recordButton.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startRecording();
        });

        recordButton.addEventListener('mouseup', (e) => {
            e.preventDefault();
            stopRecording();
        });

        // Animation loop
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw waveforms
            waveforms.forEach((wf, index) => {
                wf.analyser.getByteFrequencyData(wf.dataArray);
                
                const barCount = 60;
                const angleStep = (Math.PI * 2) / barCount;
                const radius = 150;
                
                ctx.save();
                ctx.translate(wf.x, wf.y);
                ctx.globalAlpha = wf.alpha;
                
                for (let i = 0; i < barCount; i++) {
                    const value = wf.dataArray[Math.floor(i * wf.dataArray.length / barCount)];
                    const barHeight = (value / 255) * 100;
                    const angle = angleStep * i;
                    
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    const x2 = Math.cos(angle) * (radius + barHeight);
                    const y2 = Math.sin(angle) * (radius + barHeight);
                    
                    const gradient = ctx.createLinearGradient(x, y, x2, y2);
                    gradient.addColorStop(0, '#D4A574');
                    gradient.addColorStop(1, '#2D9596');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                wf.alpha -= 0.005;
                if (wf.alpha <= 0) {
                    waveforms.splice(index, 1);
                }
            });
            
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
