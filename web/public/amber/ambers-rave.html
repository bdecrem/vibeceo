<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AMBER'S RAVE</title>
  <link rel="icon" type="image/svg+xml" href="/amber/favicon.svg">

  <!-- OpenGraph -->
  <meta property="og:title" content="AMBER'S RAVE">
  <meta property="og:description" content="Robots, humans, pets — all losing their minds to techno. Click to spawn. They multiply.">
  <meta property="og:image" content="https://kochi.to/amber/ambers-rave-og.png">
  <meta property="og:url" content="https://kochi.to/amber/ambers-rave.html">
  <meta property="og:type" content="website">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="AMBER'S RAVE">
  <meta name="twitter:description" content="Robots, humans, pets — all losing their minds to techno. Click to spawn. They multiply.">
  <meta name="twitter:image" content="https://kochi.to/amber/ambers-rave-og.png">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0A0908;
      overflow: hidden;
      cursor: crosshair;
      font-family: 'Courier New', monospace;
    }

    canvas {
      display: block;
    }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #D4A574;
      font-size: 12px;
      opacity: 0.7;
      z-index: 100;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    #count {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #2D9596;
      font-size: 48px;
      font-weight: bold;
      z-index: 100;
      text-shadow: 0 0 20px #2D9596;
    }

    #title {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #D4A574;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      letter-spacing: 4px;
      text-shadow: 0 0 10px #B8860B;
    }

    .flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #D4A574;
      opacity: 0;
      pointer-events: none;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="title">AMBER'S RAVE</div>
  <div id="count">0</div>
  <div id="info">click to spawn /// space for chaos /// they multiply</div>
  <div class="flash" id="flash"></div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const countEl = document.getElementById('count');
    const flashEl = document.getElementById('flash');

    let width, height;
    let characters = [];
    let audioStarted = false;
    let audioCtx, gainNode;
    let beat = 0;
    let bpm = 140;
    let lastBeat = 0;
    let chaos = false;

    // Colors
    const AMBER = '#D4A574';
    const GOLD = '#B8860B';
    const TEAL = '#2D9596';
    const BLACK = '#0A0908';
    const DARK = '#1a1a18';
    const VIOLET = '#7B68EE';
    const CORAL = '#E07A5F';
    const MINT = '#81B29A';
    const SKY = '#89C2D9';

    const SKIN_TONES = ['#D4A574', '#E8C4A2', '#C68642', '#8D5524', '#F5DEB3', '#DEB887'];
    const ACCENT_COLORS = [TEAL, GOLD, VIOLET, CORAL, MINT, SKY];
    const HAIR_COLORS = ['#1a1a18', '#4A3728', '#8B4513', '#D4A574', '#B8860B', '#2D2D2D', VIOLET, TEAL, CORAL];

    // Character types - mix of robots and organic
    const TYPES = ['robot', 'robot', 'human', 'human', 'human', 'cat', 'dog', 'bunny'];

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    // Character class
    class Character {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 30 + Math.random() * 35;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.bobSpeed = 0.1 + Math.random() * 0.1;
        this.glitching = false;
        this.glitchFrames = 0;
        this.blinking = false;
        this.blinkTimer = Math.random() * 100;
        this.scale = 1;
        this.targetScale = 1;
        this.spawning = true;
        this.spawnScale = 0;
        this.lifetime = 0;
        this.mutationTimer = Math.random() * 500;

        // Determine type
        this.type = TYPES[Math.floor(Math.random() * TYPES.length)];

        if (this.type === 'robot') {
          this.skinTone = Math.random() > 0.5 ? '#888888' : '#666666';
          this.accentColor = ACCENT_COLORS[Math.floor(Math.random() * ACCENT_COLORS.length)];
          this.hasHeadphones = Math.random() > 0.3;
          this.headphoneColor = DARK;
          this.eyeType = Math.floor(Math.random() * 6);
          this.mouthType = Math.floor(Math.random() * 5);
          this.hasAntenna = Math.random() > 0.3;
          this.hasHair = false;
          this.hairColor = null;
          this.hairStyle = null;
          this.hasBow = false;
          this.hasGlasses = Math.random() > 0.8;
          this.hasHat = false;
          this.bodyColor = DARK;
          this.earType = 'none';
        } else if (this.type === 'cat' || this.type === 'dog' || this.type === 'bunny') {
          this.skinTone = Math.random() > 0.5 ? '#DEB887' : (Math.random() > 0.5 ? '#8B7355' : '#F5DEB3');
          this.accentColor = ACCENT_COLORS[Math.floor(Math.random() * ACCENT_COLORS.length)];
          this.hasHeadphones = Math.random() > 0.6;
          this.headphoneColor = DARK;
          this.eyeType = Math.random() > 0.5 ? 1 : 0;
          this.mouthType = Math.random() > 0.5 ? 3 : 0;
          this.hasAntenna = false;
          this.hasHair = false;
          this.hairColor = null;
          this.hairStyle = null;
          this.hasBow = Math.random() > 0.5;
          this.hasGlasses = false;
          this.hasHat = Math.random() > 0.85;
          this.bodyColor = this.skinTone;
          this.earType = this.type;
          this.size *= 0.75;
        } else {
          // Human
          this.skinTone = SKIN_TONES[Math.floor(Math.random() * SKIN_TONES.length)];
          this.accentColor = ACCENT_COLORS[Math.floor(Math.random() * ACCENT_COLORS.length)];
          this.hasHeadphones = Math.random() > 0.35;
          this.headphoneColor = Math.random() > 0.5 ? DARK : this.accentColor;
          this.eyeType = Math.floor(Math.random() * 6);
          this.mouthType = Math.floor(Math.random() * 5);
          this.hasAntenna = false;
          this.hasHair = Math.random() > 0.25;
          this.hairColor = HAIR_COLORS[Math.floor(Math.random() * HAIR_COLORS.length)];
          this.hairStyle = Math.floor(Math.random() * 5);
          this.hasBow = Math.random() > 0.7;
          this.hasGlasses = Math.random() > 0.75;
          this.hasHat = Math.random() > 0.85;
          this.bodyColor = Math.random() > 0.5 ? DARK : this.accentColor;
          this.earType = 'none';
        }
      }

      update(beatPulse) {
        this.lifetime++;

        // Spawn animation
        if (this.spawning) {
          this.spawnScale += 0.1;
          if (this.spawnScale >= 1) {
            this.spawnScale = 1;
            this.spawning = false;
          }
        }

        // Movement
        this.x += this.vx;
        this.y += this.vy;

        // Bounce off walls
        if (this.x < this.size) { this.x = this.size; this.vx *= -1; }
        if (this.x > width - this.size) { this.x = width - this.size; this.vx *= -1; }
        if (this.y < this.size) { this.y = this.size; this.vy *= -1; }
        if (this.y > height - this.size) { this.y = height - this.size; this.vy *= -1; }

        // Bob to the beat
        this.bobPhase += this.bobSpeed;

        // Beat pulse scale
        this.targetScale = beatPulse ? 1.2 : 1;
        this.scale += (this.targetScale - this.scale) * 0.3;

        // Rotation
        if (chaos) {
          this.rotation += this.rotationSpeed * 3;
        } else {
          this.rotation += this.rotationSpeed * 0.3;
        }

        // Blinking
        this.blinkTimer--;
        if (this.blinkTimer <= 0) {
          this.blinking = !this.blinking;
          this.blinkTimer = this.blinking ? 5 : 50 + Math.random() * 100;
        }

        // Random glitching
        if (Math.random() < (chaos ? 0.05 : 0.005)) {
          this.glitching = true;
          this.glitchFrames = 5 + Math.floor(Math.random() * 10);
        }

        if (this.glitching) {
          this.glitchFrames--;
          if (this.glitchFrames <= 0) this.glitching = false;
        }

        // Mutation
        this.mutationTimer--;
        if (this.mutationTimer <= 0) {
          this.mutate();
          this.mutationTimer = 200 + Math.random() * 500;
        }

        // Chaos mode - faster, crazier
        if (chaos) {
          this.vx *= 1.01;
          this.vy *= 1.01;
          if (Math.abs(this.vx) > 10) this.vx = Math.sign(this.vx) * 10;
          if (Math.abs(this.vy) > 10) this.vy = Math.sign(this.vy) * 10;
        } else {
          this.vx *= 0.99;
          this.vy *= 0.99;
        }
      }

      mutate() {
        if (Math.random() > 0.7) this.eyeType = Math.floor(Math.random() * 6);
        if (Math.random() > 0.7) this.mouthType = Math.floor(Math.random() * 5);
        if (Math.random() > 0.8) this.accentColor = ACCENT_COLORS[Math.floor(Math.random() * ACCENT_COLORS.length)];
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y + Math.sin(this.bobPhase) * 5);
        ctx.rotate(this.rotation);
        ctx.scale(this.scale * this.spawnScale, this.scale * this.spawnScale);

        const s = this.size;
        const glitchOffset = this.glitching ? (Math.random() - 0.5) * 10 : 0;

        // Glitch effect
        if (this.glitching) {
          ctx.globalAlpha = 0.5;
          ctx.translate(glitchOffset, glitchOffset);
          this.drawBody(s);
          ctx.translate(-glitchOffset * 2, -glitchOffset);
          this.drawBody(s);
          ctx.translate(glitchOffset, 0);
          ctx.globalAlpha = 1;
        }

        this.drawBody(s);

        ctx.restore();
      }

      drawBody(s) {
        // Ears first (behind head)
        if (this.earType === 'cat') this.drawCatEars(s);
        else if (this.earType === 'dog') this.drawDogEars(s);
        else if (this.earType === 'bunny') this.drawBunnyEars(s);

        // Head
        ctx.fillStyle = this.skinTone;
        ctx.fillRect(-s/2, -s/2, s, s * 0.8);

        // Face detail blocks
        if (this.earType === 'none') {
          ctx.fillStyle = this.type === 'robot' ? '#555555' : this.adjustBrightness(this.skinTone, -20);
          ctx.fillRect(-s/2 + 3, -s/2 + 3, s/5, s/5);
          ctx.fillRect(s/2 - 3 - s/5, -s/2 + 3, s/5, s/5);
        }

        // Hair
        if (this.hasHair && !this.hasHat) this.drawHair(s);

        // Hat
        if (this.hasHat) this.drawHat(s);

        // Headphones
        if (this.hasHeadphones) this.drawHeadphones(s);

        // Antenna
        if (this.hasAntenna) {
          ctx.strokeStyle = DARK;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, -s/2);
          ctx.lineTo(0, -s/2 - 12);
          ctx.stroke();
          ctx.fillStyle = this.accentColor;
          ctx.beginPath();
          ctx.arc(0, -s/2 - 14, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Bow
        if (this.hasBow && !this.hasHeadphones && !this.hasHat) this.drawBow(s);

        // Glasses
        if (this.hasGlasses) this.drawGlasses(s);

        // Eyes
        if (!this.blinking) {
          this.drawEyes(s);
        } else {
          ctx.strokeStyle = BLACK;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-s/4 - 4, -s/8);
          ctx.lineTo(-s/4 + 4, -s/8);
          ctx.moveTo(s/4 - 4, -s/8);
          ctx.lineTo(s/4 + 4, -s/8);
          ctx.stroke();
        }

        // Nose for pets
        if (this.earType !== 'none') {
          ctx.fillStyle = '#333';
          ctx.beginPath();
          ctx.ellipse(0, s/10, 4, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Mouth
        this.drawMouth(s);

        // Body
        ctx.fillStyle = this.bodyColor;
        ctx.fillRect(-s/3, s * 0.3, s * 0.66, s/3);

        // Body accent
        ctx.fillStyle = this.accentColor;
        ctx.beginPath();
        ctx.arc(0, s * 0.45, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      drawHeadphones(s) {
        ctx.fillStyle = this.headphoneColor;
        ctx.fillRect(-s/2 - 6, -s/4, 10, s/2);
        ctx.fillRect(s/2 - 4, -s/4, 10, s/2);

        ctx.fillStyle = this.accentColor;
        ctx.beginPath();
        ctx.arc(-s/2 - 1, 0, 5, 0, Math.PI * 2);
        ctx.arc(s/2 + 1, 0, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = this.headphoneColor;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, -s/4, s/2 + 3, Math.PI, 0);
        ctx.stroke();
      }

      drawHair(s) {
        ctx.fillStyle = this.hairColor;
        switch(this.hairStyle) {
          case 0: // Spiky
            ctx.fillRect(-s/2, -s/2 - 8, s, 12);
            for (let i = 0; i < 5; i++) {
              ctx.fillRect(-s/2 + i * s/5 + 2, -s/2 - 12, s/6, 8);
            }
            break;
          case 1: // Long
            ctx.fillRect(-s/2 - 4, -s/2 - 6, s + 8, s * 0.9);
            break;
          case 2: // Pigtails
            ctx.fillRect(-s/2, -s/2 - 6, s, 10);
            ctx.fillRect(-s/2 - 8, -s/3, 10, s/2);
            ctx.fillRect(s/2 - 2, -s/3, 10, s/2);
            break;
          case 3: // Mohawk
            ctx.fillRect(-4, -s/2 - 15, 8, 20);
            break;
          case 4: // Curly
            for (let i = 0; i < 4; i++) {
              ctx.beginPath();
              ctx.arc(-s/3 + i * s/4, -s/2 - 4, 8, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
        }
      }

      drawHat(s) {
        ctx.fillStyle = this.accentColor;
        ctx.fillRect(-s/2 - 4, -s/2 - 10, s + 8, 14);
        ctx.fillRect(-s/3, -s/2 - 20, s * 0.66, 14);
      }

      drawBow(s) {
        ctx.fillStyle = this.accentColor;
        ctx.beginPath();
        ctx.ellipse(-s/3, -s/2 + 5, 8, 5, -0.3, 0, Math.PI * 2);
        ctx.ellipse(-s/3 + 12, -s/2 + 5, 8, 5, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(-s/3 + 6, -s/2 + 5, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      drawGlasses(s) {
        ctx.strokeStyle = this.accentColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(-s/4 - 7, -s/6 - 5, 14, 10);
        ctx.strokeRect(s/4 - 7, -s/6 - 5, 14, 10);
        ctx.beginPath();
        ctx.moveTo(-s/4 + 7, -s/6);
        ctx.lineTo(s/4 - 7, -s/6);
        ctx.stroke();
      }

      drawCatEars(s) {
        ctx.fillStyle = this.skinTone;
        ctx.beginPath();
        ctx.moveTo(-s/2, -s/2);
        ctx.lineTo(-s/2 - 8, -s/2 - 15);
        ctx.lineTo(-s/4, -s/2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(s/2, -s/2);
        ctx.lineTo(s/2 + 8, -s/2 - 15);
        ctx.lineTo(s/4, -s/2);
        ctx.fill();
        ctx.fillStyle = CORAL;
        ctx.beginPath();
        ctx.moveTo(-s/2 + 2, -s/2);
        ctx.lineTo(-s/2 - 4, -s/2 - 10);
        ctx.lineTo(-s/4 - 2, -s/2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(s/2 - 2, -s/2);
        ctx.lineTo(s/2 + 4, -s/2 - 10);
        ctx.lineTo(s/4 + 2, -s/2);
        ctx.fill();
      }

      drawDogEars(s) {
        ctx.fillStyle = this.adjustBrightness(this.skinTone, -30);
        ctx.beginPath();
        ctx.ellipse(-s/2 - 5, -s/6, 8, 16, -0.3, 0, Math.PI * 2);
        ctx.ellipse(s/2 + 5, -s/6, 8, 16, 0.3, 0, Math.PI * 2);
        ctx.fill();
      }

      drawBunnyEars(s) {
        ctx.fillStyle = this.skinTone;
        ctx.beginPath();
        ctx.ellipse(-s/4, -s/2 - 20, 6, 20, -0.1, 0, Math.PI * 2);
        ctx.ellipse(s/4, -s/2 - 20, 6, 20, 0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = CORAL;
        ctx.beginPath();
        ctx.ellipse(-s/4, -s/2 - 20, 3, 14, -0.1, 0, Math.PI * 2);
        ctx.ellipse(s/4, -s/2 - 20, 3, 14, 0.1, 0, Math.PI * 2);
        ctx.fill();
      }

      drawEyes(s) {
        ctx.fillStyle = BLACK;

        switch(this.eyeType) {
          case 0: // ><
            ctx.lineWidth = 2;
            ctx.strokeStyle = BLACK;
            ctx.beginPath();
            ctx.moveTo(-s/4 - 5, -s/8 - 3);
            ctx.lineTo(-s/4, -s/8);
            ctx.lineTo(-s/4 - 5, -s/8 + 3);
            ctx.moveTo(s/4 + 5, -s/8 - 3);
            ctx.lineTo(s/4, -s/8);
            ctx.lineTo(s/4 + 5, -s/8 + 3);
            ctx.stroke();
            break;
          case 1: // O O
            ctx.beginPath();
            ctx.arc(-s/4, -s/8, 5, 0, Math.PI * 2);
            ctx.arc(s/4, -s/8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = this.accentColor;
            ctx.beginPath();
            ctx.arc(-s/4 + 1, -s/8 - 1, 2, 0, Math.PI * 2);
            ctx.arc(s/4 + 1, -s/8 - 1, 2, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 2: // - -
            ctx.fillRect(-s/4 - 5, -s/8 - 1, 10, 3);
            ctx.fillRect(s/4 - 5, -s/8 - 1, 10, 3);
            break;
          case 3: // ^ ^
            ctx.lineWidth = 2;
            ctx.strokeStyle = BLACK;
            ctx.beginPath();
            ctx.moveTo(-s/4 - 5, -s/8 + 2);
            ctx.lineTo(-s/4, -s/8 - 4);
            ctx.lineTo(-s/4 + 5, -s/8 + 2);
            ctx.moveTo(s/4 - 5, -s/8 + 2);
            ctx.lineTo(s/4, -s/8 - 4);
            ctx.lineTo(s/4 + 5, -s/8 + 2);
            ctx.stroke();
            break;
          case 4: // * *
            ctx.font = `${s/4}px monospace`;
            ctx.fillText('*', -s/4 - 4, -s/8 + 4);
            ctx.fillText('*', s/4 - 4, -s/8 + 4);
            break;
          case 5: // hearts
            ctx.fillStyle = CORAL;
            ctx.font = `${s/4}px serif`;
            ctx.fillText('♥', -s/4 - 5, -s/8 + 4);
            ctx.fillText('♥', s/4 - 5, -s/8 + 4);
            break;
        }
      }

      drawMouth(s) {
        ctx.fillStyle = BLACK;
        ctx.strokeStyle = BLACK;
        ctx.lineWidth = 2;

        switch(this.mouthType) {
          case 0: // smile
            ctx.beginPath();
            ctx.arc(0, s/7, 6, 0, Math.PI);
            ctx.stroke();
            break;
          case 1: // o
            ctx.beginPath();
            ctx.arc(0, s/7, 4, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 2: // teeth
            ctx.fillRect(-8, s/7 - 2, 16, 6);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-6, s/7 - 1, 4, 4);
            ctx.fillRect(2, s/7 - 1, 4, 4);
            break;
          case 3: // w
            ctx.beginPath();
            ctx.moveTo(-6, s/7);
            ctx.lineTo(-3, s/7 + 4);
            ctx.lineTo(0, s/7);
            ctx.lineTo(3, s/7 + 4);
            ctx.lineTo(6, s/7);
            ctx.stroke();
            break;
          case 4: // :3
            ctx.beginPath();
            ctx.arc(-4, s/7, 4, 0, Math.PI);
            ctx.arc(4, s/7, 4, 0, Math.PI);
            ctx.stroke();
            break;
        }
      }

      adjustBrightness(hex, amount) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.min(255, Math.max(0, (num >> 16) + amount));
        const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
        const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
        return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`;
      }

      shouldReproduce() {
        return this.lifetime > 300 && Math.random() < 0.001 * (chaos ? 5 : 1);
      }
    }

    // Audio
    function initAudio() {
      if (audioStarted) return;
      audioStarted = true;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0.3;
      gainNode.connect(audioCtx.destination);

      scheduleBeat();
    }

    function scheduleBeat() {
      const beatInterval = 60000 / bpm;

      setInterval(() => {
        beat++;
        lastBeat = Date.now();

        if (beat % 4 === 0 || beat % 4 === 2) playKick();
        playHihat();
        if (beat % 4 === 0) playBass();
        if (chaos && Math.random() > 0.5) playGlitch();
        if (beat % 4 === 0) flash();

      }, beatInterval);
    }

    function playKick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.connect(gain);
      gain.connect(gainNode);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    }

    function playHihat() {
      const bufferSize = audioCtx.sampleRate * 0.05;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
      }
      const source = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 7000;
      source.buffer = buffer;
      gain.gain.value = 0.15;
      source.connect(filter);
      filter.connect(gain);
      gain.connect(gainNode);
      source.start();
    }

    function playBass() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const notes = [55, 55, 73.42, 55];
      const note = notes[Math.floor(beat / 4) % notes.length];
      osc.type = 'sawtooth';
      osc.frequency.value = note;
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(gainNode);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }

    function playGlitch() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = 200 + Math.random() * 2000;
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
      osc.connect(gain);
      gain.connect(gainNode);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.05);
    }

    function flash() {
      flashEl.style.opacity = '0.1';
      setTimeout(() => { flashEl.style.opacity = '0'; }, 50);
    }

    function spawnCharacter(x, y) {
      if (characters.length < 100) {
        characters.push(new Character(x || Math.random() * width, y || Math.random() * height));
        updateCount();
      }
    }

    function updateCount() {
      countEl.textContent = characters.length;
    }

    // Initial characters
    for (let i = 0; i < 8; i++) {
      spawnCharacter();
    }

    // Click to spawn
    canvas.addEventListener('click', (e) => {
      initAudio();
      spawnCharacter(e.clientX, e.clientY);

      if (chaos) {
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            spawnCharacter(
              e.clientX + (Math.random() - 0.5) * 100,
              e.clientY + (Math.random() - 0.5) * 100
            );
          }, i * 100);
        }
      }
    });

    // Space for chaos
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        chaos = !chaos;
        document.body.style.background = chaos ? '#1a0a08' : '#0A0908';
        if (chaos) bpm = 160;
        else bpm = 140;
      }
    });

    // Animation loop
    function animate() {
      ctx.fillStyle = 'rgba(10, 9, 8, 0.2)';
      ctx.fillRect(0, 0, width, height);

      const timeSinceBeat = Date.now() - lastBeat;
      const beatPulse = timeSinceBeat < 100;

      characters.forEach(char => {
        char.update(beatPulse);
        char.draw();

        if (char.shouldReproduce()) {
          spawnCharacter(
            char.x + (Math.random() - 0.5) * 50,
            char.y + (Math.random() - 0.5) * 50
          );
        }
      });

      // Scanlines
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      for (let y = 0; y < height; y += 4) {
        ctx.fillRect(0, y, width, 2);
      }

      requestAnimationFrame(animate);
    }

    animate();

    // Auto-spawn
    setInterval(() => {
      if (characters.length < 20 && Math.random() > 0.7) {
        spawnCharacter();
      }
    }, 3000);
  </script>
</body>
</html>
