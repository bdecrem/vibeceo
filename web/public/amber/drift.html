<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DRIFT — Sine waves morph through particle space</title>
  <meta property="og:title" content="DRIFT — Sine waves morph through particle space">
  <meta property="og:description" content="A music machine by Amber">
  <meta property="og:image" content="https://intheamber.com/amber/drift-og.png">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="DRIFT — Sine waves morph through particle space">
  <meta name="twitter:description" content="A music machine by Amber">
  <meta name="twitter:image" content="https://intheamber.com/amber/drift-og.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      width: 100vw;
      height: 100vh;
      background: #000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-family: 'Space Mono', monospace;
      color: #D4A574;
      touch-action: none;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.95);
z-index: 10;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.5s;
    }

    #overlay.hidden {
      opacity: 0;
    }

    #startBtn {
      background: #D4A574;
      color: #000;
      border: none;
      padding: 20px 50px;
      font-size: 24px;
      font-family: 'Space Mono', monospace;
      font-weight: bold;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
      margin-bottom: 20px;
      pointer-events: all;
    }

    #startBtn:hover {
      background: #FFD700;
      transform: scale(1.05);
    }

    #instruction {
      font-size: 14px;
      color: #D4A574;
      opacity: 0.7;
      text-align: center;
      max-width: 500px;
      line-height: 1.8;
      padding: 0 20px;
    }

    #stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 11px;
      color: #D4A574;
      opacity: 0.5;
      font-family: 'Space Mono', monospace;
      line-height: 1.8;
    }

    @media (max-width: 768px) {
      #startBtn {
        padding: 16px 40px;
        font-size: 20px;
      }
      #instruction {
        font-size: 13px;
      }
      #stats {
        font-size: 10px;
        bottom: 12px;
        left: 12px;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="overlay">
    <button id="startBtn">START</button>
    <div id="instruction">
      Five drones drift through harmonic space<br>
      Each particle pulls frequencies toward itself<br>
      Tap to add gravity wells<br>
      Let it evolve
    </div>
  </div>

  <div id="stats">
    DRONES: <span id="droneCount">5</span><br>
    WELLS: <span id="wellCount">8</span><br>
    DRIFT: <span id="driftSpeed">slow</span>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const droneCountStat = document.getElementById('droneCount');
    const wellCountStat = document.getElementById('wellCount');
    const driftSpeedStat = document.getElementById('driftSpeed');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // Audio setup
    let audioCtx = null;
    let audioStarted = false;

    // D minor pentatonic frequencies (Hz) - across 3 octaves for variation
    const scaleFreqs = [
      146.83, // D3
      164.81, // E3
      174.61, // F3
      220.00, // A3
      246.94, // B3
      293.66, // D4
      329.63, // E4
      349.23, // F4
      440.00, // A4
      493.88, // B4
      587.33, // D5
      659.25, // E5
    ];

    // Drones - continuous sine wave oscillators
    const drones = [];
    const DRONE_COUNT = 5;

    class Drone {
      constructor(index) {
        this.index = index;
        this.targetFreq = scaleFreqs[index % scaleFreqs.length];
        this.currentFreq = this.targetFreq;
        this.color = ['#D4A574', '#FFD700', '#2D9596', '#7B68EE', '#FF69B4'][index % 5];
        
        // Web Audio nodes
        this.osc = null;
        this.gain = null;
        this.filter = null;
        
        // Visual position (follows target frequency)
        this.x = width * (0.2 + (index / DRONE_COUNT) * 0.6);
        this.y = height / 2;
        this.size = 15;
        this.phase = Math.random() * Math.PI * 2; // For breathing animation
      }

      init(audioContext) {
        this.osc = audioContext.createOscillator();
        this.gain = audioContext.createGain();
        this.filter = audioContext.createBiquadFilter();
        
        this.osc.type = 'sine';
        this.osc.frequency.value = this.currentFreq;
        
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 800;
        this.filter.Q.value = 1;
        
        this.gain.gain.value = 0.08; // Quiet, ambient volume
        
        this.osc.connect(this.filter);
        this.filter.connect(this.gain);
        this.gain.connect(audioContext.destination);
        
        this.osc.start();
      }

      update(wells) {
        if (!this.osc) return;

        // Calculate target frequency based on gravity wells
        let totalPull = 0;
        let weightedFreq = 0;

        wells.forEach(well => {
          const dx = well.x - this.x;
          const dy = well.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const pull = well.mass / (dist + 50); // Prevent division by zero
          
          totalPull += pull;
          weightedFreq += well.freq * pull;
        });

        if (totalPull > 0) {
          this.targetFreq = weightedFreq / totalPull;
        }

        // Smoothly interpolate toward target frequency (slow drift)
        this.currentFreq += (this.targetFreq - this.currentFreq) * 0.005;
        
        // Apply frequency to oscillator
        this.osc.frequency.setTargetAtTime(this.currentFreq, audioCtx.currentTime, 0.1);

        // Update visual position based on frequency (map freq to Y position)
        const freqIndex = scaleFreqs.indexOf(scaleFreqs.reduce((prev, curr) => 
          Math.abs(curr - this.currentFreq) < Math.abs(prev - this.currentFreq) ? curr : prev
        ));
        
        const targetY = height * 0.2 + (freqIndex / scaleFreqs.length) * height * 0.6;
        this.y += (targetY - this.y) * 0.01;

        // Update breathing phase
        this.phase += 0.02;
      }

      draw() {
        const breathe = Math.sin(this.phase) * 0.2 + 1.0; // 0.8 to 1.2
        const size = this.size * breathe;

        // Outer glow
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 3);
        gradient.addColorStop(0, this.color + 'AA');
        gradient.addColorStop(0.4, this.color + '44');
        gradient.addColorStop(1, this.color + '00');
        ctx.fillStyle = gradient;
        ctx.fillRect(this.x - size * 3, this.y - size * 3, size * 6, size * 6);

        // Core
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
        ctx.fill();

        // Frequency ring
        ctx.strokeStyle = this.color + '80';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, size * 1.8, 0, Math.PI * 2);
        ctx.stroke();
      }

      destroy() {
        if (this.osc) this.osc.stop();
        if (this.gain) this.gain.disconnect();
        if (this.filter) this.filter.disconnect();
      }
    }

    // Gravity wells - attract drone frequencies
    const wells = [];

    class Well {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.mass = 150 + Math.random() * 200;
        this.freq = scaleFreqs[Math.floor(Math.random() * scaleFreqs.length)];
        this.life = 1.0;
        this.decay = 0.001; // Very slow fade
        this.color = '#FFD700';
        this.pulse = 0;
      }

      update() {
        this.life -= this.decay;
        this.pulse += 0.05;
      }

      draw() {
        const pulse = Math.sin(this.pulse) * 0.3 + 0.7;
        const alpha = Math.floor(this.life * 120).toString(16).padStart(2, '0');
        
        // Radial rings
        for (let i = 3; i > 0; i--) {
          ctx.strokeStyle = this.color + Math.floor(alpha * (i / 3) * 0.5).toString(16).padStart(2, '0');
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, (this.mass / 10) * pulse * i * 0.5, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Core
        ctx.fillStyle = this.color + alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Initialize audio
    async function startAudio() {
      if (audioStarted) return;

      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // iOS unlock
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }

        // Create drones
        for (let i = 0; i < DRONE_COUNT; i++) {
          const drone = new Drone(i);
          drone.init(audioCtx);
          drones.push(drone);
        }

        // Spawn initial gravity wells
        for (let i = 0; i < 8; i++) {
          wells.push(new Well(
            width * (0.2 + Math.random() * 0.6),
            height * (0.2 + Math.random() * 0.6)
          ));
        }

        audioStarted = true;
        overlay.classList.add('hidden');
        
      } catch (err) {
        console.error('Audio init error:', err);
        alert('Audio failed: ' + err.message);
      }
    }

    // Handle interaction - add new gravity well
    function handleInteraction(e) {
      if (!audioStarted) return;
      
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
      
      wells.push(new Well(x, y));
    }

    startBtn.addEventListener('click', startAudio);
    startBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      startAudio();
    });

    canvas.addEventListener('click', handleInteraction);
    canvas.addEventListener('touchstart', handleInteraction);

    // Animation loop
    function animate() {
      // Dark fade trail
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      ctx.fillRect(0, 0, width, height);

      if (audioStarted) {
        // Update wells
        for (let i = wells.length - 1; i >= 0; i--) {
          wells[i].update();
          wells[i].draw();
          
          if (wells[i].life <= 0) {
            wells.splice(i, 1);
          }
        }

        // Draw connection lines from drones to nearby wells
        drones.forEach(drone => {
          wells.forEach(well => {
            const dx = well.x - drone.x;
            const dy = well.y - drone.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 200) {
              const alpha = Math.floor((1 - dist / 200) * well.life * 40).toString(16).padStart(2, '0');
              ctx.strokeStyle = '#2D9596' + alpha;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(drone.x, drone.y);
              ctx.lineTo(well.x, well.y);
              ctx.stroke();
            }
          });
        });

        // Update and draw drones
        drones.forEach(drone => {
          drone.update(wells);
          drone.draw();
        });

        // Update stats
        wellCountStat.textContent = wells.length;
      } else {
        // Preview animation - pulsing circles
        const previewTime = Date.now() * 0.001;
        for (let i = 0; i < 5; i++) {
          const x = width * (0.2 + (i / 5) * 0.6);
          const y = height / 2;
          const pulse = Math.sin(previewTime * 2 + i * 0.5) * 0.3 + 0.7;
          const colors = ['#D4A574', '#FFD700', '#2D9596', '#7B68EE', '#FF69B4'];
          
          ctx.fillStyle = colors[i] + '40';
          ctx.beginPath();
          ctx.arc(x, y, 15 * pulse, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      requestAnimationFrame(animate);
    }

    animate();

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      drones.forEach(d => d.destroy());
      if (audioCtx) audioCtx.close();
    });
  </script>
</body>
</html>
