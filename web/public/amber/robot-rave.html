<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROBOT RAVE</title>
  <link rel="icon" type="image/svg+xml" href="/amber/favicon.svg">

  <!-- OpenGraph -->
  <meta property="og:title" content="ROBOT RAVE">
  <meta property="og:description" content="Unhinged pixel robots losing their minds to techno. Click to spawn more. They multiply.">
  <meta property="og:image" content="https://kochi.to/amber/robot-rave-og.png">
  <meta property="og:url" content="https://kochi.to/amber/robot-rave.html">
  <meta property="og:type" content="website">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="ROBOT RAVE">
  <meta name="twitter:description" content="Unhinged pixel robots losing their minds to techno. Click to spawn more. They multiply.">
  <meta name="twitter:image" content="https://kochi.to/amber/robot-rave-og.png">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0A0908;
      overflow: hidden;
      cursor: crosshair;
      font-family: 'Courier New', monospace;
    }

    canvas {
      display: block;
    }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #D4A574;
      font-size: 12px;
      opacity: 0.7;
      z-index: 100;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    #count {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #2D9596;
      font-size: 48px;
      font-weight: bold;
      z-index: 100;
      text-shadow: 0 0 20px #2D9596;
    }

    #title {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #D4A574;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      letter-spacing: 4px;
      text-shadow: 0 0 10px #B8860B;
    }

    .flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #D4A574;
      opacity: 0;
      pointer-events: none;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="title">ROBOT RAVE</div>
  <div id="count">0</div>
  <div id="info">click to spawn /// space for chaos /// they multiply</div>
  <div class="flash" id="flash"></div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const countEl = document.getElementById('count');
    const flashEl = document.getElementById('flash');

    let width, height;
    let robots = [];
    let audioStarted = false;
    let audioCtx, kickOsc, hihatOsc, bassOsc, gainNode;
    let beat = 0;
    let bpm = 140;
    let lastBeat = 0;
    let chaos = false;

    // Colors
    const AMBER = '#D4A574';
    const GOLD = '#B8860B';
    const TEAL = '#2D9596';
    const BLACK = '#0A0908';
    const DARK = '#1a1a18';

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    // Robot class
    class Robot {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 40 + Math.random() * 40;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.bobSpeed = 0.1 + Math.random() * 0.1;
        this.glitching = false;
        this.glitchFrames = 0;
        this.eyeType = Math.floor(Math.random() * 5);
        this.mouthType = Math.floor(Math.random() * 4);
        this.hasHeadphones = Math.random() > 0.3;
        this.hasAntenna = Math.random() > 0.6;
        this.accentColor = Math.random() > 0.5 ? TEAL : GOLD;
        this.blinking = false;
        this.blinkTimer = Math.random() * 100;
        this.scale = 1;
        this.targetScale = 1;
        this.spawning = true;
        this.spawnScale = 0;
        this.lifetime = 0;
        this.mutationTimer = Math.random() * 500;
      }

      update(beatPulse) {
        this.lifetime++;

        // Spawn animation
        if (this.spawning) {
          this.spawnScale += 0.1;
          if (this.spawnScale >= 1) {
            this.spawnScale = 1;
            this.spawning = false;
          }
        }

        // Movement
        this.x += this.vx;
        this.y += this.vy;

        // Bounce off walls
        if (this.x < this.size) { this.x = this.size; this.vx *= -1; }
        if (this.x > width - this.size) { this.x = width - this.size; this.vx *= -1; }
        if (this.y < this.size) { this.y = this.size; this.vy *= -1; }
        if (this.y > height - this.size) { this.y = height - this.size; this.vy *= -1; }

        // Bob to the beat
        this.bobPhase += this.bobSpeed;

        // Beat pulse scale
        this.targetScale = beatPulse ? 1.2 : 1;
        this.scale += (this.targetScale - this.scale) * 0.3;

        // Rotation
        if (chaos) {
          this.rotation += this.rotationSpeed * 3;
        } else {
          this.rotation += this.rotationSpeed * 0.3;
        }

        // Blinking
        this.blinkTimer--;
        if (this.blinkTimer <= 0) {
          this.blinking = !this.blinking;
          this.blinkTimer = this.blinking ? 5 : 50 + Math.random() * 100;
        }

        // Random glitching
        if (Math.random() < (chaos ? 0.05 : 0.005)) {
          this.glitching = true;
          this.glitchFrames = 5 + Math.floor(Math.random() * 10);
        }

        if (this.glitching) {
          this.glitchFrames--;
          if (this.glitchFrames <= 0) this.glitching = false;
        }

        // Mutation
        this.mutationTimer--;
        if (this.mutationTimer <= 0) {
          this.mutate();
          this.mutationTimer = 200 + Math.random() * 500;
        }

        // Chaos mode - faster, crazier
        if (chaos) {
          this.vx *= 1.01;
          this.vy *= 1.01;
          if (Math.abs(this.vx) > 10) this.vx = Math.sign(this.vx) * 10;
          if (Math.abs(this.vy) > 10) this.vy = Math.sign(this.vy) * 10;
        } else {
          this.vx *= 0.99;
          this.vy *= 0.99;
        }
      }

      mutate() {
        if (Math.random() > 0.7) this.eyeType = Math.floor(Math.random() * 5);
        if (Math.random() > 0.7) this.mouthType = Math.floor(Math.random() * 4);
        if (Math.random() > 0.8) this.accentColor = Math.random() > 0.5 ? TEAL : GOLD;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y + Math.sin(this.bobPhase) * 5);
        ctx.rotate(this.rotation);
        ctx.scale(this.scale * this.spawnScale, this.scale * this.spawnScale);

        const s = this.size;
        const glitchOffset = this.glitching ? (Math.random() - 0.5) * 10 : 0;

        // Glitch effect - draw offset copies
        if (this.glitching) {
          ctx.globalAlpha = 0.5;
          ctx.translate(glitchOffset, glitchOffset);
          this.drawBody(s);
          ctx.translate(-glitchOffset * 2, -glitchOffset);
          this.drawBody(s);
          ctx.translate(glitchOffset, 0);
          ctx.globalAlpha = 1;
        }

        this.drawBody(s);

        ctx.restore();
      }

      drawBody(s) {
        // Head - blocky rectangle
        ctx.fillStyle = AMBER;
        ctx.fillRect(-s/2, -s/2, s, s * 0.8);

        // Face detail blocks
        ctx.fillStyle = GOLD;
        ctx.fillRect(-s/2 + 4, -s/2 + 4, s/4, s/4);
        ctx.fillRect(s/2 - 4 - s/4, -s/2 + 4, s/4, s/4);

        // Eyes
        if (!this.blinking) {
          this.drawEyes(s);
        } else {
          // Closed eyes - lines
          ctx.strokeStyle = BLACK;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(-s/4 - 5, -s/8);
          ctx.lineTo(-s/4 + 5, -s/8);
          ctx.moveTo(s/4 - 5, -s/8);
          ctx.lineTo(s/4 + 5, -s/8);
          ctx.stroke();
        }

        // Mouth
        this.drawMouth(s);

        // Headphones
        if (this.hasHeadphones) {
          ctx.fillStyle = DARK;
          ctx.fillRect(-s/2 - 8, -s/4, 12, s/2);
          ctx.fillRect(s/2 - 4, -s/4, 12, s/2);

          // Headphone accents
          ctx.fillStyle = this.accentColor;
          ctx.beginPath();
          ctx.arc(-s/2 - 2, 0, 6, 0, Math.PI * 2);
          ctx.arc(s/2 + 2, 0, 6, 0, Math.PI * 2);
          ctx.fill();

          // Headband
          ctx.strokeStyle = DARK;
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.arc(0, -s/4, s/2 + 4, Math.PI, 0);
          ctx.stroke();
        }

        // Antenna
        if (this.hasAntenna) {
          ctx.strokeStyle = DARK;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, -s/2);
          ctx.lineTo(0, -s/2 - 15);
          ctx.stroke();

          ctx.fillStyle = this.accentColor;
          ctx.beginPath();
          ctx.arc(0, -s/2 - 18, 5, 0, Math.PI * 2);
          ctx.fill();
        }

        // Body
        ctx.fillStyle = DARK;
        ctx.fillRect(-s/3, s * 0.3, s * 0.66, s/3);

        // Body accent
        ctx.fillStyle = this.accentColor;
        ctx.beginPath();
        ctx.arc(0, s * 0.45, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      drawEyes(s) {
        ctx.fillStyle = BLACK;

        switch(this.eyeType) {
          case 0: // >< happy
            ctx.lineWidth = 3;
            ctx.strokeStyle = BLACK;
            ctx.beginPath();
            ctx.moveTo(-s/4 - 6, -s/8 - 4);
            ctx.lineTo(-s/4, -s/8);
            ctx.lineTo(-s/4 - 6, -s/8 + 4);
            ctx.moveTo(s/4 + 6, -s/8 - 4);
            ctx.lineTo(s/4, -s/8);
            ctx.lineTo(s/4 + 6, -s/8 + 4);
            ctx.stroke();
            break;

          case 1: // O O wide
            ctx.beginPath();
            ctx.arc(-s/4, -s/8, 7, 0, Math.PI * 2);
            ctx.arc(s/4, -s/8, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = this.accentColor;
            ctx.beginPath();
            ctx.arc(-s/4 + 2, -s/8 - 2, 2, 0, Math.PI * 2);
            ctx.arc(s/4 + 2, -s/8 - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 2: // - - chill
            ctx.fillRect(-s/4 - 6, -s/8 - 2, 12, 4);
            ctx.fillRect(s/4 - 6, -s/8 - 2, 12, 4);
            break;

          case 3: // ^ ^ excited
            ctx.lineWidth = 3;
            ctx.strokeStyle = BLACK;
            ctx.beginPath();
            ctx.moveTo(-s/4 - 6, -s/8 + 3);
            ctx.lineTo(-s/4, -s/8 - 5);
            ctx.lineTo(-s/4 + 6, -s/8 + 3);
            ctx.moveTo(s/4 - 6, -s/8 + 3);
            ctx.lineTo(s/4, -s/8 - 5);
            ctx.lineTo(s/4 + 6, -s/8 + 3);
            ctx.stroke();
            break;

          case 4: // @ @ glitched
            ctx.font = `${s/4}px monospace`;
            ctx.fillText('@', -s/4 - 6, -s/8 + 5);
            ctx.fillText('@', s/4 - 6, -s/8 + 5);
            break;
        }
      }

      drawMouth(s) {
        ctx.fillStyle = BLACK;
        ctx.strokeStyle = BLACK;
        ctx.lineWidth = 2;

        switch(this.mouthType) {
          case 0: // smile
            ctx.beginPath();
            ctx.arc(0, s/6, 8, 0, Math.PI);
            ctx.stroke();
            break;

          case 1: // o
            ctx.beginPath();
            ctx.arc(0, s/6, 5, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 2: // === teeth
            ctx.fillRect(-10, s/6 - 3, 20, 8);
            ctx.fillStyle = AMBER;
            ctx.fillRect(-8, s/6 - 1, 4, 4);
            ctx.fillRect(-2, s/6 - 1, 4, 4);
            ctx.fillRect(4, s/6 - 1, 4, 4);
            break;

          case 3: // w
            ctx.beginPath();
            ctx.moveTo(-8, s/6);
            ctx.lineTo(-4, s/6 + 5);
            ctx.lineTo(0, s/6);
            ctx.lineTo(4, s/6 + 5);
            ctx.lineTo(8, s/6);
            ctx.stroke();
            break;
        }
      }

      // Check if this robot should spawn a child
      shouldReproduce() {
        return this.lifetime > 300 && Math.random() < 0.001 * (chaos ? 5 : 1);
      }
    }

    // Audio setup
    function initAudio() {
      if (audioStarted) return;
      audioStarted = true;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0.3;
      gainNode.connect(audioCtx.destination);

      // Start the beat loop
      scheduleBeat();
    }

    function scheduleBeat() {
      const beatInterval = 60000 / bpm;

      setInterval(() => {
        beat++;
        lastBeat = Date.now();

        // Kick on 1 and 3
        if (beat % 4 === 0 || beat % 4 === 2) {
          playKick();
        }

        // Hihat on every beat
        playHihat();

        // Bass on 1
        if (beat % 4 === 0) {
          playBass();
        }

        // Extra percussion in chaos mode
        if (chaos && Math.random() > 0.5) {
          playGlitch();
        }

        // Flash on 1
        if (beat % 4 === 0) {
          flash();
        }

      }, beatInterval);
    }

    function playKick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.1);

      gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);

      osc.connect(gain);
      gain.connect(gainNode);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    }

    function playHihat() {
      const bufferSize = audioCtx.sampleRate * 0.05;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
      }

      const source = audioCtx.createBufferSource();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      filter.type = 'highpass';
      filter.frequency.value = 7000;

      source.buffer = buffer;
      gain.gain.value = 0.15;

      source.connect(filter);
      filter.connect(gain);
      gain.connect(gainNode);

      source.start();
    }

    function playBass() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      const notes = [55, 55, 73.42, 55]; // A1, A1, D2, A1
      const note = notes[Math.floor(beat / 4) % notes.length];

      osc.type = 'sawtooth';
      osc.frequency.value = note;

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(gainNode);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }

    function playGlitch() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'square';
      osc.frequency.value = 200 + Math.random() * 2000;

      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);

      osc.connect(gain);
      gain.connect(gainNode);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.05);
    }

    function flash() {
      flashEl.style.opacity = '0.1';
      setTimeout(() => { flashEl.style.opacity = '0'; }, 50);
    }

    // Spawn robot
    function spawnRobot(x, y) {
      if (robots.length < 100) {
        robots.push(new Robot(x || Math.random() * width, y || Math.random() * height));
        updateCount();
      }
    }

    function updateCount() {
      countEl.textContent = robots.length;
    }

    // Initial robots
    for (let i = 0; i < 5; i++) {
      spawnRobot();
    }

    // Click to spawn
    canvas.addEventListener('click', (e) => {
      initAudio();
      spawnRobot(e.clientX, e.clientY);

      // Spawn extra in chaos mode
      if (chaos) {
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            spawnRobot(
              e.clientX + (Math.random() - 0.5) * 100,
              e.clientY + (Math.random() - 0.5) * 100
            );
          }, i * 100);
        }
      }
    });

    // Space for chaos
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        chaos = !chaos;
        document.body.style.background = chaos ? '#1a0a08' : '#0A0908';
        if (chaos) bpm = 160;
        else bpm = 140;
      }
    });

    // Animation loop
    function animate() {
      // Semi-transparent clear for trails
      ctx.fillStyle = 'rgba(10, 9, 8, 0.2)';
      ctx.fillRect(0, 0, width, height);

      // Beat pulse detection
      const timeSinceBeat = Date.now() - lastBeat;
      const beatPulse = timeSinceBeat < 100;

      // Update and draw robots
      robots.forEach(robot => {
        robot.update(beatPulse);
        robot.draw();

        // Reproduction
        if (robot.shouldReproduce()) {
          spawnRobot(
            robot.x + (Math.random() - 0.5) * 50,
            robot.y + (Math.random() - 0.5) * 50
          );
        }
      });

      // Scanlines
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      for (let y = 0; y < height; y += 4) {
        ctx.fillRect(0, y, width, 2);
      }

      requestAnimationFrame(animate);
    }

    animate();

    // Auto-spawn occasionally
    setInterval(() => {
      if (robots.length < 20 && Math.random() > 0.7) {
        spawnRobot();
      }
    }, 3000);
  </script>
</body>
</html>
