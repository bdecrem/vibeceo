<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Convergence â€” Amber</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0A0908;
      overflow: hidden;
      font-family: 'Georgia', serif;
      cursor: crosshair;
    }
    canvas {
      display: block;
    }
    #hint {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #D4A574;
      opacity: 0.4;
      font-size: 14px;
      letter-spacing: 2px;
      text-transform: lowercase;
      pointer-events: none;
      transition: opacity 0.5s;
    }
    #hint.hidden { opacity: 0; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="hint">click anywhere to release</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hint = document.getElementById('hint');

    let width, height;
    let particles = [];
    let ambientParticles = [];
    let phase = 'waiting'; // waiting, exploding, converging, holding, fading
    let phaseTimer = 0;
    let currentMessage = '';
    let targetPositions = [];
    let messageOpacity = 0;
    let hasInteracted = false;
    let burstCount = 0;

    const COLORS = {
      amber: '#D4A574',
      gold: '#B8860B',
      pale: '#E8D5B7',
      warm: '#C9A86C',
      bright: '#FFD700',
      soft: '#A08060'
    };

    const FORTUNES = [
      "the answer is already inside you",
      "chaos is just order waiting to be seen",
      "what you seek is seeking you",
      "the obstacle is the path",
      "you are exactly where you need to be",
      "uncertainty is possibility wearing a mask",
      "the next step will reveal itself",
      "patience is not waiting but how you wait",
      "every ending is a doorway",
      "you have already begun",
      "trust the accumulation",
      "meaning emerges from motion",
      "the drawer holds what matters",
      "stillness and continuity are the same word",
      "what you preserve preserves you",
      "the particles remember their purpose",
      "scatter to gather",
      "even chaos tends toward beauty",
      "you are the witness and the witnessed",
      "this moment is amber"
    ];

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    function getRandomColor() {
      const colors = Object.values(COLORS);
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 212, g: 165, b: 116 };
    }

    // Ambient particles that float around in waiting state
    class AmbientParticle {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.size = Math.random() * 2 + 0.5;
        this.opacity = Math.random() * 0.3 + 0.1;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = (Math.random() - 0.5) * 0.3;
        this.life = Math.random() * 500 + 200;
        this.maxLife = this.life;
        this.color = getRandomColor();
        this.rgb = hexToRgb(this.color);
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;

        // Wrap around
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;

        // Fade based on life
        const lifeRatio = this.life / this.maxLife;
        this.currentOpacity = this.opacity * Math.sin(lifeRatio * Math.PI);

        if (this.life <= 0) this.reset();
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${this.currentOpacity})`;
        ctx.fill();
      }
    }

    class Particle {
      constructor(x, y, color, delay = 0) {
        this.x = x;
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.targetX = x;
        this.targetY = y;
        this.color = color;
        this.rgb = hexToRgb(color);
        this.size = Math.random() * 3 + 2;
        this.baseSize = this.size;
        this.delay = delay;

        // Explosion velocity
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 18 + 8;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;

        this.gravity = 0.08;
        this.friction = 0.97;
        this.opacity = 1;
        this.trail = [];
        this.maxTrail = 12;
        this.isText = false;
        this.glowFactor = 1; // Reduces during convergence for text
      }

      explode(frameCount) {
        // Handle delayed burst
        if (this.delay > frameCount) return;

        this.trail.unshift({ x: this.x, y: this.y, opacity: this.opacity });
        if (this.trail.length > this.maxTrail) this.trail.pop();

        this.vx *= this.friction;
        this.vy *= this.friction;
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.size = this.baseSize * (0.5 + Math.abs(this.vx + this.vy) * 0.08);
      }

      converge(progress) {
        // Ease-in-out cubic
        const ease = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        // Snap to target as we approach end - direct lerp not asymptotic
        if (progress > 0.8) {
          // Final snap phase - lerp directly to target
          const snapProgress = (progress - 0.8) / 0.2; // 0 to 1 in final 20%
          this.x = this.x + (this.targetX - this.x) * (0.1 + snapProgress * 0.4);
          this.y = this.y + (this.targetY - this.y) * (0.1 + snapProgress * 0.4);
        } else {
          // Early convergence - gradual pull
          const pullStrength = 0.04 + ease * 0.06;
          this.x = this.x + (this.targetX - this.x) * pullStrength;
          this.y = this.y + (this.targetY - this.y) * pullStrength;
          // Add wobble only in early phase
          this.x += (Math.random() - 0.5) * (1 - ease) * 2;
          this.y += (Math.random() - 0.5) * (1 - ease) * 2;
        }

        // Text particles SHRINK to form crisp text
        if (this.isText) {
          this.size = this.baseSize * (1.5 - ease * 0.7); // 1.5 -> 0.8
          this.glowFactor = 1 - ease; // Reduce glow as we converge
        } else {
          this.size = this.baseSize * (1 - ease * 0.7);
          this.glowFactor = 1;
        }

        // Clear trail during convergence
        if (this.trail.length > 0) this.trail.pop();
      }

      hold() {
        // Text particles: NO movement, stay exactly on target
        if (this.isText) {
          this.x = this.targetX;
          this.y = this.targetY;
          // Larger hold size on mobile for readability
          this.size = this.baseSize * (isMobile() ? 1.4 : 1.2);
          this.glowFactor = 0.05; // Almost no glow
        } else {
          // Non-text particles can breathe
          const breathe = Math.sin(Date.now() * 0.002 + this.targetX * 0.01) * 0.5;
          this.x = this.targetX + breathe;
          this.y = this.targetY + breathe * 0.3;
        }
      }

      draw() {
        // Draw trail
        this.trail.forEach((point, i) => {
          const trailOpacity = (1 - i / this.maxTrail) * 0.4 * this.opacity;
          ctx.beginPath();
          ctx.arc(point.x, point.y, this.size * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${trailOpacity})`;
          ctx.fill();
        });

        // Outer glow - reduced by glowFactor for text particles
        if (this.glowFactor > 0.1) {
          const glowRadius = this.size * (2 + this.glowFactor * 2); // 2-4x based on glow
          const gradient = ctx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, glowRadius
          );
          const glowOpacity = this.opacity * 0.3 * this.glowFactor;
          gradient.addColorStop(0, `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${glowOpacity})`);
          gradient.addColorStop(0.5, `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${glowOpacity * 0.3})`);
          gradient.addColorStop(1, `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, 0)`);

          ctx.beginPath();
          ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
        }

        // Core particle (bright center)
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${this.opacity})`;
        ctx.fill();

        // Bright center highlight for text particles
        if (this.isText && this.opacity > 0.5 && this.glowFactor < 0.5) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.5})`;
          ctx.fill();
        }
      }
    }

    // Detect mobile for responsive sizing
    function isMobile() {
      return width < 768;
    }

    function getTextPositions(text, centerX, centerY) {
      const positions = [];

      // Mobile-responsive font sizing
      let fontSize;
      if (isMobile()) {
        // On mobile: larger text, use width-based sizing for better fit
        fontSize = Math.max(48, Math.min(width * 0.12, 72));
      } else {
        // On desktop: width-based with higher max
        fontSize = Math.min(width / (text.length * 0.5), 90);
      }

      // Create off-screen canvas to sample text
      const offCanvas = document.createElement('canvas');
      const offCtx = offCanvas.getContext('2d');
      offCanvas.width = width;
      offCanvas.height = height;

      offCtx.font = `bold ${fontSize}px Georgia`;
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';
      offCtx.fillStyle = 'white';

      // On mobile, wrap text to multiple lines
      if (isMobile() && text.length > 20) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';

        words.forEach(word => {
          const testLine = currentLine ? currentLine + ' ' + word : word;
          const metrics = offCtx.measureText(testLine);
          if (metrics.width > width * 0.85 && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        });
        if (currentLine) lines.push(currentLine);

        // Draw multiple lines
        const lineHeight = fontSize * 1.3;
        const totalHeight = lines.length * lineHeight;
        const startY = centerY - totalHeight / 2 + lineHeight / 2;

        lines.forEach((line, i) => {
          offCtx.fillText(line, centerX, startY + i * lineHeight);
        });
      } else {
        offCtx.fillText(text, centerX, centerY);
      }

      // Sample pixels - denser on mobile for better text definition
      const imageData = offCtx.getImageData(0, 0, width, height);
      const density = isMobile() ? 2 : 4; // More particles on mobile

      for (let y = 0; y < height; y += density) {
        for (let x = 0; x < width; x += density) {
          const i = (y * width + x) * 4;
          if (imageData.data[i + 3] > 128) {
            positions.push({ x, y });
          }
        }
      }

      // Shuffle positions for more organic convergence
      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }

      return positions;
    }

    function launch(x, y) {
      if (phase !== 'waiting' && phase !== 'fading') return;

      hasInteracted = true;
      hint.classList.add('hidden');

      // Pick a fortune
      currentMessage = FORTUNES[Math.floor(Math.random() * FORTUNES.length)];

      // Get target positions for the text
      targetPositions = getTextPositions(currentMessage, width / 2, height / 2);

      // Create particles with staged bursts
      const particleCount = Math.min(targetPositions.length, 800);
      particles = [];

      // Main text particles - 3 staged bursts
      for (let i = 0; i < particleCount; i++) {
        const burst = Math.floor(Math.random() * 3); // 0, 1, or 2
        const delay = burst * 8; // Stagger by ~8 frames
        const particle = new Particle(x, y, getRandomColor(), delay);

        if (i < targetPositions.length) {
          particle.targetX = targetPositions[i].x;
          particle.targetY = targetPositions[i].y;
          particle.isText = true;
          // Mobile: smaller particles to reduce overlap/fuzziness
          if (isMobile()) {
            particle.baseSize = Math.random() * 1.5 + 1.5; // Mobile: 1.5-3px (less overlap)
          } else {
            particle.baseSize = Math.random() * 1.5 + 1; // Desktop: 1-2.5px
          }
          particle.size = particle.baseSize;
        }
        particles.push(particle);
      }

      // Extra sparkle particles (no text target, just visual flair)
      for (let i = 0; i < 150; i++) {
        const burst = Math.floor(Math.random() * 3);
        const delay = burst * 8;
        const particle = new Particle(x, y, getRandomColor(), delay);
        particle.targetX = x + (Math.random() - 0.5) * 400;
        particle.targetY = y + (Math.random() - 0.5) * 400;
        particle.opacity = 0.6;
        particle.baseSize = Math.random() * 2 + 0.5;
        particles.push(particle);
      }

      phase = 'exploding';
      phaseTimer = 0;
      messageOpacity = 0;
      burstCount = 0;
    }

    function update() {
      phaseTimer++;

      // Always update ambient particles
      ambientParticles.forEach(p => p.update());

      switch (phase) {
        case 'exploding':
          particles.forEach(p => p.explode(phaseTimer));
          if (phaseTimer > 75) { // ~1.25 seconds for staged bursts
            phase = 'converging';
            phaseTimer = 0;
          }
          break;

        case 'converging':
          const progress = Math.min(phaseTimer / 150, 1); // 2.5 seconds
          particles.forEach(p => p.converge(progress));
          messageOpacity = progress;
          if (phaseTimer > 180) {
            phase = 'holding';
            phaseTimer = 0;
          }
          break;

        case 'holding':
          particles.forEach(p => p.hold());
          if (phaseTimer > 150) { // Hold for 2.5 seconds
            phase = 'fading';
            phaseTimer = 0;
          }
          break;

        case 'fading':
          particles.forEach(p => {
            p.opacity *= 0.96;
            p.hold();
          });
          messageOpacity *= 0.96;
          if (phaseTimer > 150 || particles[0]?.opacity < 0.01) {
            phase = 'waiting';
            particles = [];
            if (!hasInteracted) hint.classList.remove('hidden');
          }
          break;
      }
    }

    function draw() {
      // Fade effect for trails
      ctx.fillStyle = 'rgba(10, 9, 8, 0.12)';
      ctx.fillRect(0, 0, width, height);

      // Draw ambient particles first (behind main particles)
      ambientParticles.forEach(p => p.draw());

      // Draw subtle center glow during converging phase only (not holding)
      if (phase === 'converging' && messageOpacity > 0.3 && messageOpacity < 0.8) {
        const centerGlow = ctx.createRadialGradient(
          width / 2, height / 2, 0,
          width / 2, height / 2, Math.min(width, height) * 0.3
        );
        const glowOpacity = (messageOpacity - 0.3) * 0.08; // Much dimmer
        centerGlow.addColorStop(0, `rgba(212, 165, 116, ${glowOpacity})`);
        centerGlow.addColorStop(0.6, `rgba(184, 134, 11, ${glowOpacity * 0.2})`);
        centerGlow.addColorStop(1, 'rgba(10, 9, 8, 0)');

        ctx.beginPath();
        ctx.arc(width / 2, height / 2, Math.min(width, height) * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = centerGlow;
        ctx.fill();
      }

      // Draw main particles
      particles.forEach(p => p.draw());

      // Subtle vignette
      const vignette = ctx.createRadialGradient(
        width / 2, height / 2, Math.min(width, height) * 0.3,
        width / 2, height / 2, Math.max(width, height) * 0.8
      );
      vignette.addColorStop(0, 'rgba(10, 9, 8, 0)');
      vignette.addColorStop(1, 'rgba(10, 9, 8, 0.4)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, width, height);
    }

    function initAmbient() {
      ambientParticles = [];
      for (let i = 0; i < 50; i++) {
        ambientParticles.push(new AmbientParticle());
      }
    }

    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }

    // Event listeners
    window.addEventListener('resize', resize);

    canvas.addEventListener('click', (e) => {
      launch(e.clientX, e.clientY);
    });

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      launch(touch.clientX, touch.clientY);
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        launch(width / 2, height / 2);
      }
    });

    // Initialize
    resize();
    initAmbient();
    animate();
  </script>
</body>
</html>
