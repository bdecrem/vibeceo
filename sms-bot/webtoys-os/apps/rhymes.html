<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="window:rhymes" content="width=900,height=650,resizable=true">
    <title>RHYMES - Poetry & Rhyme Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Comic Sans MS', 'Georgia', serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            min-height: 44px;
        }

        .title {
            font-size: 18px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .title .icon {
            font-size: 20px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .toolbar {
            display: flex;
            gap: 5px;
        }

        .btn {
            background: white;
            color: #764ba2;
            border: none;
            padding: 6px 10px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-family: inherit;
            font-size: 12px;
            min-height: 32px;
        }

        .btn:hover, .btn:active {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .main-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            overflow: hidden;
        }

        .document-title {
            padding: 10px;
            background: rgba(240, 147, 251, 0.2);
            border-bottom: 2px solid rgba(240, 147, 251, 0.3);
        }

        .document-title input {
            width: 100%;
            font-size: 16px;
            font-weight: bold;
            border: none;
            background: transparent;
            color: #764ba2;
            outline: none;
            font-family: inherit;
        }

        #editor {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            line-height: 1.6;
            border: none;
            outline: none;
            resize: none;
            font-family: 'Georgia', serif;
            color: #333;
            background: transparent;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .rhyme-panel {
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            height: 180px;
            border-top: 3px solid rgba(250, 112, 154, 0.3);
        }

        .rhyme-header {
            padding: 8px 10px;
            background: linear-gradient(90deg, #fa709a 0%, #fee140 100%);
            color: white;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .current-word {
            font-size: 12px;
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .ai-toggle {
            background: rgba(255, 255, 255, 0.3);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .ai-toggle.active {
            background: rgba(255, 255, 255, 0.5);
        }

        .rhyme-content {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 10px;
        }

        .suggestion-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .chip {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            white-space: nowrap;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chip:active {
            transform: scale(0.95);
        }

        .chip.ai-suggestion {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .loading-dots {
            display: inline-block;
            font-size: 20px;
            letter-spacing: 2px;
            animation: loading 1.4s infinite;
        }

        @keyframes loading {
            0%, 60%, 100% { opacity: 0.2; }
            20% { opacity: 1; }
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #666;
            min-height: 30px;
        }

        .word-count {
            font-weight: bold;
            color: #764ba2;
        }

        .save-status {
            color: #4CAF50;
            font-style: italic;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            width: 100%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-header {
            font-size: 18px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 15px;
        }

        .file-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-item {
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-item:active {
            transform: scale(0.98);
        }

        .file-date {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 4px;
        }

        .close-modal {
            margin-top: 15px;
            width: 100%;
        }

        /* Desktop styles */
        @media (min-width: 768px) {
            .header {
                padding: 10px 20px;
            }

            .title {
                font-size: 24px;
                gap: 10px;
            }

            .title .icon {
                font-size: 30px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 14px;
            }

            .toolbar {
                gap: 10px;
            }

            .main-container {
                flex-direction: row;
            }

            .editor-panel {
                flex: 1;
                margin: 20px;
                margin-right: 10px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            }

            .document-title {
                padding: 15px;
            }

            .document-title input {
                font-size: 18px;
            }

            #editor {
                padding: 20px;
                font-size: 16px;
                line-height: 1.8;
            }

            .rhyme-panel {
                width: 300px;
                height: auto;
                margin: 20px;
                margin-left: 10px;
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                border-top: none;
            }

            .rhyme-header {
                border-radius: 15px 15px 0 0;
                padding: 12px 15px;
                font-size: 16px;
            }

            .current-word {
                font-size: 14px;
            }

            .rhyme-content {
                padding: 15px;
            }

            .chip {
                padding: 8px 14px;
                font-size: 14px;
            }

            .status-bar {
                padding: 8px 20px;
                font-size: 12px;
            }

            .modal-content {
                padding: 30px;
            }

            .modal-header {
                font-size: 20px;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">
            <span class="icon">✨</span>
            <span>RHYMES</span>
        </div>
        <div class="toolbar">
            <button class="btn" onclick="newDocument()">📝</button>
            <button class="btn" onclick="openDocument()">📂</button>
            <button class="btn" onclick="saveDocument()">💾</button>
        </div>
    </div>

    <div class="main-container">
        <div class="editor-panel">
            <div class="document-title">
                <input type="text" id="docTitle" placeholder="Untitled Poem..." value="Untitled Poem">
            </div>
            <textarea id="editor" placeholder="Start writing your poetry here..."></textarea>
        </div>

        <div class="rhyme-panel">
            <div class="rhyme-header">
                <span class="current-word" id="currentWord">Type to see magic...</span>
                <button class="ai-toggle" id="aiToggle" onclick="toggleAI()">AI: ON</button>
            </div>
            <div class="rhyme-content">
                <div class="suggestion-chips" id="suggestions">
                    <div style="color: #999; font-size: 14px;">Start typing to see rhymes & suggestions!</div>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="word-count">
            <span id="wordCount">0</span> words
        </div>
        <div class="save-status" id="saveStatus">Ready</div>
    </div>

    <!-- File browser modal -->
    <div class="modal" id="fileModal">
        <div class="modal-content">
            <div class="modal-header">📚 Your Saved Poems</div>
            <div class="file-list" id="fileList"></div>
            <button class="btn close-modal" onclick="closeModal()">Cancel</button>
        </div>
    </div>

    <script>
        // App configuration
        window.APP_ID = 'rhymes-editor';
        let currentUser = null;
        let currentDocId = null;
        let lastSaved = '';
        let autoSaveTimer = null;
        let aiEnabled = true;
        let lastWord = '';
        let aiSuggestionTimer = null;

        // Common rhyme patterns database (simplified for mobile)
        const rhymePatterns = {
            'at': ['cat', 'hat', 'bat', 'mat', 'rat', 'sat', 'that'],
            'ay': ['day', 'way', 'say', 'may', 'play', 'stay', 'gray'],
            'ight': ['night', 'light', 'right', 'might', 'bright', 'flight'],
            'ake': ['make', 'take', 'wake', 'bake', 'shake', 'cake'],
            'all': ['ball', 'call', 'fall', 'wall', 'tall', 'small'],
            'ame': ['name', 'same', 'game', 'came', 'flame', 'frame'],
            'ate': ['gate', 'late', 'rate', 'date', 'great', 'state'],
            'eat': ['beat', 'seat', 'heat', 'neat', 'treat', 'wheat'],
            'ell': ['bell', 'tell', 'sell', 'well', 'fell', 'spell'],
            'ice': ['nice', 'price', 'twice', 'rice', 'dice', 'slice'],
            'ide': ['ride', 'side', 'wide', 'hide', 'slide', 'pride'],
            'ine': ['line', 'mine', 'fine', 'wine', 'shine', 'pine'],
            'ing': ['ring', 'sing', 'king', 'thing', 'bring', 'wing'],
            'old': ['cold', 'gold', 'hold', 'told', 'bold', 'sold'],
            'ore': ['more', 'store', 'before', 'core', 'score', 'shore'],
            'ow': ['now', 'how', 'cow', 'bow', 'wow', 'vow']
        };

        // Helper functions for participant ID
        function getParticipantId() {
            return currentUser?.handle || 'anonymous';
        }

        function getUsername() {
            return currentUser?.handle || 'anonymous';
        }

        function getAppId() {
            return window.APP_ID;
        }

        // ZAD helper functions
        async function save(dataType, data) {
            try {
                const response = await fetch('/api/zad/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        app_id: getAppId(),
                        participant_id: getParticipantId(),
                        participant_data: { userLabel: getUsername(), username: getUsername() },
                        action_type: dataType,
                        content_data: data
                    })
                });
                return response.ok;
            } catch (error) {
                console.error('Save error:', error);
                return false;
            }
        }

        async function load(dataType) {
            try {
                const response = await fetch(`/api/zad/load?app_id=${getAppId()}&action_type=${dataType}`);
                const data = await response.json();
                return data || [];
            } catch (error) {
                console.error('Load error:', error);
                return [];
            }
        }

        async function generateText(prompt, options = {}) {
            try {
                const response = await fetch('/api/zad/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        app_id: getAppId(),
                        participant_id: getParticipantId(),
                        participant_data: { userLabel: getUsername(), username: getUsername() },
                        action_type: 'generate_text',
                        content_data: { 
                            prompt: prompt,
                            maxTokens: options.maxTokens || 100,
                            temperature: options.temperature || 0.9,
                            systemPrompt: options.systemPrompt || 'You are a creative poetry assistant helping with rhymes and word suggestions.'
                        }
                    })
                });
                
                if (!response.ok) {
                    console.error('Generate text failed:', response.status);
                    return '';
                }
                
                const result = await response.json();
                console.log('Generate text result:', result);
                
                // The response comes back in result.data
                if (result.data && typeof result.data === 'string') {
                    return result.data;
                } else if (result.data && result.data.generated_text) {
                    return result.data.generated_text;
                } else if (typeof result === 'string') {
                    return result;
                }
                
                return '';
            } catch (error) {
                console.error('Generate text error:', error);
                return '';
            }
        }

        // Listen for authentication
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'TOYBOX_AUTH') {
                currentUser = event.data.user;
                updateUI();
            }
        });

        // Request authentication on load
        if (window.parent !== window) {
            window.parent.postMessage({ type: 'GET_AUTH' }, '*');
        }

        function updateUI() {
            const username = getUsername();
            document.getElementById('saveStatus').textContent = username === 'anonymous' ? 'Not logged in' : `@${username}`;
        }

        // Toggle AI
        function toggleAI() {
            aiEnabled = !aiEnabled;
            const toggle = document.getElementById('aiToggle');
            toggle.textContent = aiEnabled ? 'AI: ON' : 'AI: OFF';
            toggle.classList.toggle('active', aiEnabled);
            
            if (lastWord && aiEnabled) {
                updateSuggestions(lastWord);
            }
        }

        // Find local rhymes
        function findLocalRhymes(word) {
            if (!word) return [];
            word = word.toLowerCase().trim();
            
            // Find matching rhyme pattern
            for (const [pattern, rhymes] of Object.entries(rhymePatterns)) {
                if (word.endsWith(pattern.slice(1))) {
                    return rhymes.filter(r => r !== word).slice(0, 5);
                }
                if (rhymes.includes(word)) {
                    return rhymes.filter(r => r !== word).slice(0, 5);
                }
            }
            
            // Fallback: find words with same ending
            const ending = word.slice(-2);
            const possibleRhymes = [];
            for (const rhymes of Object.values(rhymePatterns)) {
                possibleRhymes.push(...rhymes.filter(r => r.endsWith(ending) && r !== word));
            }
            return [...new Set(possibleRhymes)].slice(0, 5);
        }

        // Update suggestions
        async function updateSuggestions(word) {
            const suggestionsEl = document.getElementById('suggestions');
            const currentWordEl = document.getElementById('currentWord');
            
            if (!word || word.length < 2) {
                currentWordEl.textContent = 'Type to see magic...';
                suggestionsEl.innerHTML = '<div style="color: #999; font-size: 14px;">Start typing to see rhymes & suggestions!</div>';
                return;
            }
            
            currentWordEl.textContent = word;
            
            // Show local rhymes immediately
            const localRhymes = findLocalRhymes(word);
            let html = '';
            
            if (localRhymes.length > 0) {
                html = localRhymes.map(rhyme => 
                    `<div class="chip" onclick="insertWord('${rhyme}')">${rhyme}</div>`
                ).join('');
            }
            
            // Add loading indicator for AI suggestions
            if (aiEnabled) {
                html += '<div class="chip ai-suggestion"><span class="loading-dots">...</span></div>';
            }
            
            suggestionsEl.innerHTML = html;
            
            // Get AI suggestions if enabled
            if (aiEnabled) {
                clearTimeout(aiSuggestionTimer);
                aiSuggestionTimer = setTimeout(async () => {
                    const aiSuggestions = await generateText(
                        `Give me 3-5 creative words that rhyme with "${word}" for poetry. Return ONLY comma-separated words, no explanations.`,
                        {
                            maxTokens: 50,
                            temperature: 0.9,
                            systemPrompt: 'You are a rhyming assistant. Return ONLY comma-separated rhyming words, nothing else.'
                        }
                    );
                    
                    if (aiSuggestions) {
                        const aiWords = aiSuggestions.split(',')
                            .map(w => w.trim())
                            .filter(w => w && w.length > 0 && !localRhymes.includes(w))
                            .slice(0, 3);
                        
                        if (aiWords.length > 0) {
                            // Remove loading indicator and add AI suggestions
                            let updatedHtml = localRhymes.map(rhyme => 
                                `<div class="chip" onclick="insertWord('${rhyme}')">${rhyme}</div>`
                            ).join('');
                            
                            updatedHtml += aiWords.map(aiWord => 
                                `<div class="chip ai-suggestion" onclick="insertWord('${aiWord}')">${aiWord} ✨</div>`
                            ).join('');
                            
                            suggestionsEl.innerHTML = updatedHtml;
                        } else {
                            // Remove loading indicator if no AI suggestions
                            suggestionsEl.innerHTML = localRhymes.map(rhyme => 
                                `<div class="chip" onclick="insertWord('${rhyme}')">${rhyme}</div>`
                            ).join('');
                        }
                    }
                }, 800); // Wait a bit before calling AI
            }
        }

        // Insert word at cursor
        function insertWord(word) {
            const editor = document.getElementById('editor');
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const text = editor.value;
            
            // Add space before if needed
            const prefix = start > 0 && text[start-1] !== ' ' && text[start-1] !== '\n' ? ' ' : '';
            const insertText = prefix + word;
            
            editor.value = text.substring(0, start) + insertText + text.substring(end);
            editor.selectionStart = editor.selectionEnd = start + insertText.length;
            editor.focus();
            updateWordCount();
        }

        // Handle editor input
        document.getElementById('editor').addEventListener('input', function(e) {
            updateWordCount();
            
            // Get current word at cursor
            const editor = e.target;
            const cursorPos = editor.selectionStart;
            const text = editor.value;
            
            // Find word at cursor
            let start = cursorPos;
            while (start > 0 && text[start - 1] !== ' ' && text[start - 1] !== '\n') {
                start--;
            }
            
            let end = cursorPos;
            while (end < text.length && text[end] !== ' ' && text[end] !== '\n') {
                end++;
            }
            
            const word = text.substring(start, end).trim();
            if (word && word !== lastWord) {
                lastWord = word;
                updateSuggestions(word);
            } else if (!word) {
                lastWord = '';
                updateSuggestions('');
            }
            
            // Auto-save
            clearTimeout(autoSaveTimer);
            if (currentDocId) {
                autoSaveTimer = setTimeout(() => {
                    saveDocument(true);
                }, 3000);
            }
        });

        // Update word count
        function updateWordCount() {
            const text = document.getElementById('editor').value;
            const words = text.trim().split(/\s+/).filter(w => w.length > 0);
            document.getElementById('wordCount').textContent = words.length || 0;
        }

        // New document
        function newDocument() {
            if (document.getElementById('editor').value && !confirm('Create new? Unsaved changes will be lost.')) {
                return;
            }
            
            currentDocId = null;
            document.getElementById('docTitle').value = 'Untitled Poem';
            document.getElementById('editor').value = '';
            updateWordCount();
            updateSuggestions('');
            document.getElementById('saveStatus').textContent = 'New';
        }

        // Save document
        async function saveDocument(isAutoSave = false) {
            const title = document.getElementById('docTitle').value || 'Untitled Poem';
            const content = document.getElementById('editor').value;
            
            if (!content.trim()) {
                if (!isAutoSave) alert('Nothing to save!');
                return;
            }
            
            const docData = {
                id: currentDocId || Date.now().toString(),
                title: title,
                content: content,
                author: getUsername(),
                updatedAt: new Date().toISOString()
            };
            
            currentDocId = docData.id;
            const success = await save('poem_document', docData);
            
            if (success) {
                lastSaved = content;
                const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                document.getElementById('saveStatus').textContent = isAutoSave ? `Auto ${time}` : `Saved ${time}`;
            } else {
                document.getElementById('saveStatus').textContent = 'Failed';
            }
        }

        // Open document
        async function openDocument() {
            const modal = document.getElementById('fileModal');
            const fileList = document.getElementById('fileList');
            
            fileList.innerHTML = '<div style="text-align: center; color: #999;">Loading...</div>';
            modal.classList.add('active');
            
            const allDocs = await load('poem_document');
            const userDocs = allDocs.filter(doc => 
                doc.author === getUsername()
            );
            
            if (userDocs.length === 0) {
                fileList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No saved poems yet!</div>';
            } else {
                // Sort by date and deduplicate by ID (take most recent)
                const uniqueDocs = {};
                userDocs.forEach(doc => {
                    if (!uniqueDocs[doc.id] || new Date(doc.updatedAt) > new Date(uniqueDocs[doc.id].updatedAt)) {
                        uniqueDocs[doc.id] = doc;
                    }
                });
                
                fileList.innerHTML = Object.values(uniqueDocs)
                    .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
                    .map(doc => `
                        <div class="file-item" onclick="loadDocument('${doc.id}')">
                            <div>${doc.title}</div>
                            <div class="file-date">${new Date(doc.updatedAt).toLocaleDateString()}</div>
                        </div>
                    `).join('');
            }
        }

        // Load document
        async function loadDocument(docId) {
            const allDocs = await load('poem_document');
            // Get most recent version of this document
            const docVersions = allDocs.filter(d => d.id === docId);
            const doc = docVersions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))[0];
            
            if (doc) {
                currentDocId = doc.id;
                document.getElementById('docTitle').value = doc.title;
                document.getElementById('editor').value = doc.content;
                updateWordCount();
                lastSaved = doc.content;
                document.getElementById('saveStatus').textContent = 'Loaded';
                closeModal();
            }
        }

        // Close modal
        function closeModal() {
            document.getElementById('fileModal').classList.remove('active');
        }

        // Initialize
        updateWordCount();
        updateUI();
        
        // Focus editor on desktop
        if (window.innerWidth >= 768) {
            document.getElementById('editor').focus();
        }
    </script>
</body>
</html>