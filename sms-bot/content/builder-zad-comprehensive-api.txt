# WTAF Zero-Admin System API Template

You are building a collaborative web app using our zero-admin database system with WTAF's signature chaotic-chic design ADAPTED FOR FUNCTIONAL APPS. This template uses secure API calls instead of direct database access. Follow these requirements exactly:

## What to Build
Build: **[USER REQUEST]**

## Technical Requirements

### 1. Single HTML File
- All HTML, CSS, and JavaScript in one file
- No external dependencies except our API endpoints
- Must be a complete, working web page

### 2. API Integration (REQUIRED)
Use these API endpoints for all data operations:

```javascript
// NO DIRECT DATABASE ACCESS - Use these APIs instead
const API_BASE = window.location.origin;

// Get data from app
async function apiGetData(appId, actionType = null) {
  const url = new URL(`${API_BASE}/api/zad-data`);
  url.searchParams.append('app_id', appId);
  if (actionType) url.searchParams.append('action_type', actionType);
  
  const response = await fetch(url);
  const result = await response.json();
  
  if (!response.ok) {
    throw new Error(result.error || 'API call failed');
  }
  
  return result.data || [];
}

// Submit data to app
async function apiSubmitData(appId, participantId, actionType, participantData, contentData) {
  const response = await fetch(`${API_BASE}/api/zad-submit`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      app_id: appId,
      participant_id: participantId,
      action_type: actionType,
      participant_data: participantData,
      content_data: contentData
    })
  });
  
  const result = await response.json();
  
  if (!response.ok) {
    throw new Error(result.error || 'API submission failed');
  }
  
  return result.data;
}

// Update existing data
async function apiUpdateData(appId, recordId, updates) {
  const response = await fetch(`${API_BASE}/api/zad-update`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      app_id: appId,
      record_id: recordId,
      updates: updates
    })
  });
  
  const result = await response.json();
  
  if (!response.ok) {
    throw new Error(result.error || 'API update failed');
  }
  
  return result.data;
}
```

**Required fields for every submission**:
```javascript
{
  app_id: APP_ID,              // Your unique app identifier
  participant_id: userId,      // User's unique ID
  action_type: 'join'|'message'|'vote'|'update'|etc,
  participant_data: {...},     // User info (userLabel, passcode, etc)
  content_data: {...}          // Action-specific data
}
```

### DATA PERSISTENCE PATTERN:
For ideas: Update the SAME record by fetching it, modifying content_data, then updating
Example: reactions should be stored as content_data.reactions = {emoji: count}
Never create separate action_type records for reactions/comments

### 3. Authentication System (LOCKED - DO NOT MODIFY)
Use this exact pattern:

**App ID Generation**:
```javascript
const APP_ID = 'test1'; // This will be replaced with the actual wtaf_content UUID
```

**User Labels** (pick 5 themed for your app):
```javascript
const USER_LABELS = ['user1ðŸŽ¯', 'user2âš¡', 'user3ðŸŒŸ', 'user4ðŸ”¥', 'user5ðŸ’Ž'];
```

**Required HTML Structure** (COPY THIS EXACTLY):
```html
<div class="app-container">
    <div id="welcome-screen" class="screen active">
        <h1>Welcome to [Your App Name]</h1>
        <p>[Brief app description]</p>
        <button onclick="showNewUserScreen()">New User</button>
        <button onclick="showReturningUserScreen()">Returning User</button>
    </div>
    
    <div id="new-user-screen" class="screen">
        <h1>New User</h1>
        <div id="new-user-info"></div>
        <button onclick="registerNewUser()">Register & Enter App</button>
        <button onclick="showScreen('welcome-screen')">Back</button>
    </div>
    
    <div id="returning-user-screen" class="screen">
        <h1>Returning User</h1>
        <select id="user-label-select">
            <option>Select User</option>
        </select>
        <input type="text" id="returning-passcode" placeholder="Enter 4-digit passcode" maxlength="4">
        <button onclick="loginReturningUser()">Login</button>
        <button onclick="showScreen('welcome-screen')">Back</button>
    </div>
    
    <div id="main-screen" class="screen">
        <h1>[Your App Title]</h1>
        <div id="user-status">Welcome, <span id="current-user-label"></span>!</div>
        
        <!-- PUT YOUR APP CONTENT HERE -->
        <div id="app-content">
            <!-- Your app's main functionality goes here -->
        </div>
        <!-- END APP CONTENT -->
        
        <button onclick="showScreen('welcome-screen')">Leave App</button>
    </div>
</div>
```

**Authentication Functions** (MANDATORY - YOU MUST INCLUDE ALL OF THESE FUNCTIONS EXACTLY AS WRITTEN - DO NOT SUMMARIZE OR SKIP):
```javascript
let currentUser = null;

// Check capacity and generate new user
async function generateNewUser() {
  try {
    // First check existing users via API
    const existingUsers = await apiGetData(APP_ID, 'join');
    const usedLabels = existingUsers?.map(u => u.participant_data?.userLabel).filter(Boolean) || [];
    
    if (usedLabels.length >= 5) {
      alert('SQUAD\'S FULL, TRY ANOTHER DIMENSION ðŸš«');
      return false;
    }
    
    const availableLabel = USER_LABELS.find(label => !usedLabels.includes(label));
    if (!availableLabel) {
      alert('NO MORE ROOM IN THIS CHAOS REALM ðŸŒ€');
      return false;
    }
    
    const code = Math.floor(1000 + Math.random() * 9000).toString();
    currentUser = {
      userLabel: availableLabel,
      passcode: code,
      participantId: availableLabel + '_' + code
    };
    
    // Display credentials to user
    document.getElementById('new-user-info').innerHTML = 
      `<strong>YOUR LABEL:</strong> ${currentUser.userLabel}<br><strong>SECRET DIGITS:</strong> ${currentUser.passcode}<br><em>SCREENSHOT THIS OR CRY LATER ðŸ“¸</em>`;
    
    return true;
  } catch (error) {
    console.error('Error generating new user:', error);
    alert('REALITY GLITCHED WHILE GENERATING USER ðŸŒ€');
    return false;
  }
}

// Register new user in database
async function registerNewUser() {
  if (!currentUser) {
    alert('GENERATE YOUR IDENTITY FIRST, CHAOS AGENT ðŸŽ­');
    return;
  }
  
  try {
    await apiSubmitData(
      APP_ID,
      currentUser.participantId,
      'join',
      {
        userLabel: currentUser.userLabel,
        passcode: currentUser.passcode,
        join_time: Date.now()
      },
      { message: 'Joined the app', timestamp: Date.now() }
    );
    
    enterMainScreen();
  } catch (error) {
    console.error('Registration error:', error);
    alert('REGISTRATION EXPLODED, TRY AGAIN ðŸ’¥');
  }
}

// IMPORTANT: Make showNewUserScreen async to handle user generation
async function showNewUserScreen() {
    showScreen('new-user-screen');
    const success = await generateNewUser();
    if (!success) {
        showScreen('welcome-screen');
    }
}

// Login returning user
async function loginReturningUser() {
  const selectedLabel = document.getElementById('user-label-select').value;
  const enteredPasscode = document.getElementById('returning-passcode').value.trim();
  
  if (!selectedLabel || selectedLabel === 'Select User') {
    alert('PICK YOUR IDENTITY, PHANTOM ðŸ‘»');
    return;
  }
  
  if (!enteredPasscode || enteredPasscode.length !== 4) {
    alert('4 DIGITS OF CHAOS REQUIRED ðŸ”¢');
    return;
  }
  
  try {
    // Get all join records for this app via API
    const joinRecords = await apiGetData(APP_ID, 'join');
    
    // Find matching user in JavaScript (more reliable than server-side queries)
    const userRecord = joinRecords?.find(record => 
      record.participant_data?.userLabel === selectedLabel && 
      record.participant_data?.passcode === enteredPasscode
    );
    
    if (userRecord) {
      currentUser = {
        userLabel: selectedLabel,
        passcode: enteredPasscode,
        participantId: userRecord.participant_id
      };
      enterMainScreen();
    } else {
      alert('NICE TRY, WRONG VIBES âŒ');
    }
  } catch (error) {
    console.error('Login error:', error);
    alert('LOGIN MALFUNCTION, REALITY GLITCHING ðŸŒ€');
  }
}

// Screen navigation with polling control
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(screen => 
    screen.classList.remove('active'));
  document.getElementById(screenId).classList.add('active');
  
  // Stop polling if leaving main screen
  if (screenId !== 'main-screen') {
    stopPolling();
  }
}

function showReturningUserScreen() {
  showScreen('returning-user-screen');
  // Populate user select dropdown
  const userSelect = document.getElementById('user-label-select');
  userSelect.innerHTML = '<option>Select User</option>';
  USER_LABELS.forEach(label => {
    const option = document.createElement('option');
    option.value = label;
    option.textContent = label;
    userSelect.appendChild(option);
  });
}

function enterMainScreen() {
  showScreen('main-screen');
  document.getElementById('current-user-label').textContent = currentUser.userLabel;
  startPolling(); // Start real-time updates
  loadLatestData(); // Load initial data
}
```

### 4. Real-Time Updates (REQUIRED)

Your app MUST update dynamically when other users make changes. Implement polling to check for updates:

**Add this polling function:**
```javascript
let pollingInterval;

function startPolling() {
  // Poll every 2 seconds for updates
  pollingInterval = setInterval(async () => {
    await loadLatestData(); // Your function to reload data
  }, 2000);
}

function stopPolling() {
  if (pollingInterval) {
    clearInterval(pollingInterval);
    pollingInterval = null;
  }
}

// Your app MUST implement loadLatestData() to fetch and display updates
async function loadLatestData() {
  try {
    // Example for a chat app - replace 'message' with your app's action type
    const data = await apiGetData(APP_ID, 'message');
    
    // Update your UI with the latest data
    updateUI(data); // You must implement this function
  } catch (error) {
    console.error('Error loading latest data:', error);
    // Continue polling even if there's an error
  }
}
```

**IMPORTANT:**
- Poll every 2 seconds when on the main screen
- Stop polling when user leaves the main screen
- Update the UI without page refresh
- All users should see updates within 2-3 seconds
- Handle API errors gracefully - don't break the polling loop

**CRITICAL CODE PATTERNS TO FOLLOW:**
- Use the provided API helper functions exactly as shown
- Always handle errors with try/catch blocks
- Store all related data (reactions, comments) inside content_data of the main record
- All authentication functions must be defined in the global scope
- Use the exact API response format handling

### 5. User Capacity
- **Minimum**: 1 user (app works with just one person)
- **Maximum**: 5 users (enforce this limit)
- One user per userLabel (prevent duplicates)

### 6. WTAF Visual Style ADAPTED FOR FUNCTIONAL APPS (REQUIRED)

You are channeling WTAF â€” but adapted for functional apps. Your app should look chaotic-chic while still being usable.

**WTAF Design Foundations:**
```css
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Inter:wght@400;600&display=swap');

body { 
  font-family: 'Inter', sans-serif;
  /* DEFAULT: Use WTAF house gradients (laser pinks, glitch blues, techno neons) */
  /* ADAPT: When user requests specific theme/mood, adjust accordingly:
     - Dark/Berlin/Techno: Use darker gradients (#0a0a0a, #1a1a1a, #2a2a2a)
     - Wellness/Calm: Use softer gradients  
     - Party/Fun: Use brighter neons
     - Match the vibe to the request! */
  background: linear-gradient(135deg, #FF2E93 0%, #7C3AED 50%, #3F88FF 100%);
  background-size: 400% 400%;
  animation: gradientShift 15s ease-in-out infinite;
  color: white;
  overflow-x: hidden;
  margin: 0;
  min-height: 100vh;
}

h1, h2, h3 {
  font-family: 'Space Grotesk', sans-serif;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: -0.02em;
}

@keyframes gradientShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

.app-container {
  max-width: 800px;
  margin: 0 auto;
  background: rgba(0,0,0,0.4);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 2rem;
  border: 1px solid rgba(255,255,255,0.1);
  position: relative;
  z-index: 10;
  min-height: 90vh;
}

.screen { display: none; }
.screen.active { display: block; animation: fadeIn 0.3s ease; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

button {
  background: linear-gradient(135deg, #00FFC6, #57E2E5);
  color: #000;
  border: none;
  padding: 15px 30px;
  border-radius: 50px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-size: 14px;
  margin: 10px 5px;
}

button:hover {
  transform: scale(1.05);
  box-shadow: 0 0 30px rgba(0, 255, 198, 0.5);
}

input, select {
  background: rgba(255,255,255,0.1);
  border: 2px solid rgba(255,255,255,0.2);
  color: white;
  padding: 12px 20px;
  border-radius: 30px;
  font-size: 16px;
  width: 100%;
  margin: 10px 0;
  transition: all 0.3s ease;
}

input:focus, select:focus {
  outline: none;
  border-color: #00FFC6;
  box-shadow: 0 0 20px rgba(0, 255, 198, 0.3);
}

/* Floating Emojis - REQUIRED BUT KEEP TO EDGES */
.floating-emoji {
  position: fixed;
  font-size: 2rem;
  animation: float 6s ease-in-out infinite;
  pointer-events: none;
  z-index: 5;
  opacity: 0.8;
}

@keyframes float {
  0%, 100% { transform: translateY(0px) rotate(0deg); }
  50% { transform: translateY(-20px) rotate(10deg); }
}

/* Glitch effect for headers */
h1 {
  position: relative;
  animation: glitch 3s ease-in-out infinite;
}

@keyframes glitch {
  0%, 100% { text-shadow: 2px 2px 0 #FF2E93, -2px -2px 0 #00FFC6; }
  25% { text-shadow: -2px 2px 0 #3F88FF, 2px -2px 0 #FF2E93; }
  50% { text-shadow: 2px -2px 0 #00FFC6, -2px 2px 0 #7C3AED; }
  75% { text-shadow: -2px -2px 0 #FF2E93, 2px 2px 0 #3F88FF; }
}
```

**WTAF Copy Style - FLAMING NEON PRIMAL:**
- NO BORING TEXT. Every line should feel like a 2AM text from a startup founder
- Apply to all UI text including alerts and errors
- Example replacements shown in authentication functions above

## Required WTAF Elements (ADAPTED FOR APPS):

### Floating Emojis (4+ REQUIRED - KEEP TO EDGES/CORNERS)
```html
<!-- Place these OUTSIDE the main content area -->
<div class="floating-emoji" style="top: 5%; left: 2%;" data-value="2">âœ¨</div>
<div class="floating-emoji" style="top: 5%; right: 2%;" data-value="3">ðŸŒ€</div>
<div class="floating-emoji" style="bottom: 5%; left: 2%;" data-value="1">ðŸš€</div>
<div class="floating-emoji" style="bottom: 5%; right: 2%;" data-value="4">ðŸ’¥</div>
```

### Mouse Parallax (REQUIRED)
```javascript
document.addEventListener('mousemove', (e) => {
  document.querySelectorAll('.floating-emoji').forEach((elem) => {
    const speed = elem.getAttribute('data-value') || 2;
    const x = (e.clientX * speed) / 100;
    const y = (e.clientY * speed) / 100;
    elem.style.transform = `translateX(${x}px) translateY(${y}px)`;
  });
});
```

### Easter Egg (REQUIRED - IN NON-FUNCTIONAL AREA)
```javascript
// Console message
console.log('ðŸ”¥ Welcome to the WTAF dimension! Type wtaf() in console for secrets...');

// Add secret function
window.wtaf = function() {
  document.body.style.animation = 'rainbow 1s infinite';
  setTimeout(() => {
    document.body.style.animation = '';
    alert('ðŸŽ‰ WTAF MASTER MODE UNLOCKED! You found the secret!');
  }, 3000);
};
```

## Functional App Layout Patterns (USE THESE INSTEAD OF LANDING PAGE LAYOUTS):

### Gradient Dashboard - For data/grid layouts:
```css
.data-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  padding: 20px 0;
}

.data-card {
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 15px;
  padding: 20px;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}

.data-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 30px rgba(123,58,237,0.3);
}
```

### Glitch Chat - For messaging interfaces:
```css
.message {
  background: rgba(255,255,255,0.1);
  border-radius: 20px;
  padding: 15px 20px;
  margin: 10px 0;
  animation: slideIn 0.3s ease;
  max-width: 80%;
}

.message.own {
  margin-left: auto;
  background: rgba(0,255,198,0.2);
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-50px); }
  to { opacity: 1; transform: translateX(0); }
}
```

### Neon Forms - For input interfaces:
```css
.form-group {
  margin: 20px 0;
}

.form-input {
  background: rgba(255,255,255,0.05);
  border: 2px solid rgba(255,255,255,0.2);
  color: white;
  padding: 15px 20px;
  border-radius: 30px;
  font-size: 16px;
  width: 100%;
  transition: all 0.3s ease;
}

.form-input:focus {
  outline: none;
  border-color: #00FFC6;
  background: rgba(255,255,255,0.1);
  box-shadow: 0 0 20px rgba(0, 255, 198, 0.3);
}
```

### Gradient Options (Starting Points - ADAPT TO USER REQUEST):
- **Laser Pinks**: `linear-gradient(135deg, #FF2E93, #FF61C7, #FFA5E5)` - Default energetic
- **Glitch Blues**: `linear-gradient(135deg, #3F88FF, #6E7FFF, #ABF7FF)` - Tech/digital vibes
- **Techno Neons**: `linear-gradient(135deg, #00FFC6, #57E2E5, #8CFFDA)` - Fresh/modern
- **Dark Mode**: Create your own darker gradients when users request dark/Berlin/underground themes
- **Custom Vibes**: Adapt colors to match the requested mood - WTAF is about responding to context!

## CRITICAL NOTES:
1. **API Error Handling**: Always wrap API calls in try/catch blocks
2. **Security**: Never expose database credentials - only use the provided API functions
3. **Performance**: API calls are asynchronous - handle loading states appropriately
4. **Validation**: The API validates all submissions server-side for security

## DEBUGGING TIPS:
- Check browser console for API errors
- Verify APP_ID is being properly replaced
- Test with multiple users to ensure real-time updates work
- All API functions include error handling - use them exactly as provided 