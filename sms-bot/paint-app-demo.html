<!DOCTYPE html>
<html lang="en">
<head>
    <title>WTAF ‚Äì Delusional App Generator</title>
    <meta property="og:title" content="wtafPAIN" />
    <meta property="og:description" content="Vibecoded chaos, shipped via SMS." />
    <meta property="og:image" content="https://tqniseocczttrfwtpbdr.supabase.co/storage/v1/object/public/og-images/bart-neutral-flying-fox-calculating.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:url" content="https://theaf-web.ngrok.io/bart/neutral-flying-fox-calculating" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WTAF RETRO PAINT 98 - DEMO MODE</title>
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Inter:wght@400;600&display=swap');

    body { 
        font-family: 'Inter', sans-serif;
        background: linear-gradient(135deg, #2C2C2C 0%, #1A1A1A 50%, #0A0A0A 100%);
        background-size: 400% 400%;
        color: #00FF00;
        text-shadow: 0 0 5px #00FF00;
        overflow-x: hidden;
        margin: 0;
        min-height: 100vh;
    }

    h1, h2, h3 {
        font-family: 'Space Grotesk', sans-serif;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: -0.02em;
    }

    @keyframes gradientShift {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    .app-container {
        max-width: 100%;
        margin: 0 auto;
        background: rgba(0,0,0,0.8);
        backdrop-filter: blur(20px);
        padding: 1rem;
        border: 2px solid #00FF00;
        position: relative;
        z-index: 10;
        min-height: 90vh;
    }

    .screen { display: none; }
    .screen.active { display: block; animation: fadeIn 0.3s ease; }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    button {
        background: #000;
        color: #00FF00;
        border: 2px solid #00FF00;
        padding: 10px 20px;
        border-radius: 0;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 14px;
        margin: 5px;
        box-shadow: 3px 3px 0 #00FF00;
    }

    button:hover {
        background: #00FF00;
        color: #000;
        transform: translate(2px, 2px);
        box-shadow: 1px 1px 0 #00FF00;
    }

    input, select {
        background: #000;
        border: 2px solid #00FF00;
        color: #00FF00;
        padding: 8px 15px;
        border-radius: 0;
        font-size: 16px;
        margin: 5px 0;
        transition: all 0.3s ease;
    }

    input:focus, select:focus {
        outline: none;
        box-shadow: 0 0 10px #00FF00;
    }

    #canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
    }

    #paint-canvas {
        border: 2px solid #00FF00;
        background: #fff;
        touch-action: none;
        max-width: 100%;
    }

    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 10px;
        background: rgba(0,0,0,0.8);
        border: 2px solid #00FF00;
        margin: 10px 0;
    }

    .color-picker {
        width: 50px;
        height: 50px;
        padding: 0;
        border: 2px solid #00FF00;
    }

    .gallery-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 20px;
        padding: 20px;
    }

    .gallery-item {
        border: 2px solid #00FF00;
        padding: 10px;
        background: rgba(0,0,0,0.5);
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .gallery-item:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }

    .gallery-item img {
        width: 100%;
        height: auto;
        border: 1px solid #00FF00;
    }

    .floating-emoji {
        position: fixed;
        font-size: 2rem;
        animation: float 6s ease-in-out infinite;
        pointer-events: none;
        z-index: 5;
        opacity: 0.8;
        filter: drop-shadow(0 0 5px #00FF00);
    }

    @keyframes float {
        0%, 100% { transform: translateY(0px) rotate(0deg); }
        50% { transform: translateY(-20px) rotate(10deg); }
    }

    #user-status {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.8);
        padding: 10px;
        border: 2px solid #00FF00;
        z-index: 100;
    }

    @media (max-width: 768px) {
        .toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        
        #canvas-container {
            margin-bottom: 100px;
        }
        
        button {
            padding: 8px 15px;
            font-size: 12px;
        }
    }
    </style>
<script>
// ZAD Helper Functions - Inline version for test apps

// SIMPLIFIED UUID INJECTION: Set window.APP_ID for backup
window.APP_ID = '6dacd996-7a2a-4e83-9c91-ce176d15f51c';
console.log('üÜî SIMPLIFIED UUID INJECTION: window.APP_ID set to:', '6dacd996-7a2a-4e83-9c91-ce176d15f51c');

console.log('üöÄ Loading ZAD Helper Functions (inline)...');

// Auth state - Use existing global currentUser or create zadCurrentUser
let zadCurrentUser = (typeof currentUser !== 'undefined') ? currentUser : null;
let authInitialized = false;

// Get app ID from window.APP_ID (set by system) - ENHANCED DEBUG VERSION
function getAppId() {
    console.log('üÜî ZAD getAppId() called, returning UUID:', '6dacd996-7a2a-4e83-9c91-ce176d15f51c');
    return '6dacd996-7a2a-4e83-9c91-ce176d15f51c';
}

                // Get participant ID - return stored ID or generate temporary one
                function getParticipantId() {
                    let participantId = localStorage.getItem('zad_participant_id');
                    if (!participantId) {
                        // Generate temporary ID - app's authentication system will set the real one
                        participantId = 'temp_' + Math.random().toString(36).substr(2, 12);
                        localStorage.setItem('zad_participant_id', participantId);
                        localStorage.setItem('zad_username', 'Anonymous');
                    }
                    return participantId;
                }

                // Get username from current session
                function getUsername() {
                    return localStorage.getItem('zad_username') || 'Anonymous';
                }

                // Update ZAD helper functions with app's authentication state
                function updateZadAuth(userLabel, participantId) {
                    localStorage.setItem('zad_participant_id', participantId);
                    localStorage.setItem('zad_username', userLabel);
                    zadCurrentUser = {
                        username: userLabel,
                        participantId: participantId
                    };
                    console.log('üîÑ Updated ZAD auth state:', zadCurrentUser);
                }

                // Initialize authentication (simplified)
                function initAuth() {
                    console.log('üîê Initializing authentication...');
                    if (authInitialized) return;
                    authInitialized = true;
                    
                    // Don't clear localStorage or prompt during initialization
                    // Let the app's authentication system handle user setup
                    zadCurrentUser = {
                        username: getUsername(),
                        participantId: localStorage.getItem('zad_participant_id') || null
                    };
                    
                    console.log('‚úÖ Authentication ready:', zadCurrentUser);
                }

// Save data to ZAD API
async function save(type, data) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        const username = getUsername();
        
        const zadData = {
            app_id: app_id,
            participant_id: participant_id,
            participant_data: {
                userLabel: username,
                username: username
            },
            action_type: type,
            content_data: {
                ...data,
                timestamp: data.timestamp || Date.now(),
                author: data.author || username
            }
        };
        
        console.log('üîÑ Saving to ZAD API:', { type, data: zadData });
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(zadData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error('Save failed: ${errorData.error || response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Saved successfully:', result);
        return result;
        
    } catch (error) {
        console.error('‚ùå Save error:', error);
        alert(`Failed to save: ${error.message}`);
        throw error;
    }
}

// Phase 1 Authentication Backend Helper Functions
// These call the backend API with specific action types

// Backend Helper 1: Check Available Slots
async function checkAvailableSlots() {
    try {
        const app_id = getAppId();
        
        console.log('üîç Calling backend checkAvailableSlots for app:', app_id);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'check_slots',
                content_data: {}
            })
        });
        
        if (!response.ok) {
            throw new Error('Check slots failed: ${response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend checkAvailableSlots result:', result.slots);
        
        return result.slots;
        
    } catch (error) {
        console.error('‚ùå Check slots error:', error);
        alert(`Failed to check available slots: ${error.message}`);
        return { totalSlots: 5, usedSlots: 0, availableSlots: 5, availableLabels: [], usedLabels: [], isFull: false };
    }
}

// Backend Helper 2: Generate User Credentials
async function generateUser() {
    try {
        const app_id = getAppId();
        
        console.log('üé≤ Calling backend generateUser for app:', app_id);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'generate_user',
                content_data: {}
            })
        });
        
        if (!response.ok) {
            throw new Error('Generate user failed: ${response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend generateUser result:', result);
        
        if (!result.success) {
            alert(result.error || 'Failed to generate user');
            return null;
        }
        
        return result.user;
        
    } catch (error) {
        console.error('‚ùå Generate user error:', error);
        alert(`Failed to generate user: ${error.message}`);
        return null;
    }
}

// Backend Helper 3: Register User
async function registerUser(userLabel, passcode, participantId) {
    try {
        const app_id = getAppId();
        
        console.log('üìù Calling backend registerUser for app:', app_id, 'user:', userLabel);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'register_user',
                content_data: {
                    userLabel: userLabel,
                    passcode: passcode,
                    participantId: participantId
                }
            })
        });
        
        if (!response.ok) {
            throw new Error('Register user failed: ${response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend registerUser result:', result);
        
        if (!result.success) {
            alert(result.result?.error || 'Registration failed');
            return { success: false, error: result.result?.error };
        }
        
        return result.result;
        
    } catch (error) {
        console.error('‚ùå Register user error:', error);
        alert(`Registration failed: ${error.message}`);
        return { success: false, error: error.message };
    }
}

// Backend Helper 4: Authenticate User
async function authenticateUser(userLabel, passcode) {
    try {
        const app_id = getAppId();
        
        console.log('üîê Calling backend authenticateUser for app:', app_id, 'user:', userLabel);
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                action_type: 'authenticate_user',
                content_data: {
                    userLabel: userLabel,
                    passcode: passcode
                }
            })
        });
        
        if (!response.ok) {
            throw new Error('Authentication failed: ${response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend authenticateUser result:', result);
        
        if (!result.success) {
            alert(result.result?.error || 'Authentication failed');
            return { success: false, error: result.result?.error };
        }
        
        return result.result;
        
    } catch (error) {
        console.error('‚ùå Authentication error:', error);
        alert(`Authentication failed: ${error.message}`);
        return { success: false, error: error.message };
    }
}

// Backend Helper Function Test: greet(name)
// This demonstrates how backend helper functions work - all logic happens on server
async function greet(name) {
    try {
        const app_id = getAppId();
        const participant_id = getParticipantId();
        const username = getUsername();
        
        console.log('ü§ñ Calling backend greet function for:', name);
        
        // Simple client call - all logic happens on backend
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                app_id: app_id,
                participant_id: participant_id,
                participant_data: { userLabel: username, username: username },
                action_type: 'greet',
                content_data: { name: name }
            })
        });
        
        if (!response.ok) {
            throw new Error('Greet failed: ${response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Backend greet function result:', result);
        
        // Return the backend-generated greeting
        return result.greeting;
        
    } catch (error) {
        console.error('‚ùå Greet error:', error);
        alert(`Greet failed: ${error.message}`);
        return 'Error generating greeting';
    }
}

// Load data from ZAD API
async function load(type) {
    try {
        const app_id = getAppId();
        
        console.log('üîÑ Loading from ZAD API:', { app_id, type });
        
        const url = `/api/zad/load?app_id=${encodeURIComponent(app_id)}&action_type=${encodeURIComponent(type)}`;
        console.log('üîç ZAD load URL:', url);
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error('Load failed: ${errorData.error || response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const data = await response.json();
        console.log('‚úÖ Loaded successfully:', data);
        
        // Transform ZAD data back to simple format
        return data.map(item => ({
            id: item.id,
            ...item.content_data,
            author: item.content_data.author || item.participant_data?.username || 'Unknown',
            created_at: item.created_at
        }));
        
    } catch (error) {
        console.error('‚ùå Load error:', error);
        alert(`Failed to load: ${error.message}`);
        return [];
    }
}

// Query data from ZAD API with flexible filtering
async function query(type, options = {}) {
    try {
        const app_id = getAppId();
        
        console.log('üîç Querying ZAD API:', { app_id, type, options });
        
        const queryData = {
            app_id: app_id,
            action_type: 'query',
            content_data: {
                type: type,
                ...options
            }
        };
        
        const response = await fetch('/api/zad/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(queryData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error('Query failed: ${errorData.error || response.statusText}: ' + (error?.message || 'Unknown error'));
        }
        
        const result = await response.json();
        console.log('‚úÖ Query completed successfully:', result);
        
        // Transform ZAD data back to simple format
        return result.data.map(item => ({
            id: item.id,
            ...item.content_data,
            author: item.content_data.author || item.participant_data?.username || 'Unknown',
            created_at: item.created_at
        }));
        
    } catch (error) {
        console.error('‚ùå Query error:', error);
        alert(`Failed to query: ${error.message}`);
        return [];
    }
}

                // Make functions globally available
                window.initAuth = initAuth;
                window.save = save;
                window.load = load;
                window.query = query;
                window.getAppId = getAppId;
                window.getParticipantId = getParticipantId;
                window.getUsername = getUsername;
                window.updateZadAuth = updateZadAuth;
                window.greet = greet; // Add greet function to window object
                window.checkAvailableSlots = checkAvailableSlots;
                window.generateUser = generateUser;
                window.registerUser = registerUser;
                window.authenticateUser = authenticateUser;

console.log('üöÄ ZAD Helper Functions loaded successfully');
                console.log('Available functions: initAuth(), save(type, data), load(type), query(type, options), updateZadAuth(userLabel, participantId), greet(name)');
console.log('üîë Phase 1 Auth functions: checkAvailableSlots(), generateUser(), registerUser(label, code, id), authenticateUser(label, code)');
</script>
</head>
<body>
    <div class="floating-emoji" style="top: 5%; left: 2%;" data-value="2">üé®</div>
    <div class="floating-emoji" style="top: 5%; right: 2%;" data-value="3">üíæ</div>
    <div class="floating-emoji" style="bottom: 5%; left: 2%;" data-value="1">üëæ</div>
    <div class="floating-emoji" style="bottom: 5%; right: 2%;" data-value="4">üïπÔ∏è</div>

    <div class="app-container">
        <div id="welcome-screen" class="screen">
            <h1>WTAF RETRO PAINT 98</h1>
            <p>DIGITAL CHAOS CREATION STATION</p>
            <button onclick="showNewUserScreen()">New User</button>
            <button onclick="showReturningUserScreen()">Returning User</button>
        </div>
        
        <div id="new-user-screen" class="screen">
            <h1>New User</h1>
            <div id="new-user-info"></div>
            <button onclick="registerNewUser()">Register & Enter App</button>
            <button onclick="showScreen('welcome-screen')">Back</button>
        </div>
        
        <div id="returning-user-screen" class="screen">
            <h1>Returning User</h1>
            <select id="user-label-select">
                <option>Select User</option>
            </select>
            <input type="text" id="returning-passcode" placeholder="Enter 4-digit passcode" maxlength="4">
            <button onclick="loginReturningUser()">Login</button>
            <button onclick="showScreen('welcome-screen')">Back</button>
        </div>
        
        <div id="main-screen" class="screen active">
            <div id="user-status">üé® DEMO MODE - Anyone can paint! Welcome, <span id="current-user-label">Demo User</span>!</div>
            
            <div id="app-content">
                <div class="toolbar">
                    <button onclick="setBrush('pencil')">Pencil</button>
                    <button onclick="setBrush('brush')">Brush</button>
                    <input type="color" class="color-picker" value="#FF0000" onchange="setColor(this.value)">
                    <input type="range" min="1" max="50" value="5" onchange="setSize(this.value)">
                    <button onclick="undo()">Undo</button>
                    <button onclick="clearCanvas()">Clear</button>
                    <button onclick="saveArt()">Save Art</button>
                    <button onclick="showGallery()">Gallery</button>
                </div>

                <div id="canvas-container">
                    <canvas id="paint-canvas" width="800" height="600"></canvas>
                </div>

                <div id="gallery" style="display: none;">
                    <h2>ART GALLERY</h2>
                    <div class="gallery-grid" id="gallery-grid"></div>
                    <button onclick="hideGallery()">Back to Paint</button>
                </div>
            </div>
            
            <button onclick="showScreen('welcome-screen')">Leave App</button>
        </div>
    </div>

    <script>
    let currentUser = { userLabel: 'Demo User', participantId: 'demo-user-' + Math.random().toString(36).substr(2, 6) };
    let canvas, ctx;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentColor = '#FF0000';
    let currentSize = 5;
    let currentBrush = 'pencil';
    let drawingHistory = [];
    let currentPath = [];

    // Authentication System
    function initAuth() {
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('paint-canvas');
            ctx = canvas.getContext('2d');
            ctx.lineCap = 'round';
            setupCanvas();
        });
    }

    async function generateNewUser() {
        try {
            const slots = await checkAvailableSlots();
            if (slots.isFull) {
                alert("SQUAD'S FULL, TRY ANOTHER DIMENSION üö´");
                return false;
            }
            const user = await generateUser();
            if (user && user.success) {
                currentUser = {
                    userLabel: user.userLabel,
                    passcode: user.passcode,
                    participantId: user.participantId
                };
                document.getElementById('new-user-info').innerHTML = 
                    `<strong>YOUR LABEL:</strong> ${currentUser.userLabel}<br><strong>SECRET DIGITS:</strong> ${currentUser.passcode}<br><em>SCREENSHOT THIS OR CRY LATER üì∏</em>`;
                return true;
            }
            return false;
        } catch (error) {
            console.error('User generation error:', error);
            return false;
        }
    }

    async function registerNewUser() {
        if (!currentUser) {
            alert('GENERATE YOUR IDENTITY FIRST, CHAOS AGENT üé≠');
            return;
        }
        try {
            const result = await registerUser(currentUser.userLabel, currentUser.passcode, currentUser.participantId);
            if (result && result.success) {
                updateZadAuth(currentUser.userLabel, currentUser.participantId);
                enterMainScreen();
            }
        } catch (error) {
        console.error('Registration error:', error);
        alert('Registration error:: ' + error.message);
    }
    }

    async function showNewUserScreen() {
        showScreen('new-user-screen');
        const success = await generateNewUser();
        if (!success) {
            showScreen('welcome-screen');
        }
    }

    async function loginReturningUser() {
        const selectedLabel = document.getElementById('user-label-select').value;
        const enteredPasscode = document.getElementById('returning-passcode').value.trim();
        
        if (!selectedLabel || selectedLabel === 'Select User') {
            alert('PICK YOUR IDENTITY, PHANTOM üëª');
            return;
        }
        
        if (!enteredPasscode || enteredPasscode.length !== 4) {
            alert('4 DIGITS OF CHAOS REQUIRED üî¢');
            return;
        }
        
        try {
            const result = await authenticateUser(selectedLabel, enteredPasscode);
            if (result && result.success) {
                currentUser = {
                    userLabel: selectedLabel,
                    passcode: enteredPasscode,
                    participantId: result.user.participantId
                };
                updateZadAuth(currentUser.userLabel, currentUser.participantId);
                enterMainScreen();
            } else {
                alert('NICE TRY, WRONG VIBES ‚ùå');
            }
        } catch (error) {
        console.error('Login error:', error);
        alert('Login error:: ' + error.message);
    }
    }

    async function showReturningUserScreen() {
        showScreen('returning-user-screen');
        try {
            const slots = await checkAvailableSlots();
            const userSelect = document.getElementById('user-label-select');
            userSelect.innerHTML = '<option>Select User</option>';
            slots.usedLabels.forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                userSelect.appendChild(option);
            });
        } catch (error) {
        console.error('Error loading users:', error);
        alert('Error loading users:: ' + error.message);
    }
    }

    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(screen => 
            screen.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
        if (screenId !== 'main-screen') {
            stopPolling();
        }
    }

    function enterMainScreen() {
        showScreen('main-screen');
        document.getElementById('current-user-label').textContent = currentUser.userLabel;
        startPolling();
        loadLatestData();
    }

    // Canvas Functions
    function setupCanvas() {
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        canvas.addEventListener('touchstart', handleTouch);
        canvas.addEventListener('touchmove', handleTouch);
        canvas.addEventListener('touchend', stopDrawing);
    }

    function handleTouch(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        if (e.type === 'touchstart') {
            startDrawing({ offsetX: x, offsetY: y });
        } else if (e.type === 'touchmove') {
            draw({ offsetX: x, offsetY: y });
        }
    }

    function startDrawing(e) {
        isDrawing = true;
        [lastX, lastY] = [e.offsetX, e.offsetY];
        currentPath = [];
        currentPath.push({ x: lastX, y: lastY });
    }

    function draw(e) {
        if (!isDrawing) return;
        
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(e.offsetX, e.offsetY);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentSize;
        
        if (currentBrush === 'brush') {
            ctx.lineWidth = currentSize * 2;
            ctx.globalAlpha = 0.5;
        } else {
            ctx.globalAlpha = 1;
        }
        
        ctx.stroke();
        [lastX, lastY] = [e.offsetX, e.offsetY];
        currentPath.push({ x: lastX, y: lastY });
    }

    function stopDrawing() {
        if (isDrawing) {
            drawingHistory.push({
                path: currentPath,
                color: currentColor,
                size: currentSize,
                brush: currentBrush
            });
        }
        isDrawing = false;
    }

    function undo() {
        if (drawingHistory.length === 0) return;
        
        drawingHistory.pop();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawingHistory.forEach(drawing => {
            ctx.beginPath();
            ctx.moveTo(drawing.path[0].x, drawing.path[0].y);
            
            drawing.path.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            
            ctx.strokeStyle = drawing.color;
            ctx.lineWidth = drawing.size;
            ctx.globalAlpha = drawing.brush === 'brush' ? 0.5 : 1;
            ctx.stroke();
        });
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawingHistory = [];
    }

    function setColor(color) {
        currentColor = color;
    }

    function setSize(size) {
        currentSize = size;
    }

    function setBrush(brush) {
        currentBrush = brush;
    }

    async function saveArt() {
        const imageData = canvas.toDataURL('image/png');
        await save('artwork', {
            image: imageData,
            artist: currentUser.userLabel,
            timestamp: Date.now()
        });
        alert('ART SAVED TO THE DIGITAL VOID! üé®');
    }

    function showGallery() {
        document.getElementById('canvas-container').style.display = 'none';
        document.getElementById('gallery').style.display = 'block';
        loadGallery();
    }

    function hideGallery() {
        document.getElementById('canvas-container').style.display = 'flex';
        document.getElementById('gallery').style.display = 'none';
    }

    async function loadGallery() {
        const gallery = document.getElementById('gallery-grid');
        gallery.innerHTML = '';
        const artworks = await load('artwork');
        
        artworks.forEach(art => {
            const div = document.createElement('div');
            div.className = 'gallery-item';
            div.innerHTML = `
                <img src="${art.image}" alt="Artwork">
                <p>By: ${art.artist}</p>
            `;
            gallery.appendChild(div);
        });
    }

    let pollingInterval;
    let galleryRefreshInterval;

    function startPolling() {
        pollingInterval = setInterval(loadLatestData, 2000);
        galleryRefreshInterval = setInterval(() => {
            if (document.getElementById('gallery').style.display === 'block') {
                loadGallery();
            }
        }, 20000);
    }

    function stopPolling() {
        if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
        if (galleryRefreshInterval) {
            clearInterval(galleryRefreshInterval);
            galleryRefreshInterval = null;
        }
    }

    async function loadLatestData() {
        try {
            // Don't auto-refresh gallery to prevent blinking
            // if (document.getElementById('gallery').style.display === 'block') {
            //     await loadGallery();
            // }
        } catch (error) {
        console.error('Error loading latest data:', error);
        alert('Error loading latest data:: ' + error.message);
    }
    }

    // Mouse parallax
    document.addEventListener('mousemove', (e) => {
        document.querySelectorAll('.floating-emoji').forEach((elem) => {
            const speed = elem.getAttribute('data-value') || 2;
            const x = (e.clientX * speed) / 100;
            const y = (e.clientY * speed) / 100;
            elem.style.transform = `translateX(${x}px) translateY(${y}px)`;
        });
    });

    // Easter egg
    console.log('üî• Welcome to the WTAF dimension! Type wtaf() in console for secrets...');
    window.wtaf = function() {
        document.body.style.animation = 'rainbow 1s infinite';
        setTimeout(() => {
            document.body.style.animation = '';
            alert('üéâ WTAF MASTER MODE UNLOCKED! You found the secret!');
        }, 3000);
    };

    // Demo mode - skip auth and go straight to painting
    updateZadAuth(currentUser.userLabel, currentUser.participantId);
    document.addEventListener('DOMContentLoaded', () => {
        canvas = document.getElementById('paint-canvas');
        ctx = canvas.getContext('2d');
        ctx.lineCap = 'round';
        setupCanvas();
        startPolling();
        loadLatestData();
    });
    </script>
</body>
</html> 