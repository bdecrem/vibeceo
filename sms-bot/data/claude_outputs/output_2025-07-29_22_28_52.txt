I'll create a mobile-friendly Tetris game with touch controls. The game will use swipe gestures and taps for control.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            background: #111;
            max-height: 90vh;
        }
        
        .score {
            color: white;
            font-size: 24px;
            margin: 10px;
            position: absolute;
            top: 0;
        }
    </style>
</head>
<body>
    <div class="score">Score: <span id="scoreText">0</span></div>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = Math.floor(Math.min(window.innerWidth / COLS, window.innerHeight / ROWS));
        
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        
        // Tetromino shapes
        const SHAPES = [
            [[1, 1, 1, 1]], // I
            [[1, 1], [1, 1]], // O
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1, 1], [1, 0, 0]], // L
            [[1, 1, 1], [0, 0, 1]], // J
            [[1, 1, 0], [0, 1, 1]], // S
            [[0, 1, 1], [1, 1, 0]]  // Z
        ];
        
        const COLORS = [
            '#00f0f0', // cyan
            '#f0f000', // yellow
            '#a000f0', // purple
            '#f0a000', // orange
            '#0000f0', // blue
            '#00f000', // green
            '#f00000'  // red
        ];
        
        let score = 0;
        let grid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let gridColors = Array(ROWS).fill().map(() => Array(COLS).fill(''));
        
        let currentPiece = null;
        let currentPieceColor = '';
        let currentX = 0;
        let currentY = 0;
        
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchTime = 0;
        
        class Piece {
            constructor(shape, color) {
                this.shape = shape;
                this.color = color;
            }
            
            get width() {
                return this.shape[0].length;
            }
            
            get height() {
                return this.shape.length;
            }
        }
        
        function createNewPiece() {
            const randomIndex = Math.floor(Math.random() * SHAPES.length);
            currentPiece = new Piece(SHAPES[randomIndex], COLORS[randomIndex]);
            currentX = Math.floor((COLS - currentPiece.width) / 2);
            currentY = 0;
            
            if (!isValidMove(currentX, currentY)) {
                // Game Over
                grid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                gridColors = Array(ROWS).fill().map(() => Array(COLS).fill(''));
                score = 0;
                document.getElementById('scoreText').textContent = score;
            }
        }
        
        function isValidMove(x, y, piece = currentPiece) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (!piece.shape[r][c]) continue;
                    
                    const newX = x + c;
                    const newY = y + r;
                    
                    if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
                    if (newY < 0) continue;
                    if (grid[newY][newX]) return false;
                }
            }
            return true;
        }
        
        function rotatePiece() {
            const newShape = currentPiece.shape[0].map((_, i) =>
                currentPiece.shape.map(row => row[i]).reverse()
            );
            const rotatedPiece = new Piece(newShape, currentPiece.color);
            
            if (isValidMove(currentX, currentY, rotatedPiece)) {
                currentPiece = rotatedPiece;
            }
        }
        
        function mergePiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (!currentPiece.shape[r][c]) continue;
                    
                    grid[currentY + r][currentX + c] = 1;
                    gridColors[currentY + r][currentX + c] = currentPiece.color;
                }
            }
            
            // Check for completed lines
            for (let r = ROWS - 1; r >= 0; r--) {
                if (grid[r].every(cell => cell === 1)) {
                    // Remove the line and add new one at top
                    grid.splice(r, 1);
                    grid.unshift(Array(COLS).fill(0));
                    gridColors.splice(r, 1);
                    gridColors.unshift(Array(COLS).fill(''));
                    score += 100;
                    document.getElementById('scoreText').textContent = score;
                }
            }
            
            createNewPiece();
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c]) {
                        ctx.fillStyle = gridColors[r][c];
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                ctx.fillStyle = currentPiece.color;
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            ctx.fillRect(
                                (currentX + c) * BLOCK_SIZE,
                                (currentY + r) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                        }
                    }
                }
            }
        }
        
        // Touch controls
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastTouchTime = Date.now();
        }, false);
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const diffX = touchX - touchStartX;
            const diffY = touchY - touchStartY;
            
            // Horizontal movement
            if (Math.abs(diffX) > BLOCK_SIZE) {
                const newX = currentX + Math.sign(diffX);
                if (isValidMove(newX, currentY)) {
                    currentX = newX;
                    touchStartX = touchX;
                }
            }
            
            // Fast drop
            if (diffY > BLOCK_SIZE) {
                while (isValidMove(currentX, currentY + 1)) {
                    currentY++;
                }
                mergePiece();
                touchStartY = touchY;
            }
        }, false);
        
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            const touchEndTime = Date.now();
            
            // Tap to rotate
            if (touchEndTime - lastTouchTime < 200) {
                rotatePiece();
            }
        }, false);
        
        let dropCounter = 0;
        let lastTime = 0;
        
        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > 1000) {
                if (isValidMove(currentX, currentY + 1)) {
                    currentY++;
                } else {
                    mergePiece();
                }
                dropCounter = 0;
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        createNewPiece();
        update();
    </script>
</body>
</html>
```

This Tetris implementation includes:

1. Mobile-optimized touch controls:
   - Swipe left/right to move piece
   - Swipe down for fast drop
   - Tap to rotate piece

2. Responsive canvas sizing that adapts to screen size

3. Core Tetris mechanics:
   - Seven standard tetromino shapes
   - Piece rotation
   - Line clearing
   - Score tracking
   - Game over detection

4. Touch-friendly features:
   - Prevented default touch behaviors
   - Appropriate touch target sizes
   - Visual feedback

To play:
1. Tap the screen to rotate the current piece
2. Swipe left or right to move the piece horizontally
3. Swipe down to perform a fast drop
4. Complete lines to score points
5. Game resets if pieces reach the top

The game automatically adjusts to your screen size while maintaining playable proportions. The controls are optimized for mobile play, with generous touch zones and responsive movement.