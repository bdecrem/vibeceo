```html
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
body {
  margin: 0;
  background: linear-gradient(to bottom right, #1a1a2e, #16213e);
  color: white;
  font-family: system-ui;
  touch-action: none;
  overflow: hidden;
}
#gameArea {
  position: relative;
  width: 100vw;
  height: calc(100vh - 120px);
}
#gameCanvas {
  position: absolute;
  top: 0;
  left: 0;
}
#controls {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 120px;
  background: rgba(0,0,0,0.8);
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  box-sizing: border-box;
  z-index: 1000;
}
.btn {
  width: 60px;
  height: 60px;
  background: rgba(255,255,255,0.2);
  border: none;
  border-radius: 10px;
  color: white;
  font-size: 24px;
  touch-action: none;
}
#rotateBtn {
  background: rgba(255,255,255,0.3);
}
</style>
</head>
<body>
<div id="gameArea">
  <canvas id="gameCanvas"></canvas>
</div>
<div id="controls">
  <button class="btn" id="leftBtn">‚¨ÖÔ∏è</button>
  <button class="btn" id="downBtn">‚¨áÔ∏è</button>
  <button class="btn" id="rightBtn">‚û°Ô∏è</button>
  <button class="btn" id="rotateBtn">üîÑ</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Canvas setup
function resizeCanvas() {
  const gameArea = document.getElementById('gameArea');
  const dpr = window.devicePixelRatio || 1;
  canvas.width = gameArea.offsetWidth * dpr;
  canvas.height = gameArea.offsetHeight * dpr;
  canvas.style.width = gameArea.offsetWidth + 'px';
  canvas.style.height = gameArea.offsetHeight + 'px';
  ctx.scale(dpr, dpr);
  
  BLOCK_SIZE = Math.floor(Math.min(canvas.width / (12 * dpr), canvas.height / (22 * dpr)));
  BOARD_WIDTH = 10;
  BOARD_HEIGHT = 20;
  BOARD_X = (canvas.width/dpr - BLOCK_SIZE * BOARD_WIDTH) / 2;
  BOARD_Y = (canvas.height/dpr - BLOCK_SIZE * BOARD_HEIGHT) / 2;
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game constants
const SHAPES = [
  [[1,1,1,1]], // I
  [[1,1],[1,1]], // O
  [[0,1,0],[1,1,1]], // T
  [[0,1,1],[1,1,0]], // S
  [[1,1,0],[0,1,1]], // Z
  [[1,0,0],[1,1,1]], // J
  [[0,0,1],[1,1,1]]  // L
];

const COLORS = ['#00f0f0', '#f0f000', '#a000f0', '#00f000', '#f00000', '#0000f0', '#f0a000'];

let board = [];
let currentPiece = null;
let currentPieceX = 0;
let currentPieceY = 0;
let currentPieceType = 0;
let score = 0;
let gameOver = false;
let gameStarted = false;
let dropInterval = 1000;
let lastDrop = 0;

function initBoard() {
  board = [];
  for(let y = 0; y < BOARD_HEIGHT; y++) {
    board[y] = [];
    for(let x = 0; x < BOARD_WIDTH; x++) {
      board[y][x] = 0;
    }
  }
}

function spawnPiece() {
  currentPieceType = Math.floor(Math.random() * SHAPES.length);
  currentPiece = SHAPES[currentPieceType];
  currentPieceX = Math.floor((BOARD_WIDTH - currentPiece[0].length) / 2);
  currentPieceY = 0;
  
  if (!isValidPosition(currentPieceX, currentPieceY, currentPiece)) {
    gameOver = true;
  }
}

function isValidPosition(x, y, piece) {
  for(let py = 0; py < piece.length; py++) {
    for(let px = 0; px < piece[py].length; px++) {
      if (piece[py][px]) {
        const newX = x + px;
        const newY = y + py;
        if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return false;
        if (newY >= 0 && board[newY][newX]) return false;
      }
    }
  }
  return true;
}

function rotatePiece() {
  const newPiece = [];
  for(let x = 0; x < currentPiece[0].length; x++) {
    newPiece[x] = [];
    for(let y = 0; y < currentPiece.length; y++) {
      newPiece[x][currentPiece.length - 1 - y] = currentPiece[y][x];
    }
  }
  
  // Try normal rotation
  if (isValidPosition(currentPieceX, currentPieceY, newPiece)) {
    currentPiece = newPiece;
    return;
  }
  
  // Try wall kicks
  for(let offset = 1; offset <= 2; offset++) {
    if (isValidPosition(currentPieceX - offset, currentPieceY, newPiece)) {
      currentPiece = newPiece;
      currentPieceX -= offset;
      return;
    }
    if (isValidPosition(currentPieceX + offset, currentPieceY, newPiece)) {
      currentPiece = newPiece;
      currentPieceX += offset;
      return;
    }
  }
}

function mergePiece() {
  for(let y = 0; y < currentPiece.length; y++) {
    for(let x = 0; x < currentPiece[y].length; x++) {
      if (currentPiece[y][x]) {
        const boardY = currentPieceY + y;
        if (boardY >= 0) {
          board[boardY][currentPieceX + x] = currentPieceType + 1;
        }
      }
    }
  }
}

function clearLines() {
  let linesCleared = 0;
  for(let y = BOARD_HEIGHT - 1; y >= 0; y--) {
    if (board[y].every(cell => cell > 0)) {
      board.splice(y, 1);
      board.unshift(Array(BOARD_WIDTH).fill(0));
      linesCleared++;
      y++;
    }
  }
  if (linesCleared > 0) {
    score += [40, 100, 300, 1200][linesCleared - 1];
    dropInterval = Math.max(100, 1000 - Math.floor(score/1000) * 100);
  }
}

function movePiece(dx, dy) {
  if (isValidPosition(currentPieceX + dx, currentPieceY + dy, currentPiece)) {
    currentPieceX += dx;
    currentPieceY += dy;
    return true;
  }
  return false;
}

function dropPiece() {
  if (!movePiece(0, 1)) {
    mergePiece();
    clearLines();
    spawnPiece();
  }
}

function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  if (!gameStarted) {
    ctx.fillStyle = '#fff';
    ctx.font = '30px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('TETRIS', canvas.width/2, canvas.height/3);
    ctx.font = '20px system-ui';
    ctx.fillText('Tap to Start', canvas.width/2, canvas.height/2);
    return;
  }
  
  // Draw board
  ctx.fillStyle = '#111';
  ctx.fillRect(BOARD_X - 1, BOARD_Y - 1, BLOCK_SIZE * BOARD_WIDTH + 2, BLOCK_SIZE * BOARD_HEIGHT + 2);
  
  // Draw fallen pieces
  for(let y = 0; y < BOARD_HEIGHT; y++) {
    for(let x = 0; x < BOARD_WIDTH; x++) {
      if (board[y][x]) {
        ctx.fillStyle = COLORS[board[y][x] - 1];
        ctx.fillRect(BOARD_X + x * BLOCK_SIZE, BOARD_Y + y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
      }
    }
  }
  
  // Draw current piece
  if (currentPiece) {
    ctx.fillStyle = COLORS[currentPieceType];
    for(let y = 0; y < currentPiece.length; y++) {
      for(let x = 0; x < currentPiece[y].length; x++) {
        if (currentPiece[y][x]) {
          ctx.fillRect(
            BOARD_X + (currentPieceX + x) * BLOCK_SIZE,
            BOARD_Y + (currentPieceY + y) * BLOCK_SIZE,
            BLOCK_SIZE - 1,
            BLOCK_SIZE - 1
          );
        }
      }
    }
  }
  
  // Draw score
  ctx.fillStyle = '#fff';
  ctx.font = '20px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText('Score: ' + score, 10, 30);
  
  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '30px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', canvas.width/2, canvas.height/3);
    ctx.font = '20px system-ui';
    ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2);
    ctx.fillText('Tap to Restart', canvas.width/2, canvas.height*2/3);
  }
}

function update(timestamp) {
  if (gameStarted && !gameOver) {
    if (timestamp - lastDrop > dropInterval) {
      dropPiece();
      lastDrop = timestamp;
    }
  }
  draw();
  requestAnimationFrame(update);
}

function startGame() {
  gameStarted = true;
  gameOver = false;
  score = 0;
  dropInterval = 1000;
  initBoard();
  spawnPiece();
  lastDrop = performance.now();
}

// Controls
document.getElementById('leftBtn').addEventListener('touchstart', function(e) {
  e.preventDefault();
  if (gameStarted && !gameOver) movePiece(-1, 0);
});

document.getElementById('rightBtn').addEventListener('touchstart', function(e) {
  e.preventDefault();
  if (gameStarted && !gameOver) movePiece(1, 0);
});

document.getElementById('downBtn').addEventListener('touchstart', function(e) {
  e.preventDefault();
  if (gameStarted && !gameOver) dropPiece();
});

document.getElementById('rotateBtn').addEventListener('touchstart', function(e) {
  e.preventDefault();
  if (gameStarted && !gameOver) rotatePiece();
});

// Keyboard controls
document.addEventListener('keydown', function(e) {
  if (gameStarted && !gameOver) {
    switch(e.key) {
      case 'ArrowLeft': movePiece(-1, 0); break;
      case 'ArrowRight': movePiece(1, 0); break;
      case 'ArrowDown': dropPiece(); break;
      case 'ArrowUp': rotatePiece(); break;
    }
  }
});

// Start/Restart game
canvas.addEventListener('click', function() {
  if (!gameStarted || gameOver) {
    startGame();
  }
});

requestAnimationFrame(update);
</script>
</body>
</html>
```