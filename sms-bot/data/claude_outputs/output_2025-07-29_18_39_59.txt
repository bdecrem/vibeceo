```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üåÄ Tetris</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
    body { background: linear-gradient(135deg, #1a1a2e, #16213e); color: white; font-family: sans-serif; height: 100vh; overflow: hidden; display: flex; flex-direction: column; }
    canvas { display: block; }
    #game-container { position: relative; flex: 1; }
    #controls { height: 120px; background: rgba(0,0,0,0.3); display: flex; justify-content: space-around; align-items: center; padding: 10px; }
    .btn { width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.2); border: 2px solid white; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; user-select: none; }
    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(10,10,20,0.9); z-index: 10; text-align: center; padding: 20px; }
    #intro-screen h1 { font-size: 48px; margin-bottom: 20px; }
    #intro-screen p { margin-bottom: 30px; max-width: 300px; line-height: 1.5; }
    #end-screen { display: none; }
    button { padding: 12px 24px; background: white; color: #16213e; border: none; border-radius: 30px; font-size: 18px; font-weight: bold; cursor: pointer; margin-top: 20px; }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
    <div id="intro-screen" class="screen">
      <h1>üåÄ Tetris</h1>
      <p>Stack the blocks. Clear the lines. Don't crash!</p>
      <button id="start-btn">‚ñ∂Ô∏è Play</button>
    </div>
    <div id="end-screen" class="screen">
      <h1>Game Over</h1>
      <p>Score: <span id="final-score">0</span></p>
      <button id="restart-btn">üîÅ Again</button>
    </div>
  </div>
  <div id="controls">
    <div class="btn" id="left-btn">‚¨ÖÔ∏è</div>
    <div class="btn" id="down-btn">‚¨áÔ∏è</div>
    <div class="btn" id="right-btn">‚û°Ô∏è</div>
    <div class="btn" id="rotate-btn">üîÑ</div>
  </div>

  <script>
    var canvas = document.getElementById('game');
    var ctx = canvas.getContext('2d');
    var introScreen = document.getElementById('intro-screen');
    var endScreen = document.getElementById('end-screen');
    var startBtn = document.getElementById('start-btn');
    var restartBtn = document.getElementById('restart-btn');
    var finalScoreEl = document.getElementById('final-score');

    var COLS = 10;
    var ROWS = 20;
    var blockSize, boardWidth, boardHeight, offsetX, offsetY;
    var score = 0;
    var dropInterval = 1000;
    var lastDropTime = 0;
    var gameOver = false;
    var gameRunning = false;

    var grid = [];
    var currentPiece = null;

    var tetrominoes = [
      { shape: [[1,1,1,1]], color: '#00f0f0' }, // I
      { shape: [[1,1],[1,1]], color: '#f0f000' }, // O
      { shape: [[0,1,0],[1,1,1]], color: '#a000f0' }, // T
      { shape: [[0,1,1],[1,1,0]], color: '#00f000' }, // S
      { shape: [[1,1,0],[0,1,1]], color: '#f00000' }, // Z
      { shape: [[1,0,0],[1,1,1]], color: '#0000f0' }, // J
      { shape: [[0,0,1],[1,1,1]], color: '#f0a000' }  // L
    ];

    function setupCanvas() {
      var controlsHeight = 120;
      var dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = (window.innerHeight - controlsHeight) * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = (window.innerHeight - controlsHeight) + 'px';
      ctx.scale(dpr, dpr);

      blockSize = Math.floor(Math.min(canvas.width, canvas.height) / Math.max(COLS, ROWS));
      boardWidth = blockSize * COLS;
      boardHeight = blockSize * ROWS;
      offsetX = (canvas.width / dpr - boardWidth) / 2;
      offsetY = (canvas.height / dpr - boardHeight) / 2;
    }

    function initGrid() {
      grid = [];
      for (var y = 0; y < ROWS; y++) {
        grid[y] = [];
        for (var x = 0; x < COLS; x++) {
          grid[y][x] = 0;
        }
      }
    }

    function createPiece() {
      var type = Math.floor(Math.random() * tetrominoes.length);
      return {
        shape: tetrominoes[type].shape,
        color: tetrominoes[type].color,
        x: Math.floor(COLS / 2) - 1,
        y: 0
      };
    }

    function isValidMove(piece, dx, dy, newShape) {
      var shape = newShape || piece.shape;
      for (var y = 0; y < shape.length; y++) {
        for (var x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            var newX = piece.x + x + dx;
            var newY = piece.y + y + dy;
            if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
            if (newY >= 0 && grid[newY][newX]) return false;
          }
        }
      }
      return true;
    }

    function rotatePiece(piece) {
      var newShape = [];
      var rows = piece.shape.length;
      var cols = piece.shape[0].length;
      for (var x = 0; x < cols; x++) {
        newShape[x] = [];
        for (var y = 0; y < rows; y++) {
          newShape[x][y] = piece.shape[rows - 1 - y][x];
        }
      }
      return newShape;
    }

    function placePiece() {
      for (var y = 0; y < currentPiece.shape.length; y++) {
        for (var x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            var gridY = currentPiece.y + y;
            if (gridY < 0) {
              gameOver = true;
              return;
            }
            grid[gridY][currentPiece.x + x] = currentPiece.color;
          }
        }
      }
      clearLines();
      currentPiece = createPiece();
      if (!isValidMove(currentPiece, 0, 0)) {
        gameOver = true;
      }
    }

    function clearLines() {
      var lines = 0;
      for (var y = ROWS - 1; y >= 0; y--) {
        var isLine = true;
        for (var x = 0; x < COLS; x++) {
          if (!grid[y][x]) {
            isLine = false;
            break;
          }
        }
        if (isLine) {
          lines++;
          for (var yy = y; yy > 0; yy--) {
            for (var x = 0; x < COLS; x++) {
              grid[yy][x] = grid[yy-1][x];
            }
          }
          y++;
        }
      }
      if (lines > 0) {
        score += lines * 100;
        dropInterval = Math.max(100, 1000 - Math.floor(score / 500) * 100);
      }
    }

    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(offsetX + x * blockSize, offsetY + y * blockSize, blockSize, blockSize);
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 1;
      ctx.strokeRect(offsetX + x * blockSize, offsetY + y * blockSize, blockSize, blockSize);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw board background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.fillRect(offsetX, offsetY, boardWidth, boardHeight);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(offsetX, offsetY, boardWidth, boardHeight);
      
      // Draw grid
      for (var y = 0; y < ROWS; y++) {
        for (var x = 0; x < COLS; x++) {
          if (grid[y][x]) {
            drawBlock(x, y, grid[y][x]);
          }
        }
      }
      
      // Draw current piece
      if (currentPiece) {
        for (var y = 0; y < currentPiece.shape.length; y++) {
          for (var x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color);
            }
          }
        }
      }
      
      // Draw score
      ctx.fillStyle = 'white';
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Score: ' + score, 20, 30);
    }

    function update(timestamp) {
      if (!gameRunning) return;
      
      if (timestamp - lastDropTime > dropInterval) {
        if (currentPiece && isValidMove(currentPiece, 0, 1)) {
          currentPiece.y++;
        } else {
          placePiece();
        }
        lastDropTime = timestamp;
      }
      
      draw();
      
      if (gameOver) {
        endGame();
      } else {
        requestAnimationFrame(update);
      }
    }

    function startGame() {
      setupCanvas();
      initGrid();
      score = 0;
      dropInterval = 1000;
      gameOver = false;
      gameRunning = true;
      currentPiece = createPiece();
      introScreen.style.display = 'none';
      endScreen.style.display = 'none';
      lastDropTime = 0;
      requestAnimationFrame(update);
    }

    function endGame() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      endScreen.style.display = 'flex';
    }

    // Controls
    document.getElementById('left-btn').addEventListener('click', function() {
      if (currentPiece && isValidMove(currentPiece, -1, 0)) currentPiece.x--;
    });
    
    document.getElementById('right-btn').addEventListener('click', function() {
      if (currentPiece && isValidMove(currentPiece, 1, 0)) currentPiece.x++;
    });
    
    document.getElementById('down-btn').addEventListener('click', function() {
      if (currentPiece && isValidMove(currentPiece, 0, 1)) currentPiece.y++;
    });
    
    document.getElementById('rotate-btn').addEventListener('click', function() {
      if (currentPiece) {
        var newShape = rotatePiece(currentPiece);
        if (isValidMove(currentPiece, 0, 0, newShape)) {
          currentPiece.shape = newShape;
        }
      }
    });

    // Keyboard controls
    document.addEventListener('keydown', function(e) {
      if (!gameRunning) return;
      if (e.keyCode === 37) { // left
        if (currentPiece && isValidMove(currentPiece, -1, 0)) currentPiece.x--;
      } else if (e.keyCode === 39) { // right
        if (currentPiece && isValidMove(currentPiece, 1, 0)) currentPiece.x++;
      } else if (e.keyCode === 40) { // down
        if (currentPiece && isValidMove(currentPiece, 0, 1)) currentPiece.y++;
      } else if (e.keyCode === 38) { // up (rotate)
        if (currentPiece) {
          var newShape = rotatePiece(currentPiece);
          if (isValidMove(currentPiece, 0, 0, newShape)) {
            currentPiece.shape = newShape;
          }
        }
      }
    });

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);

    window.addEventListener('resize', function() {
      if (gameRunning) {
        setupCanvas();
        draw();
      }
    });

    setupCanvas();
  </script>
</body>
</html>
```