# Tetris Game Implementation

I've created a complete, mobile-first Tetris game with responsive design and touch controls. The game features all the classic Tetris mechanics with a clean, modern interface that works on both mobile and desktop.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        #gameCanvas {
            display: block;
            background: #0f3460;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        
        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: rgba(15, 52, 96, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 10px;
            z-index: 1000;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            font-size: 28px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }
        
        #leftBtn {
            background: linear-gradient(145deg, #ff6b6b, #ff8e8e);
        }
        
        #rightBtn {
            background: linear-gradient(145deg, #ff6b6b, #ff8e8e);
        }
        
        #rotateBtn {
            background: linear-gradient(145deg, #4ecdc4, #6fffe9);
        }
        
        #downBtn {
            background: linear-gradient(145deg, #ffd166, #ffe18f);
        }
        
        .game-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        
        .game-title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 2px;
        }
        
        .next-piece {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
        }
        
        #nextCanvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="game-title">TETRIS</div>
    
    <div class="game-info">
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Lines: <span id="lines">0</span></div>
    </div>
    
    <div class="next-piece">
        Next:
        <canvas id="nextCanvas" width="100" height="100"></canvas>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="controls">
        <div id="leftBtn" class="control-btn">←</div>
        <div id="rotateBtn" class="control-btn">↻</div>
        <div id="rightBtn" class="control-btn">→</div>
        <div id="downBtn" class="control-btn">↓</div>
    </div>

    <script>
        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const controlsHeight = 120;
        const canvasDisplayWidth = Math.min(window.innerWidth, 500);
        const canvasDisplayHeight = window.innerHeight - controlsHeight;
        const blockSizeX = Math.floor(canvasDisplayWidth / COLS);
        const blockSizeY = Math.floor(canvasDisplayHeight / ROWS);
        const blockSize = Math.min(blockSizeX, blockSizeY);
        const boardWidth = blockSize * COLS;
        const boardHeight = blockSize * ROWS;
        const offsetX = (canvasDisplayWidth - boardWidth) / 2;
        const offsetY = (canvasDisplayHeight - boardHeight) / 2;
        
        // Tetromino colors
        const COLORS = [
            null,
            '#FF0D72', // I - Pink
            '#0DC2FF', // J - Blue
            '#0DFF72', // L - Green
            '#F538FF', // O - Purple
            '#FF8E0D', // S - Orange
            '#FFE138', // T - Yellow
            '#3877FF'  // Z - Light Blue
        ];
        
        // Tetromino shapes
        const SHAPES = [
            [],
            [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
            [[2,0,0], [2,2,2], [0,0,0]],                   // J
            [[0,0,3], [3,3,3], [0,0,0]],                   // L
            [[4,4], [4,4]],                                // O
            [[0,5,5], [5,5,0], [0,0,0]],                   // S
            [[0,6,0], [6,6,6], [0,0,0]],                   // T
            [[7,7,0], [0,7,7], [0,0,0]]                    // Z
        ];
        
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const nextCanvas = document.getElementById('nextCanvas');
        const ctx = canvas.getContext('2d');
        const nextCtx = nextCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        
        // Set canvas sizes
        canvas.width = canvasDisplayWidth;
        canvas.height = canvasDisplayHeight;
        nextCanvas.width = 100;
        nextCanvas.height = 100;
        
        // Game state
        let score = 0;
        let level = 1;
        let lines = 0;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let gameOver = false;
        
        // Create the arena
        const arena = createMatrix(COLS, ROWS);
        
        // Create the player
        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            type: null,
            score: 0
        };
        
        // Create next piece
        let nextPiece = {
            matrix: null,
            type: null
        };
        
        // Initialize the game
        resetGame();
        initNextPiece();
        
        // Game loop
        function gameLoop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }
            
            draw();
            if (!gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Create matrix
        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }
        
        // Create a piece
        function createPiece(type) {
            return SHAPES[type].map(row => [...row]);
        }
        
        // Draw the game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw board background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fillRect(offsetX, offsetY, boardWidth, boardHeight);
            
            // Draw board border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(offsetX, offsetY, boardWidth, boardHeight);
            
            // Draw arena
            drawMatrix(arena, {x: 0, y: 0});
            
            // Draw player
            drawMatrix(player.matrix, player.pos);
            
            // Draw next piece
            drawNextPiece();
            
            // Draw game over
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);
                
                ctx.font = '20px Arial';
                ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
                ctx.fillText('Tap to restart', canvas.width / 2, canvas.height / 2 + 60);
            }
        }
        
        // Draw matrix
        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(
                            offsetX + (x + offset.x) * blockSize,
                            offsetY + (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            offsetX + (x + offset.x) * blockSize,
                            offsetY + (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                    }
                });
            });
        }
        
        // Draw next piece
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            nextCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (nextPiece.matrix) {
                const offsetX = (nextCanvas.width - nextPiece.matrix[0].length * 20) / 2;
                const offsetY = (nextCanvas.height - nextPiece.matrix.length * 20) / 2;
                
                nextPiece.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            nextCtx.fillStyle = COLORS[value];
                            nextCtx.fillRect(
                                offsetX + x * 20,
                                offsetY + y * 20,
                                20,
                                20
                            );
                            
                            nextCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            nextCtx.lineWidth = 1;
                            nextCtx.strokeRect(
                                offsetX + x * 20,
                                offsetY + y * 20,
                                20,
                                20
                            );
                        }
                    });
                });
            }
        }
        
        // Collision detection
        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                        (arena[y + o.y] &&
                        arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Merge player with arena
        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }
        
        // Rotate matrix
        function rotate(matrix) {
            const N = matrix.length;
            const result = [];
            
            for (let i = 0; i < N; i++) {
                result.push(new Array(N).fill(0));
            }
            
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < N; x++) {
                    result[x][N - 1 - y] = matrix[y][x];
                }
            }
            
            return result;
        }
        
        // Player rotation
        function playerRotate() {
            if (gameOver) return;
            
            const pos = player.pos.x;
            let offset = 1;
            player.matrix = rotate(player.matrix);
            
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    player.matrix = rotate(rotate(rotate(player.matrix)));
                    player.pos.x = pos;
                    return;
                }
            }
        }
        
        // Player movement
        function playerMove(dir) {
            if (gameOver) return;
            
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
            }
        }
        
        // Player drop
        function playerDrop() {
            if (gameOver) return;
            
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }
        
        // Hard drop
        function playerHardDrop() {
            if (gameOver) return;
            
            while (!collide(arena, player)) {
                player.pos.y++;
            }
            player.pos.y--;
            merge(arena, player);
            playerReset();
            arenaSweep();
            updateScore();
        }
        
        // Reset player
        function playerReset() {
            // Use the next piece
            player.matrix = nextPiece.matrix;
            player.type = nextPiece.type;
            
            // Create new next piece
            initNextPiece();
            
            // Reset position
            player.pos.y = 0;
            player.pos.x = Math.floor(arena[0].length / 2) - Math.floor(player.matrix[0].length / 2);
            
            // Check for game over
            if (collide(arena, player)) {
                gameOver = true;
                canvas.addEventListener('click', resetGame);
            }
        }
        
        // Initialize next piece
        function initNextPiece() {
            const type = Math.floor(Math.random() * 7) + 1;
            nextPiece.matrix = createPiece(type);
            nextPiece.type = type;
        }
        
        // Sweep arena
        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = arena.length - 1; y >= 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }
                
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                
                rowCount++;
            }
            
            // Update lines and level
            lines += rowCount;
            level = Math.floor(lines / 10) + 1;
            dropInterval = 1000 - (level - 1) * 100;
            if (dropInterval < 100) dropInterval = 100;
        }
        
        // Update score
        function updateScore() {
            const linePoints = [0, 40, 100, 300, 1200];
            const rowCount = lines % 10 || 10;
            score += linePoints[rowCount] * level;
            
            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesElement.textContent = lines;
        }
        
        // Reset game
        function resetGame() {
            // Reset arena
            arena.forEach(row => row.fill(0));
            
            // Reset score
            score = 0;
            level = 1;
            lines = 0;
            dropInterval = 1000;
            
            // Reset player
            player.pos.x = 0;
            player.pos.y = 0;
            player.matrix = null;
            player.type = null;
            
            // Reset next piece
            initNextPiece();
            
            // Reset game state
            gameOver = false;
            canvas.removeEventListener('click', resetGame);
            
            // Update UI
            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesElement.textContent = lines;
            
            // Start new game
            playerReset();
            requestAnimationFrame(gameLoop);
        }
        
        // Add button handlers
        function addButtonHandler(buttonId, action) {
            const btn = document.getElementById(buttonId);
            
            // Handle touch events (mobile)
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                action();
            });
            
            // Handle click events (desktop)  
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                action();
            });
        }
        
        // Apply to all game buttons
        addButtonHandler('leftBtn', () => playerMove(-1));
        addButtonHandler('rightBtn', () => playerMove(1));
        addButtonHandler('rotateBtn', playerRotate);
        addButtonHandler('downBtn', playerHardDrop);
        
        // Keyboard controls for desktop
        document.addEventListener('keydown', event => {
            if (event.keyCode === 37) { // Left arrow
                playerMove(-1);
            } else if (event.keyCode === 39) { // Right arrow
                playerMove(1);
            } else if (event.keyCode === 40) { // Down arrow
                playerDrop();
            } else if (event.keyCode === 38) { // Up arrow
                playerRotate();
            } else if (event.keyCode === 32) { // Space
                playerHardDrop();
            }
        });
    </script>
</body>
</html>
```

## Features of this Tetris Implementation:

1. **Mobile-First Design**:
   - Responsive layout that adapts to any screen size
   - Touch-friendly controls with large buttons
   - Optimized for both portrait and landscape orientations

2. **Complete Game Mechanics**:
   - All 7 classic Tetris pieces with correct rotations
   - Line clearing and scoring system
   - Increasing difficulty levels
   - Next piece preview
   - Game over detection and restart

3. **Visual Design**:
   - Modern color scheme with vibrant piece colors
   - Clean, intuitive interface
   - Visual feedback for controls
   - Game information display (score, level, lines)

4. **Controls**:
   - Four directional buttons at the bottom of the screen
   - Works with both touch and mouse input
   - Keyboard support for desktop play

5. **Performance**:
   - Efficient rendering using canvas
   - Smooth game loop with requestAnimationFrame
   - Optimized collision detection

To play the game, simply open the HTML file in any browser. On mobile, use the on-screen controls. On desktop, you can use arrow keys or the on-screen buttons.