```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>WTAF Tetris - Chaos Blocks</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Orbitron:wght@400;700&display=swap');

        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #FF2E93 0%, #7C3AED 50%, #3F88FF 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease-in-out infinite;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 90vw;
        }

        .game-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            color: #00FFC6;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 0 20px;
            font-size: 14px;
        }

        #gameCanvas {
            display: block;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(0,255,198,0.5);
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(123,58,237,0.4);
            touch-action: none;
        }

        .control-legend {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(0,255,198,0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #00FFC6;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .control-legend h4 {
            margin: 0 0 10px 0;
            color: #FF2E93;
        }

        .mobile-controls {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            border: 1px solid rgba(0,255,198,0.2);
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-controls {
                display: flex;
            }
        }

        .control-layout {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 350px;
            gap: 30px;
        }

        .dpad-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 8px;
            width: 140px;
            height: 140px;
        }

        .dpad-container .control-button {
            border-radius: 8px;
        }

        .dpad-container .control-button:nth-child(1) { grid-column: 2; grid-row: 1; }
        .dpad-container .control-button:nth-child(2) { grid-column: 1; grid-row: 2; }
        .dpad-container .control-button:nth-child(3) { grid-column: 3; grid-row: 2; }
        .dpad-container .control-button:nth-child(4) { grid-column: 2; grid-row: 3; }

        .action-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .action-row {
            display: flex;
            gap: 15px;
        }

        .control-button {
            background: linear-gradient(135deg, #00FFC6, #57E2E5);
            border: none;
            border-radius: 12px;
            width: 55px;
            height: 55px;
            font-size: 16px;
            color: #000;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,255,198,0.4);
            touch-action: manipulation;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            font-size: 11px;
            transition: all 0.1s ease;
        }

        .control-button:active {
            transform: scale(0.92);
            box-shadow: 0 2px 8px rgba(0,255,198,0.6);
        }

        .control-button.action-button {
            background: linear-gradient(135deg, #FF2E93, #FF61C7);
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
        }

        .control-button.pause-button {
            background: linear-gradient(135deg, #7C3AED, #A855F7);
            color: white;
            width: 50px;
            height: 35px;
            border-radius: 8px;
            font-size: 10px;
        }

        .restart-button {
            background: linear-gradient(135deg, #FF2E93, #FF61C7);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            margin: 20px 0;
            font-size: 14px;
            display: none;
        }

        .restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,46,147,0.5);
        }

        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #FF2E93;
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #FF2E93;
            text-align: center;
            font-size: 24px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: none;
            z-index: 1000;
        }

        .game-over-screen h2 {
            margin: 0 0 20px 0;
            font-size: 32px;
            text-shadow: 0 0 20px #FF2E93;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-ui">
            <div class="score">CHAOS BLOCKS: <span id="score">0</span></div>
            <div class="level">LEVEL: <span id="level">1</span></div>
            <div class="high-score">BEST: <span id="highScore">0</span></div>
        </div>

        <canvas id="gameCanvas" width="400" height="600"></canvas>

        <div class="control-legend">
            <h4>üéÆ CHAOS CONTROLS</h4>
            <div>‚Üê‚Üí: Move ‚Ä¢ ‚Üì: Drop ‚Ä¢ ‚Üë/SPACE: Rotate ‚Ä¢ P: Pause</div>
        </div>

        <div class="mobile-controls">
            <div class="control-layout">
                <div class="dpad-container">
                    <button class="control-button" id="upBtn">‚Üë</button>
                    <button class="control-button" id="leftBtn">‚Üê</button>
                    <button class="control-button" id="rightBtn">‚Üí</button>
                    <button class="control-button" id="downBtn">‚Üì</button>
                </div>

                <div class="action-container">
                    <div class="action-row">
                        <button class="control-button action-button" id="rotateBtn">‚ü≤</button>
                    </div>
                    <div class="action-row">
                        <button class="control-button pause-button" id="pauseBtn">‚è∏</button>
                    </div>
                </div>
            </div>
        </div>

        <button class="restart-button" onclick="restartGame()" id="restartBtn">
            üîÑ RESTART CHAOS
        </button>

        <div class="game-over-screen" id="gameOverScreen">
            <h2>REALITY GLITCHED üí•</h2>
            <div id="finalScore">FINAL SCORE: 0</div>
            <div style="margin-top: 20px; font-size: 16px;">Click to restart chaos...</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const highScoreElement = document.getElementById('highScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartBtn = document.getElementById('restartBtn');
        const finalScoreElement = document.getElementById('finalScore');

        // Game variables
        let gameState = 'playing';
        let score = 0;
        let level = 1;
        let lines = 0;
        let dropTime = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let highScore = localStorage.getItem('tetrisHighScore') || 0;

        // Game grid
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;
        let board = [];

        // Particle system
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            createExplosion(x, y, color = '#00FFC6') {
                for(let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: x * BLOCK_SIZE + BLOCK_SIZE/2,
                        y: y * BLOCK_SIZE + BLOCK_SIZE/2,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30,
                        color: color
                    });
                }
            }

            createLineClear(y) {
                for(let x = 0; x < BOARD_WIDTH; x++) {
                    this.createExplosion(x, y, '#FF2E93');
                }
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    return p.life > 0;
                });
            }

            render() {
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life / 30;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 4, 4);
                });
                ctx.globalAlpha = 1;
            }
        }

        const particles = new ParticleSystem();

        // Screen shake
        let screenShake = { intensity: 0, duration: 0 };

        function addScreenShake(intensity, duration) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }

        function updateScreenShake() {
            if (screenShake.duration > 0) {
                const shakeX = (Math.random() - 0.5) * screenShake.intensity;
                const shakeY = (Math.random() - 0.5) * screenShake.intensity;
                canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                screenShake.duration--;
                screenShake.intensity *= 0.95;
            } else {
                canvas.style.transform = 'translate(0, 0)';
            }
        }

        // Tetris pieces
        const PIECES = [
            // I piece
            [
                [1,1,1,1]
            ],
            // O piece
            [
                [1,1],
                [1,1]
            ],
            // T piece
            [
                [0,1,0],
                [1,1,1]
            ],
            // S piece
            [
                [0,1,1],
                [1,1,0]
            ],
            // Z piece
            [
                [1,1,0],
                [0,1,1]
            ],
            // J piece
            [
                [1,0,0],
                [1,1,1]
            ],
            // L piece
            [
                [0,0,1],
                [1,1,1]
            ]
        ];

        const PIECE_COLORS = ['#00FFC6', '#FF2E93', '#3F88FF', '#7C3AED', '#57E2E5', '#FF61C7', '#A855F7'];

        // Current piece
        let currentPiece = {
            shape: null,
            x: 0,
            y: 0,
            color: '#00FFC6'
        };

        // Initialize game
        function initializeGame() {
            // Initialize board
            board = [];
            for(let y = 0; y < BOARD_HEIGHT; y++) {
                board[y] = [];
                for(let x = 0; x < BOARD_WIDTH; x++) {
                    board[y][x] = 0;
                }
            }

            // Reset game state
            score = 0;
            level = 1;
            lines = 0;
            dropTime = 0;
            dropInterval = 1000;
            gameState = 'playing';

            // Update UI
            updateUI();
            spawnPiece();

            // Hide game over screen
            gameOverScreen.style.display = 'none';
            restartBtn.style.display = 'none';
        }

        function spawnPiece() {
            const pieceIndex = Math.floor(Math.random() * PIECES.length);
            currentPiece.shape = PIECES[pieceIndex];
            currentPiece.color = PIECE_COLORS[pieceIndex];
            currentPiece.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentPiece.y = 0;

            // Check if game over
            if (isColliding(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                gameOver();
            }
        }

        function isColliding(shape, x, y) {
            for(let py = 0; py < shape.length; py++) {
                for(let px = 0; px < shape[py].length; px++) {
                    if(shape[py][px] && (
                        x + px < 0 ||
                        x + px >= BOARD_WIDTH ||
                        y + py >= BOARD_HEIGHT ||
                        (y + py >= 0 && board[y + py][x + px])
                    )) {
                        return true;
                    }
                }
            }
            return false;
        }

        function placePiece() {
            for(let py = 0; py < currentPiece.shape.length; py++) {
                for(let px = 0; px < currentPiece.shape[py].length; px++) {
                    if(currentPiece.shape[py][px] && currentPiece.y + py >= 0) {
                        board[currentPiece.y + py][currentPiece.x + px] = currentPiece.color;
                    }
                }
            }

            clearLines();
            spawnPiece();
        }

        function clearLines() {
            let linesCleared = 0;
            
            for(let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                let fullLine = true;
                for(let x = 0; x < BOARD_WIDTH; x++) {
                    if(!board[y][x]) {
                        fullLine = false;
                        break;
                    }
                }

                if(fullLine) {
                    // Create particles for line clear
                    particles.createLineClear(y);
                    addScreenShake(8, 10);

                    // Remove the line
                    board.splice(y, 1);
                    board.unshift(new Array(BOARD_WIDTH).fill(0));
                    linesCleared++;
                    y++; // Check the same line again
                }
            }

            if(linesCleared > 0) {
                lines += linesCleared;
                score += linesCleared * 100 * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(50, 1000 - (level - 1) * 50);
                updateUI();
            }
        }

        function rotatePiece() {
            const rotated = currentPiece.shape[0].map((_, i) =>
                currentPiece.shape.map(row => row[i]).reverse()
            );

            if(!isColliding(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.shape = rotated;
            }
        }

        function movePiece(dx, dy) {
            if(!isColliding(currentPiece.shape, currentPiece.x + dx, currentPiece.y + dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                return true;
            }
            return false;
        }

        function dropPiece() {
            if(!movePiece(0, 1)) {
                placePiece();
            }
        }

        function hardDrop() {
            while(movePiece(0, 1)) {
                score += 2;
            }
            placePiece();
            updateUI();
        }

        function update(time) {
            if(gameState !== 'playing') return;

            const deltaTime = time - lastTime;
            lastTime = time;

            dropTime += deltaTime;
            if(dropTime > dropInterval) {
                dropPiece();
                dropTime = 0;
            }

            particles.update();
            updateScreenShake();
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid background
            ctx.strokeStyle = 'rgba(0,255,198,0.1)';
            ctx.lineWidth = 1;
            for(let x = 0; x <= BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE + 50, 50);
                ctx.lineTo(x * BLOCK_SIZE + 50, BOARD_HEIGHT * BLOCK_SIZE + 50);
                ctx.stroke();
            }
            for(let y = 0; y <= BOARD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(50, y * BLOCK_SIZE + 50);
                ctx.lineTo(BOARD_WIDTH * BLOCK_SIZE + 50, y * BLOCK_SIZE + 50);
                ctx.stroke();
            }

            // Draw placed pieces
            for(let y = 0; y < BOARD_HEIGHT; y++) {
                for(let x = 0; x < BOARD_WIDTH; x++) {
                    if(board[y][x]) {
                        ctx.fillStyle = board[y][x];
                        ctx.fillRect(x * BLOCK_SIZE + 50, y * BLOCK_SIZE + 50, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        
                        // Add glow effect
                        ctx.shadowColor = board[y][x];
                        ctx.shadowBlur = 10;
                        ctx.fillRect(x * BLOCK_SIZE + 50, y * BLOCK_SIZE + 50, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Draw current piece
            if(currentPiece.shape) {
                ctx.fillStyle = currentPiece.color;
                ctx.shadowColor = currentPiece.color;
                ctx.shadowBlur = 15;
                
                for(let py = 0; py < currentPiece.shape.length; py++) {
                    for(let px = 0; px < currentPiece.shape[py].length; px++) {
                        if(currentPiece.shape[py][px]) {
                            const x = (currentPiece.x + px) * BLOCK_SIZE + 50;
                            const y = (currentPiece.y + py) * BLOCK_SIZE + 50;
                            ctx.fillRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    }
                }
                ctx.shadowBlur = 0;
            }

            // Draw particles
            particles.render();
        }

        function gameLoop(time) {
            update(time);
            render();
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            scoreElement.textContent = score;
            levelElement.textContent = level;
            highScoreElement.textContent = highScore;
        }

        function gameOver() {
            gameState = 'gameOver';
            
            if(score > highScore) {
                highScore = score;
                localStorage.setItem('tetrisHighScore', highScore);
                updateUI();
            }

            finalScoreElement.textContent = `FINAL SCORE: ${score}`;
            gameOverScreen.style.display = 'block';
            restartBtn.style.display = 'block';

            addScreenShake(15, 30);
        }

        function restartGame() {
            initializeGame();
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if(gameState !== 'playing') {
                if(e.code === 'Space' || e.code === 'Enter') {
                    restartGame();
                }
                return;
            }

            switch(e.code) {
                case 'ArrowLeft':
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    dropPiece();
                    score += 1;
                    updateUI();
                    break;
                case 'ArrowUp':
                case 'Space':
                    rotatePiece();
                    break;
                case 'KeyP':
                    gameState = gameState === 'playing' ? 'paused' : 'playing';
                    break;
            }
        });

        // Mobile controls
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(gameState === 'playing') movePiece(-1, 0);
        });

        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(gameState === 'playing') movePiece(1, 0);
        });

        document.getElementById('downBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(gameState === 'playing') {
                dropPiece();
                score += 1;
                updateUI();
            }
        });

        document.getElementById('upBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(gameState === 'playing') rotatePiece();
        });

        document.getElementById('rotateBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(gameState === 'playing') rotatePiece();
        });

        document.getElementById('pauseBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState = gameState === 'playing' ? 'paused' : 'playing';
        });

        // Game over screen click to restart
        gameOverScreen.addEventListener('click', () => {
            restartGame();
        });

        // Touch controls for swipe
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if(gameState !== 'playing') return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if(Math.abs(deltaX) > Math.abs(deltaY)) {
                if(deltaX > 30) {
                    movePiece(1, 0);
                } else if(deltaX < -30) {
                    movePiece(-1, 0);
                }
            } else {
                if(deltaY > 30) {
                    dropPiece();
                    score += 1;
                    updateUI();
                } else if(deltaY < -30) {
                    rotatePiece();
                }
            }
        });

        // Initialize and start game
        highScoreElement.textContent = highScore;
        initializeGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
```