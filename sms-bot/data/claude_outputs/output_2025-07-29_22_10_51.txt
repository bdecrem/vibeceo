Here's a mobile-friendly Asteroids game with touch controls and particle effects:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Rocks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            touch-action: none;
            background: black;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        .ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
            text-shadow: 2px 2px 2px black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui">Score: <span id="score">0</span></div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');

// Set canvas size
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game state
const game = {
    score: 0,
    lives: 3,
    asteroids: [],
    bullets: [],
    particles: [],
    touchStart: null,
    isShooting: false
};

// Ship object
const ship = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: 15,
    angle: 0,
    thrust: { x: 0, y: 0 },
    maxSpeed: 5,
    friction: 0.99
};

// Object pools
const POOL_SIZE = 100;
const bulletPool = Array(POOL_SIZE).fill().map(() => ({ active: false, x: 0, y: 0, dx: 0, dy: 0 }));
const particlePool = Array(POOL_SIZE).fill().map(() => ({ active: false, x: 0, y: 0, dx: 0, dy: 0, life: 0 }));

// Get inactive object from pool
function getFromPool(pool) {
    return pool.find(obj => !obj.active) || null;
}

// Create asteroid
function createAsteroid(x, y, size) {
    const speed = 1 + Math.random() * 2;
    const angle = Math.random() * Math.PI * 2;
    return {
        x: x || Math.random() * canvas.width,
        y: y || Math.random() * canvas.height,
        dx: Math.cos(angle) * speed,
        dy: Math.sin(angle) * speed,
        radius: size || 40,
        vertices: Array(8).fill().map(() => ({
            radius: (size || 40) * (0.8 + Math.random() * 0.4),
            angle: Math.random() * Math.PI * 2
        }))
    };
}

// Initialize game
function initGame() {
    game.asteroids = [];
    for (let i = 0; i < 5; i++) {
        game.asteroids.push(createAsteroid());
    }
}

// Handle touch input
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    game.touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    game.isShooting = true;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (game.touchStart) {
        const touch = e.touches[0];
        const dx = touch.clientX - game.touchStart.x;
        const dy = touch.clientY - game.touchStart.y;
        ship.angle = Math.atan2(dy, dx);
        
        // Apply thrust
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > 50) {
            ship.thrust.x += Math.cos(ship.angle) * 0.5;
            ship.thrust.y += Math.sin(ship.angle) * 0.5;
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    game.touchStart = null;
    game.isShooting = false;
});

// Shoot bullet
function shoot() {
    const bullet = getFromPool(bulletPool);
    if (bullet) {
        bullet.active = true;
        bullet.x = ship.x + Math.cos(ship.angle) * ship.radius;
        bullet.y = ship.y + Math.sin(ship.angle) * ship.radius;
        bullet.dx = Math.cos(ship.angle) * 10;
        bullet.dy = Math.sin(ship.angle) * 10;
    }
}

// Create particle effect
function createParticles(x, y, count) {
    for (let i = 0; i < count; i++) {
        const particle = getFromPool(particlePool);
        if (particle) {
            particle.active = true;
            particle.x = x;
            particle.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;
            particle.dx = Math.cos(angle) * speed;
            particle.dy = Math.sin(angle) * speed;
            particle.life = 1;
        }
    }
}

// Update game state
function update() {
    // Update ship position
    ship.thrust.x *= ship.friction;
    ship.thrust.y *= ship.friction;
    ship.x += ship.thrust.x;
    ship.y += ship.thrust.y;
    
    // Wrap ship around screen
    if (ship.x < 0) ship.x = canvas.width;
    if (ship.x > canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = canvas.height;
    if (ship.y > canvas.height) ship.y = 0;

    // Shoot if touching
    if (game.isShooting && game.frameCount % 10 === 0) {
        shoot();
    }

    // Update bullets
    bulletPool.forEach(bullet => {
        if (bullet.active) {
            bullet.x += bullet.dx;
            bullet.y += bullet.dy;
            
            // Deactivate bullets off screen
            if (bullet.x < 0 || bullet.x > canvas.width || 
                bullet.y < 0 || bullet.y > canvas.height) {
                bullet.active = false;
            }
        }
    });

    // Update asteroids
    game.asteroids.forEach(asteroid => {
        asteroid.x += asteroid.dx;
        asteroid.y += asteroid.dy;
        
        // Wrap asteroids around screen
        if (asteroid.x < 0) asteroid.x = canvas.width;
        if (asteroid.x > canvas.width) asteroid.x = 0;
        if (asteroid.y < 0) asteroid.y = canvas.height;
        if (asteroid.y > canvas.height) asteroid.y = 0;
    });

    // Update particles
    particlePool.forEach(particle => {
        if (particle.active) {
            particle.x += particle.dx;
            particle.y += particle.dy;
            particle.life -= 0.02;
            if (particle.life <= 0) {
                particle.active = false;
            }
        }
    });

    // Check bullet-asteroid collisions
    bulletPool.forEach(bullet => {
        if (bullet.active) {
            game.asteroids.forEach((asteroid, i) => {
                const dx = bullet.x - asteroid.x;
                const dy = bullet.y - asteroid.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < asteroid.radius) {
                    bullet.active = false;
                    createParticles(asteroid.x, asteroid.y, 10);
                    
                    // Split asteroid
                    if (asteroid.radius > 20) {
                        game.asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.radius / 2));
                        game.asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.radius / 2));
                    }
                    
                    game.asteroids.splice(i, 1);
                    game.score += 100;
                    scoreElement.textContent = game.score;
                }
            });
        }
    });
}

// Render game
function render() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw ship
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.angle);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ship.radius, 0);
    ctx.lineTo(-ship.radius, ship.radius / 2);
    ctx.lineTo(-ship.radius, -ship.radius / 2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();

    // Draw bullets
    ctx.fillStyle = 'white';
    bulletPool.forEach(bullet => {
        if (bullet.active) {
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    // Draw asteroids
    ctx.strokeStyle = 'white';
    game.asteroids.forEach(asteroid => {
        ctx.beginPath();
        asteroid.vertices.forEach((vertex, i) => {
            const angle = vertex.angle + Math.atan2(asteroid.dy, asteroid.dx);
            const x = asteroid.x + Math.cos(angle) * vertex.radius;
            const y = asteroid.y + Math.sin(angle) * vertex.radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.stroke();
    });

    // Draw particles
    ctx.fillStyle = 'white';
    particlePool.forEach(particle => {
        if (particle.active) {
            ctx.globalAlpha = particle.life;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    ctx.globalAlpha = 1;
}

// Game loop
let lastTime = 0;
game.frameCount = 0;

function gameLoop(timestamp) {
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    game.frameCount++;

    update(deltaTime);
    render();
    requestAnimationFrame(gameLoop);
}

// Start game
initGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
```

This Asteroids game features:

1. Touch controls:
   - Touch and drag to control ship direction and thrust
   - Hold touch to continuously shoot

2. Game mechanics:
   - Ship movement with momentum and friction
   - Asteroids split into smaller pieces when shot
   - Wrapping around screen edges
   - Score tracking
   - Particle effects for explosions

3. Performance optimizations:
   - Object pooling for bullets and particles
   - Efficient collision detection
   - Viewport culling

4. Mobile-friendly features:
   - Responsive canvas sizing
   - Touch event handling with preventDefault()
   - Visual feedback for controls
   - Appropriate object sizes for mobile screens

To play:
1. Touch and drag to move the ship
2. The ship will face the direction of your touch
3. Dragging far from the touch point applies thrust
4. The ship automatically fires while touching
5. Destroy asteroids to score points
6. Large asteroids split into smaller ones when destroyed

The game automatically adjusts to your screen size and works well on both portrait and landscape orientations.