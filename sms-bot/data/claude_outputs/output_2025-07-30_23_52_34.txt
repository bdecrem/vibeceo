I'll create a mobile-friendly Tetris game with touch controls and keyboard support. The game will follow the standard Tetris rules with a properly sized board that doesn't overlap with controls.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        
        #gameCanvas {
            display: block;
            background: #111;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            display: flex;
            justify-content: space-between;
        }
        
        .control-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            border-top: 2px solid #444;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: #444;
            border: 2px solid #666;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            touch-action: none;
        }
        
        .control-btn:active {
            background: #666;
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
    </div>
    <div class="control-bar">
        <div class="control-btn" id="leftBtn">←</div>
        <div class="control-btn" id="rotateBtn">↻</div>
        <div class="control-btn" id="downBtn">↓</div>
        <div class="control-btn" id="rightBtn">→</div>
    </div>
    
    <script>
        // Constants
        const ROWS = 20;
        const COLS = 10;
        const CONTROL_BAR_HEIGHT = 80;
        const TOP_UI_HEIGHT = 50;
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Tetromino shapes
        const SHAPES = [
            [[1,1,1,1]], // I
            [[1,1,1],[0,1,0]], // T
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]], // J
            [[1,1],[1,1]], // O
            [[1,1,0],[0,1,1]], // S
            [[0,1,1],[1,1,0]] // Z
        ];
        
        const COLORS = [
            '#00f0f0', // cyan
            '#a000f0', // purple
            '#f0a000', // orange
            '#0000f0', // blue
            '#f0f000', // yellow
            '#00f000', // green
            '#f00000'  // red
        ];
        
        // Game state
        let game = {
            board: Array(ROWS).fill().map(() => Array(COLS).fill(0)),
            score: 0,
            level: 1,
            current: null,
            currentX: 0,
            currentY: 0,
            currentShape: 0,
            isPlaying: false,
            dropInterval: 1000,
            lastDrop: 0
        };
        
        // Sizing calculations
        function resizeCanvas() {
            const AVAILABLE_HEIGHT = window.innerHeight - CONTROL_BAR_HEIGHT - TOP_UI_HEIGHT;
            const BLOCK_SIZE = Math.floor(Math.min(
                AVAILABLE_HEIGHT / ROWS,
                window.innerWidth / COLS
            ));
            
            game.blockSize = BLOCK_SIZE;
            game.boardWidth = BLOCK_SIZE * COLS;
            game.boardHeight = BLOCK_SIZE * ROWS;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - CONTROL_BAR_HEIGHT;
            
            game.boardX = (canvas.width - game.boardWidth) / 2;
            game.boardY = TOP_UI_HEIGHT + ((canvas.height - TOP_UI_HEIGHT - game.boardHeight) / 2);
        }
        
        // Create new piece
        function newPiece() {
            const shapeIndex = Math.floor(Math.random() * SHAPES.length);
            game.current = SHAPES[shapeIndex];
            game.currentShape = shapeIndex;
            game.currentX = Math.floor(COLS / 2) - Math.floor(game.current[0].length / 2);
            game.currentY = 0;
            
            if (!isValidMove(0, 0)) {
                gameOver();
            }
        }
        
        // Check if move is valid
        function isValidMove(offsetX, offsetY, newPiece = game.current) {
            for (let y = 0; y < newPiece.length; y++) {
                for (let x = 0; x < newPiece[y].length; x++) {
                    if (newPiece[y][x]) {
                        const newX = game.currentX + x + offsetX;
                        const newY = game.currentY + y + offsetY;
                        
                        if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
                        if (newY >= 0 && game.board[newY][newX]) return false;
                    }
                }
            }
            return true;
        }
        
        // Rotate piece
        function rotate() {
            const newPiece = game.current[0].map((_, i) => 
                game.current.map(row => row[i]).reverse()
            );
            
            if (isValidMove(0, 0, newPiece)) {
                game.current = newPiece;
            }
        }
        
        // Merge piece into board
        function merge() {
            for (let y = 0; y < game.current.length; y++) {
                for (let x = 0; x < game.current[y].length; x++) {
                    if (game.current[y][x]) {
                        const boardY = game.currentY + y;
                        if (boardY >= 0) {
                            game.board[boardY][game.currentX + x] = game.currentShape + 1;
                        }
                    }
                }
            }
        }
        
        // Clear completed lines
        function clearLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (game.board[y].every(cell => cell > 0)) {
                    game.board.splice(y, 1);
                    game.board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++;
                }
            }
            
            if (linesCleared > 0) {
                game.score += [40, 100, 300, 1200][linesCleared - 1] * game.level;
                game.level = Math.floor(game.score / 1000) + 1;
                game.dropInterval = Math.max(100, 1000 - (game.level - 1) * 100);
                document.getElementById('score').textContent = game.score;
                document.getElementById('level').textContent = game.level;
            }
        }
        
        // Game over
        function gameOver() {
            game.isPlaying = false;
            alert(`Game Over! Score: ${game.score}`);
            resetGame();
        }
        
        // Reset game
        function resetGame() {
            game.board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            game.score = 0;
            game.level = 1;
            game.dropInterval = 1000;
            game.isPlaying = true;
            document.getElementById('score').textContent = '0';
            document.getElementById('level').textContent = '1';
            newPiece();
        }
        
        // Draw functions
        function drawBlock(x, y, color) {
            const px = game.boardX + x * game.blockSize;
            const py = game.boardY + y * game.blockSize;
            
            ctx.fillStyle = color;
            ctx.fillRect(px, py, game.blockSize - 1, game.blockSize - 1);
        }
        
        function drawBoard() {
            // Draw background
            ctx.fillStyle = '#111';
            ctx.fillRect(game.boardX - 2, game.boardY - 2, 
                        game.boardWidth + 4, game.boardHeight + 4);
            
            // Draw board
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (game.board[y][x]) {
                        drawBlock(x, y, COLORS[game.board[y][x] - 1]);
                    }
                }
            }
            
            // Draw current piece
            if (game.current) {
                for (let y = 0; y < game.current.length; y++) {
                    for (let x = 0; x < game.current[y].length; x++) {
                        if (game.current[y][x]) {
                            drawBlock(game.currentX + x, game.currentY + y, 
                                    COLORS[game.currentShape]);
                        }
                    }
                }
            }
        }
        
        // Game loop
        function update(time) {
            if (game.isPlaying) {
                if (time - game.lastDrop > game.dropInterval) {
                    if (isValidMove(0, 1)) {
                        game.currentY++;
                    } else {
                        merge();
                        clearLines();
                        newPiece();
                    }
                    game.lastDrop = time;
                }
            }
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBoard();
            requestAnimationFrame(update);
        }
        
        // Controls
        document.getElementById('leftBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (isValidMove(-1, 0)) game.currentX--;
        });
        
        document.getElementById('rightBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (isValidMove(1, 0)) game.currentX++;
        });
        
        document.getElementById('downBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (isValidMove(0, 1)) game.currentY++;
        });
        
        document.getElementById('rotateBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            rotate();
        });
        
        // Keyboard controls
        window.addEventListener('keydown', e => {
            if (!game.isPlaying) {
                if (e.key === 'Enter') resetGame();
                return;
            }
            
            switch(e.key) {
                case 'ArrowLeft':
                    if (isValidMove(-1, 0)) game.currentX--;
                    break;
                case 'ArrowRight':
                    if (isValidMove(1, 0)) game.currentX++;
                    break;
                case 'ArrowDown':
                    if (isValidMove(0, 1)) game.currentY++;
                    break;
                case 'ArrowUp':
                case ' ':
                    rotate();
                    break;
            }
        });
        
        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        resetGame();
        requestAnimationFrame(update);
    </script>
</body>
</html>
```

This implementation includes:

1. Proper mobile scaling with controls that don't overlap the game board
2. Touch controls with an opaque control bar
3. Keyboard support for desktop play
4. Standard Tetris scoring system
5. Progressive difficulty increase
6. Proper piece rotation and collision detection
7. Score and level display
8. Game over detection and reset
9. Responsive canvas that maintains aspect ratio
10. Clean visual style with block colors

To play:
- Use the arrow buttons on mobile to move pieces
- Tap the rotate button to rotate pieces
- On desktop, use arrow keys to move/rotate and spacebar for alternate rotation
- Press Enter to restart after game over
- Score increases based on lines cleared
- Speed increases as level increases

The game follows standard Tetris rules:
- Lines are cleared when completely filled
- Game ends when pieces stack to the top
- Scoring system: 40 points for 1 line, 100 for 2, 300 for 3, and 1200 for 4 lines (Tetris)
- Level increases every 1000 points
- Each level increases drop speed