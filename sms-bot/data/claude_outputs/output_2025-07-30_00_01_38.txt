I'll create a mobile-friendly Tetris game with touch controls and keyboard support. Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #000;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0,0,0,0.5);
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 8px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #score {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 20px;
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .start-btn {
            padding: 20px 40px;
            font-size: 24px;
            background: white;
            color: black;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div class="controls">
        <div class="control-btn" id="leftBtn">←</div>
        <div class="control-btn" id="rotateBtn">↻</div>
        <div class="control-btn" id="rightBtn">→</div>
        <div class="control-btn" id="dropBtn">↓</div>
    </div>
    <div id="startScreen">
        <h1>TETRIS</h1>
        <div class="start-btn" onclick="startGame()">TAP TO START</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BLOCK_SIZE = 30;
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        let score = 0;
        let board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
        let isPlaying = false;
        let dropInterval = 1000;
        let lastDrop = 0;

        // Tetromino shapes
        const SHAPES = [
            [[1,1,1,1]], // I
            [[1,1],[1,1]], // O
            [[1,1,1],[0,1,0]], // T
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]], // J
            [[1,1,0],[0,1,1]], // S
            [[0,1,1],[1,1,0]]  // Z
        ];

        const COLORS = [
            '#00f0f0', // cyan
            '#f0f000', // yellow
            '#a000f0', // purple
            '#f0a000', // orange
            '#0000f0', // blue
            '#00f000', // green
            '#f00000'  // red
        ];

        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let currentShape = 0;

        function resizeCanvas() {
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight - 100; // Account for controls
            const blockSize = Math.min(
                Math.floor(maxWidth / BOARD_WIDTH),
                Math.floor(maxHeight / BOARD_HEIGHT)
            );
            
            canvas.width = BOARD_WIDTH * blockSize;
            canvas.height = BOARD_HEIGHT * blockSize;
            ctx.scale(blockSize/BLOCK_SIZE, blockSize/BLOCK_SIZE);
        }

        function createPiece() {
            currentShape = Math.floor(Math.random() * SHAPES.length);
            currentPiece = SHAPES[currentShape];
            currentX = Math.floor(BOARD_WIDTH / 2) - Math.floor(currentPiece[0].length / 2);
            currentY = 0;

            if (!isValidMove(currentX, currentY, currentPiece)) {
                gameOver();
            }
        }

        function isValidMove(x, y, piece) {
            for (let r = 0; r < piece.length; r++) {
                for (let c = 0; c < piece[r].length; c++) {
                    if (!piece[r][c]) continue;
                    
                    let newX = x + c;
                    let newY = y + r;
                    
                    if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return false;
                    if (newY >= 0 && board[newY][newX]) return false;
                }
            }
            return true;
        }

        function rotatePiece() {
            let newPiece = currentPiece[0].map((_, i) => 
                currentPiece.map(row => row[i]).reverse()
            );
            
            if (isValidMove(currentX, currentY, newPiece)) {
                currentPiece = newPiece;
            }
        }

        function mergePiece() {
            for (let r = 0; r < currentPiece.length; r++) {
                for (let c = 0; c < currentPiece[r].length; c++) {
                    if (currentPiece[r][c]) {
                        let newY = currentY + r;
                        if (newY >= 0) {
                            board[newY][currentX + c] = currentShape + 1;
                        }
                    }
                }
            }
        }

        function checkLines() {
            let linesCleared = 0;
            
            for (let r = BOARD_HEIGHT - 1; r >= 0; r--) {
                if (board[r].every(cell => cell > 0)) {
                    board.splice(r, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                    linesCleared++;
                    r++;
                }
            }
            
            if (linesCleared > 0) {
                score += [40, 100, 300, 1200][linesCleared - 1];
                document.getElementById('score').textContent = `Score: ${score}`;
                dropInterval = Math.max(100, 1000 - Math.floor(score/100) * 50);
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw board
            for (let r = 0; r < BOARD_HEIGHT; r++) {
                for (let c = 0; c < BOARD_WIDTH; c++) {
                    if (board[r][c]) {
                        ctx.fillStyle = COLORS[board[r][c] - 1];
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                ctx.fillStyle = COLORS[currentShape];
                for (let r = 0; r < currentPiece.length; r++) {
                    for (let c = 0; c < currentPiece[r].length; c++) {
                        if (currentPiece[r][c]) {
                            ctx.fillRect(
                                (currentX + c) * BLOCK_SIZE,
                                (currentY + r) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                        }
                    }
                }
            }
        }

        function gameOver() {
            isPlaying = false;
            document.getElementById('startScreen').style.display = 'flex';
        }

        function update(time) {
            if (!isPlaying) return;
            
            if (time - lastDrop > dropInterval) {
                if (isValidMove(currentX, currentY + 1, currentPiece)) {
                    currentY++;
                } else {
                    mergePiece();
                    checkLines();
                    createPiece();
                }
                lastDrop = time;
            }
            
            draw();
            requestAnimationFrame(update);
        }

        function startGame() {
            board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            score = 0;
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('startScreen').style.display = 'none';
            isPlaying = true;
            createPiece();
            requestAnimationFrame(update);
        }

        // Controls
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isValidMove(currentX - 1, currentY, currentPiece)) currentX--;
        });

        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isValidMove(currentX + 1, currentY, currentPiece)) currentX++;
        });

        document.getElementById('rotateBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            rotatePiece();
        });

        document.getElementById('dropBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            while (isValidMove(currentX, currentY + 1, currentPiece)) currentY++;
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!isPlaying) {
                if (e.key === 'Enter') startGame();
                return;
            }
            
            switch(e.key) {
                case 'ArrowLeft':
                    if (isValidMove(currentX - 1, currentY, currentPiece)) currentX--;
                    break;
                case 'ArrowRight':
                    if (isValidMove(currentX + 1, currentY, currentPiece)) currentX++;
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case 'ArrowDown':
                    if (isValidMove(currentX, currentY + 1, currentPiece)) currentY++;
                    break;
                case ' ':
                    while (isValidMove(currentX, currentY + 1, currentPiece)) currentY++;
                    break;
            }
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
```

This implementation includes:

1. Mobile-friendly touch controls with buttons for left, right, rotate, and drop
2. Keyboard support for desktop play (arrow keys and spacebar)
3. Responsive canvas sizing that maintains the aspect ratio
4. Score tracking with increasing difficulty
5. Clean visual design with semi-transparent controls
6. Start screen with tap-to-start functionality
7. All standard Tetris mechanics:
   - Piece rotation
   - Line clearing
   - Score system
   - Progressive difficulty
   - Game over detection

To play:
- Mobile: Use the on-screen buttons
- Desktop: Use arrow keys to move/rotate, spacebar for hard drop
- Score increases based on lines cleared
- Game speeds up as score increases
- Game over when pieces stack to the top

The game is optimized for mobile devices with touch controls positioned at the bottom of the screen and proper viewport settings to prevent unwanted zooming or scrolling.