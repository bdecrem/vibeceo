Here's a mobile-friendly Asteroids game with touch controls and smooth gameplay:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Rocks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            touch-action: none;
            background: black;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        .score {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="score">Score: <span id="scoreValue">0</span></div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('scoreValue');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        const state = {
            ship: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 15,
                angle: 0,
                thrust: { x: 0, y: 0 },
                isThrusting: false
            },
            asteroids: [],
            bullets: [],
            particles: [],
            score: 0,
            touchStart: null,
            gameOver: false
        };

        // Constants
        const SHIP_THRUST = 0.5;
        const FRICTION = 0.99;
        const ASTEROID_SPEED = 2;
        const BULLET_SPEED = 7;
        const MAX_BULLETS = 5;

        // Create initial asteroids
        function createAsteroids(count) {
            for (let i = 0; i < count; i++) {
                const asteroid = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 30 + Math.random() * 20,
                    velocity: {
                        x: (Math.random() - 0.5) * ASTEROID_SPEED,
                        y: (Math.random() - 0.5) * ASTEROID_SPEED
                    },
                    vertices: []
                };
                
                // Create irregular shape
                const vertices = Math.floor(Math.random() * 4) + 8;
                for (let j = 0; j < vertices; j++) {
                    const angle = (j / vertices) * Math.PI * 2;
                    const radius = asteroid.radius * (0.8 + Math.random() * 0.4);
                    asteroid.vertices.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                state.asteroids.push(asteroid);
            }
        }

        // Handle touch input
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            state.touchStart = { x: touch.clientX, y: touch.clientY };
            fireBullet();
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            if (state.touchStart) {
                const dx = touch.clientX - state.touchStart.x;
                const dy = touch.clientY - state.touchStart.y;
                state.ship.angle = Math.atan2(dy, dx);
                state.ship.isThrusting = true;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            state.ship.isThrusting = false;
            state.touchStart = null;
        }, { passive: false });

        function fireBullet() {
            if (state.bullets.length >= MAX_BULLETS) return;
            
            const angle = state.ship.angle;
            state.bullets.push({
                x: state.ship.x + Math.cos(angle) * state.ship.radius,
                y: state.ship.y + Math.sin(angle) * state.ship.radius,
                velocity: {
                    x: Math.cos(angle) * BULLET_SPEED,
                    y: Math.sin(angle) * BULLET_SPEED
                },
                lifetime: 60
            });
        }

        function createParticles(x, y, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                state.particles.push({
                    x,
                    y,
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed
                    },
                    lifetime: 30,
                    radius: Math.random() * 2 + 1
                });
            }
        }

        function update() {
            if (state.gameOver) return;

            // Update ship
            if (state.ship.isThrusting) {
                state.ship.thrust.x += Math.cos(state.ship.angle) * SHIP_THRUST;
                state.ship.thrust.y += Math.sin(state.ship.angle) * SHIP_THRUST;
            }

            state.ship.thrust.x *= FRICTION;
            state.ship.thrust.y *= FRICTION;
            state.ship.x += state.ship.thrust.x;
            state.ship.y += state.ship.thrust.y;

            // Wrap ship around screen
            if (state.ship.x < 0) state.ship.x = canvas.width;
            if (state.ship.x > canvas.width) state.ship.x = 0;
            if (state.ship.y < 0) state.ship.y = canvas.height;
            if (state.ship.y > canvas.height) state.ship.y = 0;

            // Update asteroids
            state.asteroids.forEach(asteroid => {
                asteroid.x += asteroid.velocity.x;
                asteroid.y += asteroid.velocity.y;

                // Wrap asteroids
                if (asteroid.x < -asteroid.radius) asteroid.x = canvas.width + asteroid.radius;
                if (asteroid.x > canvas.width + asteroid.radius) asteroid.x = -asteroid.radius;
                if (asteroid.y < -asteroid.radius) asteroid.y = canvas.height + asteroid.radius;
                if (asteroid.y > canvas.height + asteroid.radius) asteroid.y = -asteroid.radius;

                // Check collision with ship
                const dx = state.ship.x - asteroid.x;
                const dy = state.ship.y - asteroid.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < state.ship.radius + asteroid.radius) {
                    state.gameOver = true;
                    createParticles(state.ship.x, state.ship.y, 20);
                }
            });

            // Update bullets
            state.bullets = state.bullets.filter(bullet => {
                bullet.x += bullet.velocity.x;
                bullet.y += bullet.velocity.y;
                bullet.lifetime--;

                // Check collision with asteroids
                state.asteroids.forEach((asteroid, index) => {
                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < asteroid.radius) {
                        state.score += 100;
                        scoreElement.textContent = state.score;
                        createParticles(asteroid.x, asteroid.y, 10);
                        
                        // Split asteroid or remove it
                        if (asteroid.radius > 25) {
                            const newRadius = asteroid.radius / 2;
                            for (let i = 0; i < 2; i++) {
                                const newAsteroid = {
                                    x: asteroid.x,
                                    y: asteroid.y,
                                    radius: newRadius,
                                    velocity: {
                                        x: (Math.random() - 0.5) * ASTEROID_SPEED * 1.5,
                                        y: (Math.random() - 0.5) * ASTEROID_SPEED * 1.5
                                    },
                                    vertices: []
                                };
                                const vertices = Math.floor(Math.random() * 4) + 8;
                                for (let j = 0; j < vertices; j++) {
                                    const angle = (j / vertices) * Math.PI * 2;
                                    const radius = newRadius * (0.8 + Math.random() * 0.4);
                                    newAsteroid.vertices.push({
                                        x: Math.cos(angle) * radius,
                                        y: Math.sin(angle) * radius
                                    });
                                }
                                state.asteroids.push(newAsteroid);
                            }
                        }
                        state.asteroids.splice(index, 1);
                        bullet.lifetime = 0;
                    }
                });

                return bullet.lifetime > 0;
            });

            // Update particles
            state.particles = state.particles.filter(particle => {
                particle.x += particle.velocity.x;
                particle.y += particle.velocity.y;
                particle.lifetime--;
                return particle.lifetime > 0;
            });

            // Create new asteroids if none remain
            if (state.asteroids.length === 0) {
                createAsteroids(Math.min(3 + Math.floor(state.score / 1000), 8));
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ship
            if (!state.gameOver) {
                ctx.save();
                ctx.translate(state.ship.x, state.ship.y);
                ctx.rotate(state.ship.angle);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(state.ship.radius, 0);
                ctx.lineTo(-state.ship.radius, state.ship.radius / 2);
                ctx.lineTo(-state.ship.radius, -state.ship.radius / 2);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            // Draw asteroids
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            state.asteroids.forEach(asteroid => {
                ctx.beginPath();
                ctx.moveTo(
                    asteroid.x + asteroid.vertices[0].x,
                    asteroid.y + asteroid.vertices[0].y
                );
                for (let i = 1; i < asteroid.vertices.length; i++) {
                    ctx.lineTo(
                        asteroid.x + asteroid.vertices[i].x,
                        asteroid.y + asteroid.vertices[i].y
                    );
                }
                ctx.closePath();
                ctx.stroke();
            });

            // Draw bullets
            ctx.fillStyle = 'white';
            state.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw particles
            state.particles.forEach(particle => {
                ctx.fillStyle = `rgba(255, 255, 255, ${particle.lifetime / 30})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw game over
            if (state.gameOver) {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px Arial';
                ctx.fillText('Tap to restart', canvas.width / 2, canvas.height / 2 + 40);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            state.ship.x = canvas.width / 2;
            state.ship.y = canvas.height / 2;
            state.ship.thrust = { x: 0, y: 0 };
            state.ship.angle = 0;
            state.ship.isThrusting = false;
            state.asteroids = [];
            state.bullets = [];
            state.particles = [];
            state.score = 0;
            state.gameOver = false;
            scoreElement.textContent = '0';
            createAsteroids(3);
        }

        canvas.addEventListener('click', () => {
            if (state.gameOver) startGame();
        });

        startGame();
        gameLoop();
    </script>
</body>
</html>
```

This Asteroids game features:

1. Touch controls:
   - Touch and drag to aim and thrust the ship
   - Tap to shoot bullets

2. Mobile-optimized gameplay:
   - Responsive canvas sizing
   - Touch-friendly controls
   - Smooth performance

3. Classic features:
   - Splitting asteroids
   - Particle effects
   - Score tracking
   - Wrapping screen edges

4. Game mechanics:
   - Ship thrust and momentum
   - Asteroid collision detection
   - Bullet firing with cooldown
   - Progressive difficulty

5. Visual effects:
   - Particle explosions
   - Clean vector-style graphics
   - Smooth animations

To play:
1. Touch and drag to move the ship in the desired direction
2. Tap anywhere to shoot
3. Destroy asteroids to score points
4. Avoid colliding with asteroids
5. When all asteroids are destroyed, more will spawn
6. If you crash, tap to restart

The game automatically adjusts to your screen size and maintains performance on mobile devices. The physics are tuned for smooth control while maintaining the classic Asteroids feel.