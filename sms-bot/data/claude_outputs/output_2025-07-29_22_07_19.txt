Here's a complete, mobile-friendly Pong game with touch controls:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Pong</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            background: #000;
            max-width: 100%;
            max-height: 100vh;
            touch-action: none;
        }

        .score {
            position: absolute;
            top: 20px;
            color: white;
            font-size: 24px;
            font-family: monospace;
            text-align: center;
            width: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="score">
        Player: <span id="playerScore">0</span> 
        CPU: <span id="cpuScore">0</span>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const PADDLE_HEIGHT = 100;
        const PADDLE_WIDTH = 15;
        const BALL_SIZE = 10;
        const BALL_SPEED = 7;
        const CPU_SPEED = 5;

        // Game state
        const game = {
            playerScore: 0,
            cpuScore: 0,
            running: true
        };

        // Paddle positions
        const player = {
            y: 0,
            score: 0
        };

        const cpu = {
            y: 0,
            score: 0
        };

        const ball = {
            x: 0,
            y: 0,
            dx: BALL_SPEED,
            dy: BALL_SPEED
        };

        function resizeCanvas() {
            // Make the canvas a 16:9 aspect ratio
            const width = Math.min(window.innerWidth, window.innerHeight * (16/9));
            const height = width * (9/16);
            
            canvas.width = width;
            canvas.height = height;
            
            // Reset paddle positions
            player.y = (canvas.height - PADDLE_HEIGHT) / 2;
            cpu.y = (canvas.height - PADDLE_HEIGHT) / 2;
            
            // Reset ball position
            resetBall();
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * BALL_SPEED;
            ball.dy = (Math.random() * 2 - 1) * BALL_SPEED;
        }

        function update() {
            if (!game.running) return;

            // Move ball
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Ball collision with top and bottom
            if (ball.y <= 0 || ball.y >= canvas.height) {
                ball.dy *= -1;
            }

            // Ball collision with paddles
            if (ball.dx < 0 && ball.x <= PADDLE_WIDTH && 
                ball.y >= player.y && ball.y <= player.y + PADDLE_HEIGHT) {
                ball.dx *= -1;
                // Add some randomness to the return angle
                ball.dy = (ball.y - (player.y + PADDLE_HEIGHT/2)) * 0.2;
            }

            if (ball.dx > 0 && ball.x >= canvas.width - PADDLE_WIDTH && 
                ball.y >= cpu.y && ball.y <= cpu.y + PADDLE_HEIGHT) {
                ball.dx *= -1;
                // Add some randomness to the return angle
                ball.dy = (ball.y - (cpu.y + PADDLE_HEIGHT/2)) * 0.2;
            }

            // Scoring
            if (ball.x < 0) {
                cpu.score++;
                document.getElementById('cpuScore').textContent = cpu.score;
                resetBall();
            }
            if (ball.x > canvas.width) {
                player.score++;
                document.getElementById('playerScore').textContent = player.score;
                resetBall();
            }

            // CPU AI
            const cpuCenter = cpu.y + PADDLE_HEIGHT/2;
            if (cpuCenter < ball.y - 35) {
                cpu.y += CPU_SPEED;
            }
            if (cpuCenter > ball.y + 35) {
                cpu.y -= CPU_SPEED;
            }

            // Keep paddles within canvas
            player.y = Math.max(0, Math.min(canvas.height - PADDLE_HEIGHT, player.y));
            cpu.y = Math.max(0, Math.min(canvas.height - PADDLE_HEIGHT, cpu.y));
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw paddles
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, player.y, PADDLE_WIDTH, PADDLE_HEIGHT);
            ctx.fillRect(canvas.width - PADDLE_WIDTH, cpu.y, PADDLE_WIDTH, PADDLE_HEIGHT);

            // Draw ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_SIZE, 0, Math.PI * 2);
            ctx.fill();
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Touch handling
        let touchY = null;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touchY !== null) {
                const touch = e.touches[0];
                const deltaY = touch.clientY - touchY;
                player.y += deltaY;
                touchY = touch.clientY;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchY = null;
        }, { passive: false });

        // Mouse handling for testing on desktop
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleY = canvas.height / rect.height;
            player.y = (e.clientY - rect.top) * scaleY - PADDLE_HEIGHT/2;
        });

        // Initialize game
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        gameLoop();
    </script>
</body>
</html>
```

This Pong implementation includes:

1. **Mobile-First Design**
   - Responsive canvas that maintains 16:9 aspect ratio
   - Touch controls optimized for mobile
   - Prevention of default touch behaviors

2. **Game Features**
   - Player vs CPU gameplay
   - Score tracking
   - Intelligent CPU opponent
   - Ball physics with randomized angles
   - Center line visual
   - Smooth paddle movement

3. **Controls**
   - Touch/drag anywhere to move paddle
   - Mouse support for desktop testing
   - Smooth paddle movement

4. **Visual Feedback**
   - Clear scoring display
   - High contrast colors
   - Smooth animations

To play:
1. Simply touch and drag up/down anywhere on the screen to move your paddle (left side)
2. Try to hit the ball past the CPU paddle (right side)
3. First to score wins!

The game automatically adjusts to screen size and orientation changes. The CPU opponent provides a good challenge while still being beatable. The ball speed and paddle sizes are tuned for mobile play.