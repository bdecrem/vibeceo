Here's a complete mobile-friendly Nibbles (Snake) game with touch controls and responsive design:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nibbles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            margin: auto;
            background: #001100;
        }
        
        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            display: none;
        }
        
        #restartBtn {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            background: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay">Score: <span id="scoreDisplay">0</span></div>
    <div id="gameOver">
        Game Over!<br>
        Final Score: <span id="finalScore">0</span><br>
        <button id="restartBtn">Play Again</button>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        
        // Game constants
        const GRID_SIZE = 20;
        let CELL_SIZE;
        let touchStartX = 0;
        let touchStartY = 0;
        
        // Game state
        const game = {
            snake: [],
            food: { x: 0, y: 0 },
            direction: 'right',
            nextDirection: 'right',
            score: 0,
            speed: 150,
            isPlaying: true
        };
        
        function resizeCanvas() {
            const minDimension = Math.min(window.innerWidth, window.innerHeight - 50);
            CELL_SIZE = Math.floor(minDimension / GRID_SIZE);
            canvas.width = CELL_SIZE * GRID_SIZE;
            canvas.height = CELL_SIZE * GRID_SIZE;
        }
        
        function initGame() {
            game.snake = [
                { x: 5, y: 10 },
                { x: 4, y: 10 },
                { x: 3, y: 10 }
            ];
            game.direction = 'right';
            game.nextDirection = 'right';
            game.score = 0;
            game.speed = 150;
            game.isPlaying = true;
            spawnFood();
            gameOverScreen.style.display = 'none';
            scoreDisplay.textContent = '0';
        }
        
        function spawnFood() {
            while (true) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                let validSpot = true;
                
                for (let segment of game.snake) {
                    if (segment.x === x && segment.y === y) {
                        validSpot = false;
                        break;
                    }
                }
                
                if (validSpot) {
                    game.food = { x, y };
                    break;
                }
            }
        }
        
        function update() {
            if (!game.isPlaying) return;
            
            game.direction = game.nextDirection;
            
            // Calculate new head position
            const head = { ...game.snake[0] };
            switch (game.direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            
            // Wrap around edges
            head.x = (head.x + GRID_SIZE) % GRID_SIZE;
            head.y = (head.y + GRID_SIZE) % GRID_SIZE;
            
            // Check collision with self
            for (let segment of game.snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }
            
            // Add new head
            game.snake.unshift(head);
            
            // Check food collision
            if (head.x === game.food.x && head.y === game.food.y) {
                game.score += 10;
                scoreDisplay.textContent = game.score;
                spawnFood();
                game.speed = Math.max(50, game.speed - 2);
            } else {
                game.snake.pop();
            }
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#001100';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw snake
            ctx.fillStyle = '#00FF00';
            game.snake.forEach((segment, index) => {
                ctx.fillRect(
                    segment.x * CELL_SIZE,
                    segment.y * CELL_SIZE,
                    CELL_SIZE - 1,
                    CELL_SIZE - 1
                );
            });
            
            // Draw food
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(
                game.food.x * CELL_SIZE,
                game.food.y * CELL_SIZE,
                CELL_SIZE - 1,
                CELL_SIZE - 1
            );
        }
        
        function gameOver() {
            game.isPlaying = false;
            gameOverScreen.style.display = 'block';
            finalScoreDisplay.textContent = game.score;
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && game.direction !== 'left') {
                    game.nextDirection = 'right';
                } else if (dx < 0 && game.direction !== 'right') {
                    game.nextDirection = 'left';
                }
            } else {
                if (dy > 0 && game.direction !== 'up') {
                    game.nextDirection = 'down';
                } else if (dy < 0 && game.direction !== 'down') {
                    game.nextDirection = 'up';
                }
            }
        }
        
        // Event listeners
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        restartBtn.addEventListener('click', initGame);
        
        // Keyboard controls (for testing)
        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    if (game.direction !== 'down') game.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                    if (game.direction !== 'up') game.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                    if (game.direction !== 'right') game.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                    if (game.direction !== 'left') game.nextDirection = 'right';
                    break;
            }
        });
        
        // Game loop
        function gameLoop() {
            update();
            render();
            if (game.isPlaying) {
                setTimeout(gameLoop, game.speed);
            }
        }
        
        // Start game
        resizeCanvas();
        initGame();
        gameLoop();
    </script>
</body>
</html>
```

This implementation includes:

1. Responsive canvas that scales to fit the screen while maintaining the game grid
2. Touch controls with swipe detection
3. Score tracking and display
4. Progressive difficulty (snake speeds up as you collect food)
5. Game over screen with restart functionality
6. Wrap-around edges
7. Collision detection with snake body
8. Keyboard controls for testing
9. Clean visual style with slight gap between snake segments
10. Food spawning that avoids snake body

To play:
- Swipe in any direction to control the snake
- Collect red food squares to grow and increase score
- Avoid hitting yourself
- Game speeds up as you collect more food
- Tap "Play Again" when game is over to restart

The game works well on both mobile and desktop browsers, with touch controls optimized for mobile play. The snake wraps around the edges of the screen for continuous gameplay, and the difficulty gradually increases as you play.