Here's a complete mobile-friendly Pong game with touch and keyboard controls:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Pong</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        .score-overlay {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            color: white;
            font-size: 24px;
            text-align: center;
            pointer-events: none;
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="score-overlay">
        <span id="playerScore">0</span> - <span id="aiScore">0</span>
    </div>
    <div class="start-screen" id="startScreen">
        Tap to Start<br>
        <small>Slide finger up/down to move paddle</small>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const playerScoreElement = document.getElementById('playerScore');
        const aiScoreElement = document.getElementById('aiScore');

        // Game state
        const game = {
            started: false,
            paused: false,
            playerScore: 0,
            aiScore: 0
        };

        // Game objects
        const ball = {
            x: 0,
            y: 0,
            size: 10,
            speed: 7,
            dx: 1,
            dy: 1,
            reset() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.dx = Math.random() > 0.5 ? 1 : -1;
                this.dy = (Math.random() * 2 - 1) * 0.75;
            }
        };

        const paddle = {
            width: 10,
            height: 100,
            speed: 8,
            player: {
                y: 0,
                score: 0
            },
            ai: {
                y: 0,
                score: 0
            }
        };

        // Resize handling
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Adjust paddle dimensions based on screen size
            paddle.width = Math.max(10, canvas.width * 0.02);
            paddle.height = Math.max(60, canvas.height * 0.2);
            ball.size = Math.max(8, canvas.width * 0.015);
            
            // Reset paddle positions
            paddle.player.y = (canvas.height - paddle.height) / 2;
            paddle.ai.y = (canvas.height - paddle.height) / 2;
            
            if (!game.started) {
                startScreen.style.display = 'block';
            }
        }

        // Input handling
        let touchY = null;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!game.started) {
                game.started = true;
                startScreen.style.display = 'none';
                ball.reset();
                return;
            }
            touchY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touchY !== null) {
                const newY = e.touches[0].clientY;
                const deltaY = newY - touchY;
                paddle.player.y = Math.max(0, Math.min(canvas.height - paddle.height, 
                    paddle.player.y + deltaY));
                touchY = newY;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            touchY = null;
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (!game.started && e.key === 'Enter') {
                game.started = true;
                startScreen.style.display = 'none';
                ball.reset();
                return;
            }

            switch(e.key) {
                case 'ArrowUp':
                    paddle.player.y = Math.max(0, paddle.player.y - paddle.speed);
                    break;
                case 'ArrowDown':
                    paddle.player.y = Math.min(canvas.height - paddle.height, 
                        paddle.player.y + paddle.speed);
                    break;
            }
        });

        // Game logic
        function update() {
            if (!game.started || game.paused) return;

            // Move ball
            ball.x += ball.dx * ball.speed;
            ball.y += ball.dy * ball.speed;

            // Ball collision with top and bottom
            if (ball.y <= 0 || ball.y >= canvas.height - ball.size) {
                ball.dy *= -1;
            }

            // Ball collision with paddles
            if (ball.dx < 0 && ball.x <= paddle.width * 2 && 
                ball.y + ball.size >= paddle.player.y && 
                ball.y <= paddle.player.y + paddle.height) {
                ball.dx *= -1;
                ball.dy = ((ball.y - (paddle.player.y + paddle.height/2)) / (paddle.height/2)) * 0.75;
            }

            if (ball.dx > 0 && ball.x >= canvas.width - paddle.width * 2 - ball.size && 
                ball.y + ball.size >= paddle.ai.y && 
                ball.y <= paddle.ai.y + paddle.height) {
                ball.dx *= -1;
                ball.dy = ((ball.y - (paddle.ai.y + paddle.height/2)) / (paddle.height/2)) * 0.75;
            }

            // Scoring
            if (ball.x < 0) {
                game.aiScore++;
                aiScoreElement.textContent = game.aiScore;
                ball.reset();
            } else if (ball.x > canvas.width) {
                game.playerScore++;
                playerScoreElement.textContent = game.playerScore;
                ball.reset();
            }

            // AI movement
            const aiCenter = paddle.ai.y + paddle.height/2;
            const ballFutureY = ball.y + (ball.dy * ((canvas.width - ball.x) / ball.speed));
            if (aiCenter < ballFutureY - paddle.height/4) {
                paddle.ai.y = Math.min(canvas.height - paddle.height, paddle.ai.y + paddle.speed * 0.6);
            } else if (aiCenter > ballFutureY + paddle.height/4) {
                paddle.ai.y = Math.max(0, paddle.ai.y - paddle.speed * 0.6);
            }
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw paddles
            ctx.fillStyle = '#fff';
            ctx.fillRect(paddle.width, paddle.player.y, paddle.width, paddle.height);
            ctx.fillRect(canvas.width - paddle.width * 2, paddle.ai.y, paddle.width, paddle.height);

            // Draw ball
            if (game.started) {
                ctx.fillRect(ball.x, ball.y, ball.size, ball.size);
            }
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        ball.reset();
        gameLoop();
    </script>
</body>
</html>
```

This implementation includes:

1. **Mobile-First Design**
- Touch controls: Slide finger up/down to move paddle
- Responsive sizing that adjusts to screen dimensions
- Clear visual feedback

2. **Desktop Support**
- Arrow keys for paddle movement
- Enter key to start game

3. **Features**
- Score tracking
- AI opponent with predictive movement
- Realistic ball physics with angle reflection
- Center line for visual reference
- Start screen with instructions

4. **Technical Details**
- Paddle size scales with screen dimensions
- Ball speed and paddle dimensions are responsive
- Smooth animation using requestAnimationFrame
- Proper touch event handling with preventDefault()
- Collision detection with realistic bounce angles

To play:
- On mobile: Tap to start, then slide finger up/down to move paddle
- On desktop: Press Enter to start, use arrow keys to move paddle
- Score points by getting the ball past the AI paddle
- The AI will attempt to block your shots
- First to reach desired score wins (no limit implemented)

The game automatically adjusts to screen size and orientation changes, making it playable on any device. The AI difficulty is balanced to be challenging but beatable.