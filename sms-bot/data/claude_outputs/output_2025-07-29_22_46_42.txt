I'll create a simplified mobile-friendly Pac-Man game with touch controls. Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Pac-Man</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            margin: auto;
            touch-action: none;
        }
        
        #score {
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 10px;
            font-size: 20px;
        }
        
        .d-pad {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
        }
        
        .d-pad-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.3);
            border: 2px solid white;
            border-radius: 25px;
        }
        
        #up { top: 0; left: 50px; }
        #right { top: 50px; left: 100px; }
        #down { top: 100px; left: 50px; }
        #left { top: 50px; left: 0; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div class="d-pad">
        <div class="d-pad-button" id="up"></div>
        <div class="d-pad-button" id="right"></div>
        <div class="d-pad-button" id="down"></div>
        <div class="d-pad-button" id="left"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // Game constants
        const GRID_SIZE = 15;
        const CELL_SIZE = 20;
        const PACMAN_SPEED = 2;
        const GHOST_SPEED = 1.5;

        // Initialize canvas size
        function resizeCanvas() {
            const size = Math.min(window.innerWidth, window.innerHeight - 100);
            canvas.width = GRID_SIZE * CELL_SIZE;
            canvas.height = GRID_SIZE * CELL_SIZE;
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        const game = {
            score: 0,
            pacman: {
                x: CELL_SIZE * 7,
                y: CELL_SIZE * 11,
                direction: { x: 0, y: 0 },
                nextDirection: { x: 0, y: 0 },
                mouthOpen: 0
            },
            ghosts: [
                { x: CELL_SIZE * 7, y: CELL_SIZE * 7, direction: { x: 1, y: 0 }, color: 'red' },
                { x: CELL_SIZE * 8, y: CELL_SIZE * 7, direction: { x: -1, y: 0 }, color: 'pink' }
            ],
            dots: [],
            walls: []
        };

        // Create maze layout
        const MAZE = [
            "###############",
            "#.............#",
            "#.###.#.###.#.#",
            "#.#...#...#.#.#",
            "#.#.###.#.#.#.#",
            "#.............#",
            "#.#.#.###.#.#.#",
            "#...#..#..#...#",
            "#.#.#.###.#.#.#",
            "#.............#",
            "#.###.#.###.#.#",
            "#.#...#...#.#.#",
            "#.#.###.#.#.#.#",
            "#.............#",
            "###############"
        ];

        // Initialize maze
        for (let y = 0; y < MAZE.length; y++) {
            for (let x = 0; x < MAZE[y].length; x++) {
                if (MAZE[y][x] === '#') {
                    game.walls.push({ x: x * CELL_SIZE, y: y * CELL_SIZE });
                } else if (MAZE[y][x] === '.') {
                    game.dots.push({ x: x * CELL_SIZE + CELL_SIZE/2, y: y * CELL_SIZE + CELL_SIZE/2 });
                }
            }
        }

        // Control handlers
        function setDirection(dx, dy) {
            game.pacman.nextDirection = { x: dx, y: dy };
        }

        document.getElementById('up').addEventListener('touchstart', () => setDirection(0, -1));
        document.getElementById('right').addEventListener('touchstart', () => setDirection(1, 0));
        document.getElementById('down').addEventListener('touchstart', () => setDirection(0, 1));
        document.getElementById('left').addEventListener('touchstart', () => setDirection(-1, 0));

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': setDirection(0, -1); break;
                case 'ArrowRight': setDirection(1, 0); break;
                case 'ArrowDown': setDirection(0, 1); break;
                case 'ArrowLeft': setDirection(-1, 0); break;
            }
        });

        function checkCollision(x, y) {
            for (let wall of game.walls) {
                if (x + CELL_SIZE > wall.x && 
                    x < wall.x + CELL_SIZE && 
                    y + CELL_SIZE > wall.y && 
                    y < wall.y + CELL_SIZE) {
                    return true;
                }
            }
            return false;
        }

        function update() {
            // Try to change direction
            const nextX = game.pacman.x + game.pacman.nextDirection.x * PACMAN_SPEED;
            const nextY = game.pacman.y + game.pacman.nextDirection.y * PACMAN_SPEED;
            
            if (!checkCollision(nextX, nextY)) {
                game.pacman.direction = game.pacman.nextDirection;
            }

            // Move Pac-Man
            const newX = game.pacman.x + game.pacman.direction.x * PACMAN_SPEED;
            const newY = game.pacman.y + game.pacman.direction.y * PACMAN_SPEED;
            
            if (!checkCollision(newX, newY)) {
                game.pacman.x = newX;
                game.pacman.y = newY;
            }

            // Collect dots
            game.dots = game.dots.filter(dot => {
                const dx = dot.x - (game.pacman.x + CELL_SIZE/2);
                const dy = dot.y - (game.pacman.y + CELL_SIZE/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < CELL_SIZE/2) {
                    game.score += 10;
                    scoreElement.textContent = `Score: ${game.score}`;
                    return false;
                }
                return true;
            });

            // Move ghosts
            game.ghosts.forEach(ghost => {
                // Simple ghost AI: try to move towards Pac-Man
                if (Math.random() < 0.02) {
                    const dx = game.pacman.x - ghost.x;
                    const dy = game.pacman.y - ghost.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        ghost.direction = { x: Math.sign(dx), y: 0 };
                    } else {
                        ghost.direction = { x: 0, y: Math.sign(dy) };
                    }
                }

                const newX = ghost.x + ghost.direction.x * GHOST_SPEED;
                const newY = ghost.y + ghost.direction.y * GHOST_SPEED;

                if (!checkCollision(newX, newY)) {
                    ghost.x = newX;
                    ghost.y = newY;
                } else {
                    // If collision, try random direction
                    ghost.direction = {
                        x: Math.floor(Math.random() * 3) - 1,
                        y: Math.floor(Math.random() * 3) - 1
                    };
                }
            });

            // Animate Pac-Man's mouth
            game.pacman.mouthOpen = (game.pacman.mouthOpen + 0.1) % Math.PI;
        }

        function render() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw walls
            ctx.fillStyle = 'blue';
            game.walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, CELL_SIZE, CELL_SIZE);
            });

            // Draw dots
            ctx.fillStyle = 'white';
            game.dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw Pac-Man
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            const mouthSize = Math.abs(Math.sin(game.pacman.mouthOpen)) * 0.5;
            ctx.arc(
                game.pacman.x + CELL_SIZE/2,
                game.pacman.y + CELL_SIZE/2,
                CELL_SIZE/2,
                mouthSize + Math.atan2(game.pacman.direction.y, game.pacman.direction.x),
                -mouthSize + Math.atan2(game.pacman.direction.y, game.pacman.direction.x) + Math.PI * 2
            );
            ctx.lineTo(game.pacman.x + CELL_SIZE/2, game.pacman.y + CELL_SIZE/2);
            ctx.fill();

            // Draw ghosts
            game.ghosts.forEach(ghost => {
                ctx.fillStyle = ghost.color;
                ctx.beginPath();
                ctx.arc(ghost.x + CELL_SIZE/2, ghost.y + CELL_SIZE/2, CELL_SIZE/2, 0, Math.PI);
                ctx.fillRect(ghost.x, ghost.y + CELL_SIZE/2, CELL_SIZE, CELL_SIZE/2);
                ctx.fill();
            });
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
```

This implementation includes:

1. A simplified maze layout with walls and dots
2. Touch-based D-pad controls for mobile
3. Keyboard controls for desktop
4. Basic ghost AI that follows Pac-Man
5. Score tracking
6. Collision detection
7. Responsive canvas sizing
8. Animated Pac-Man character
9. Two ghosts with different colors

The game features:
- Classic Pac-Man gameplay mechanics
- Mobile-friendly controls
- Responsive design that works on any screen size
- Simple ghost AI that pursues the player
- Score system for collecting dots
- Wall collision detection
- Smooth animation

To play:
- Use the D-pad controls on mobile devices
- Use arrow keys on desktop
- Collect all dots while avoiding ghosts
- Score points for each dot collected

The game automatically scales to fit the screen while maintaining the aspect ratio and playability on both mobile and desktop devices.