I'll create a mobile-friendly Tetris game with touch controls and all modern features. Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            background: #111;
            max-height: 90vh;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 20px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #score {
            position: fixed;
            top: 20px;
            color: white;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <div class="control-btn" id="leftBtn">←</div>
        <div class="control-btn" id="rotateBtn">↻</div>
        <div class="control-btn" id="rightBtn">→</div>
        <div class="control-btn" id="dropBtn">↓</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = Math.min(window.innerWidth / 12, window.innerHeight / 24);
        
        canvas.width = BLOCK_SIZE * COLS;
        canvas.height = BLOCK_SIZE * ROWS;

        // Tetromino shapes
        const SHAPES = [
            [[1,1,1,1]], // I
            [[1,1,1],[0,1,0]], // T
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]], // J
            [[1,1],[1,1]], // O
            [[1,1,0],[0,1,1]], // S
            [[0,1,1],[1,1,0]] // Z
        ];

        const COLORS = [
            '#00f0f0', // cyan
            '#a000f0', // purple
            '#f0a000', // orange
            '#0000f0', // blue
            '#f0f000', // yellow
            '#00f000', // green
            '#f00000'  // red
        ];

        // Game state
        const game = {
            board: Array(ROWS).fill().map(() => Array(COLS).fill(0)),
            score: 0,
            current: null,
            currentPos: {x: 0, y: 0},
            currentColor: '',
            gameOver: false
        };

        // Create new tetromino
        function newPiece() {
            const shapeIndex = Math.floor(Math.random() * SHAPES.length);
            game.current = SHAPES[shapeIndex].map(row => [...row]);
            game.currentColor = COLORS[shapeIndex];
            game.currentPos = {
                x: Math.floor((COLS - game.current[0].length) / 2),
                y: 0
            };

            if (!isValidMove(0, 0)) {
                game.gameOver = true;
            }
        }

        // Check if move is valid
        function isValidMove(moveX, moveY, newPiece = game.current) {
            return newPiece.every((row, dy) => 
                row.every((value, dx) => {
                    let newX = game.currentPos.x + dx + moveX;
                    let newY = game.currentPos.y + dy + moveY;
                    return (
                        value === 0 ||
                        (newX >= 0 && newX < COLS &&
                         newY < ROWS &&
                         newY >= 0 &&
                         !game.board[newY][newX])
                    );
                })
            );
        }

        // Rotate piece
        function rotate() {
            const rotated = game.current[0].map((_, i) =>
                game.current.map(row => row[i]).reverse()
            );
            if (isValidMove(0, 0, rotated)) {
                game.current = rotated;
            }
        }

        // Lock piece in place
        function lockPiece() {
            game.current.forEach((row, dy) => {
                row.forEach((value, dx) => {
                    if (value) {
                        game.board[game.currentPos.y + dy][game.currentPos.x + dx] = game.currentColor;
                    }
                });
            });

            // Check for completed lines
            let linesCleared = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (game.board[y].every(cell => cell)) {
                    game.board.splice(y, 1);
                    game.board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++;
                }
            }

            // Update score
            game.score += linesCleared * 100;
            document.getElementById('score').textContent = `Score: ${game.score}`;

            newPiece();
        }

        // Draw functions
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw board
            game.board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color) {
                        drawBlock(x, y, color);
                    }
                });
            });

            // Draw current piece
            if (game.current) {
                game.current.forEach((row, dy) => {
                    row.forEach((value, dx) => {
                        if (value) {
                            drawBlock(game.currentPos.x + dx, game.currentPos.y + dy, game.currentColor);
                        }
                    });
                });
            }

            if (game.gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width/2, canvas.height/2);
            }
        }

        // Game loop
        let dropCounter = 0;
        let lastTime = 0;
        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > 1000) {
                if (isValidMove(0, 1)) {
                    game.currentPos.y++;
                } else {
                    lockPiece();
                }
                dropCounter = 0;
            }

            draw();
            requestAnimationFrame(update);
        }

        // Controls
        document.getElementById('leftBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (!game.gameOver && isValidMove(-1, 0)) game.currentPos.x--;
        });

        document.getElementById('rightBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (!game.gameOver && isValidMove(1, 0)) game.currentPos.x++;
        });

        document.getElementById('rotateBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (!game.gameOver) rotate();
        });

        document.getElementById('dropBtn').addEventListener('touchstart', e => {
            e.preventDefault();
            if (!game.gameOver) {
                while (isValidMove(0, 1)) {
                    game.currentPos.y++;
                }
                lockPiece();
                dropCounter = 0;
            }
        });

        // Swipe controls
        let touchStartX = null;
        let touchStartY = null;

        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
        });

        canvas.addEventListener('touchend', e => {
            if (!touchStartX || !touchStartY) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const diffX = touchStartX - touchEndX;
            const diffY = touchStartY - touchEndY;

            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (diffX > 0 && isValidMove(-1, 0)) {
                    game.currentPos.x--;
                } else if (diffX < 0 && isValidMove(1, 0)) {
                    game.currentPos.x++;
                }
            } else {
                if (diffY > 0) {
                    rotate();
                } else {
                    while (isValidMove(0, 1)) {
                        game.currentPos.y++;
                    }
                    lockPiece();
                }
            }

            touchStartX = null;
            touchStartY = null;
        });

        // Start game
        newPiece();
        update();
    </script>
</body>
</html>
```

This implementation includes:

1. Responsive canvas sizing that works on all mobile devices
2. Touch controls:
   - Buttons for left, right, rotate, and quick drop
   - Swipe controls on the game area (left/right to move, up to rotate, down to drop)
3. Classic Tetris features:
   - Seven standard tetromino shapes
   - Color-coded pieces
   - Score tracking
   - Line clearing
   - Game over detection
4. Mobile-optimized UI:
   - Large, touch-friendly control buttons
   - Clear score display
   - Responsive layout
5. Performance optimizations:
   - Efficient drawing routines
   - RequestAnimationFrame for smooth animation
   - Touch event handling with preventDefault()

To play:
1. Use the buttons at the bottom or swipe on the game area
2. Swipe left/right to move the piece
3. Swipe up to rotate
4. Swipe down or use the down button for quick drop
5. Clear lines to score points
6. Game ends when pieces stack to the top

The game automatically adjusts to the device screen size while maintaining playable proportions. All controls are designed to be touch-friendly with clear visual feedback.