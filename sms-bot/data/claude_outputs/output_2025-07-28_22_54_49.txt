<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üêç SNAKE!</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            background: linear-gradient(45deg, #2c3e50, #3498db);
        }
        #controls {
            position: fixed;
            bottom: 0;
            width: 100%;
            height: 120px;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .dpad {
            position: relative;
            width: 180px;
            height: 180px;
        }
        .dpad-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
        }
        #upBtn { top: 0; left: 60px; }
        #leftBtn { top: 60px; left: 0; }
        #rightBtn { top: 60px; left: 120px; }
        #downBtn { top: 120px; left: 60px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <div class="dpad">
            <button class="dpad-btn" id="upBtn">‚¨ÜÔ∏è</button>
            <button class="dpad-btn" id="leftBtn">‚¨ÖÔ∏è</button>
            <button class="dpad-btn" id="rightBtn">‚û°Ô∏è</button>
            <button class="dpad-btn" id="downBtn">‚¨áÔ∏è</button>
        </div>
    </div>

<script>
var canvas = document.getElementById('gameCanvas');
var ctx = canvas.getContext('2d');
var controlsHeight = 120;

function resizeCanvas() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = (window.innerHeight - controlsHeight) * devicePixelRatio;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = (window.innerHeight - controlsHeight) + 'px';
    gridSize = Math.floor(Math.min(canvas.width, canvas.height) / 20);
    gridWidth = Math.floor(canvas.width / gridSize);
    gridHeight = Math.floor(canvas.height / gridSize);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

var gameState = 'title'; // title, playing, gameover
var score = 0;
var highScore = 0;
var snake = [];
var food = { x: 0, y: 0 };
var direction = 'right';
var nextDirection = 'right';
var gridSize, gridWidth, gridHeight;
var lastTime = 0;
var gameSpeed = 150;

function initGame() {
    snake = [
        {x: Math.floor(gridWidth/4), y: Math.floor(gridHeight/2)},
        {x: Math.floor(gridWidth/4)-1, y: Math.floor(gridHeight/2)}
    ];
    direction = 'right';
    nextDirection = 'right';
    score = 0;
    spawnFood();
}

function spawnFood() {
    do {
        food = {
            x: Math.floor(Math.random() * gridWidth),
            y: Math.floor(Math.random() * gridHeight)
        };
    } while (snake.some(function(segment) {
        return segment.x === food.x && segment.y === food.y;
    }));
}

function update() {
    if (gameState !== 'playing') return;

    direction = nextDirection;
    var head = {x: snake[0].x, y: snake[0].y};
    
    switch(direction) {
        case 'up': head.y--; break;
        case 'down': head.y++; break;
        case 'left': head.x--; break;
        case 'right': head.x++; break;
    }

    // Wall collision
    if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
        gameState = 'gameover';
        if (score > highScore) highScore = score;
        return;
    }

    // Self collision
    if (snake.some(function(segment) { return segment.x === head.x && segment.y === head.y; })) {
        gameState = 'gameover';
        if (score > highScore) highScore = score;
        return;
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
        score += 10;
        spawnFood();
        gameSpeed = Math.max(50, 150 - Math.floor(score/50) * 10);
    } else {
        snake.pop();
    }
}

function draw() {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'title') {
        ctx.fillStyle = 'white';
        ctx.font = (48 * devicePixelRatio) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('üêç SNAKE!', canvas.width/2, canvas.height/3);
        ctx.font = (24 * devicePixelRatio) + 'px Arial';
        ctx.fillText('Tap to Play!', canvas.width/2, canvas.height/2);
        return;
    }

    // Draw food
    ctx.fillStyle = '#ff4757';
    ctx.fillRect(
        food.x * gridSize,
        food.y * gridSize,
        gridSize - 1,
        gridSize - 1
    );

    // Draw snake
    snake.forEach(function(segment, i) {
        ctx.fillStyle = i === 0 ? '#7bed9f' : '#2ed573';
        ctx.fillRect(
            segment.x * gridSize,
            segment.y * gridSize,
            gridSize - 1,
            gridSize - 1
        );
    });

    // Draw score
    ctx.fillStyle = 'white';
    ctx.font = (20 * devicePixelRatio) + 'px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 10, 30);

    if (gameState === 'gameover') {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = (48 * devicePixelRatio) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over!', canvas.width/2, canvas.height/3);
        ctx.font = (24 * devicePixelRatio) + 'px Arial';
        ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2);
        ctx.fillText('High Score: ' + highScore, canvas.width/2, canvas.height/2 + 40);
        ctx.fillText('Tap to Restart', canvas.width/2, canvas.height/2 + 80);
    }
}

function gameLoop(currentTime) {
    if (currentTime - lastTime >= gameSpeed) {
        update();
        lastTime = currentTime;
    }
    draw();
    requestAnimationFrame(gameLoop);
}

// Controls
var keys = {
    up: false,
    down: false,
    left: false,
    right: false
};

function handleDirection(dir) {
    if (gameState === 'playing') {
        if (dir === 'up' && direction !== 'down') nextDirection = 'up';
        if (dir === 'down' && direction !== 'up') nextDirection = 'down';
        if (dir === 'left' && direction !== 'right') nextDirection = 'left';
        if (dir === 'right' && direction !== 'left') nextDirection = 'right';
    }
}

// Touch controls
document.getElementById('upBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    handleDirection('up');
});
document.getElementById('downBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    handleDirection('down');
});
document.getElementById('leftBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    handleDirection('left');
});
document.getElementById('rightBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    handleDirection('right');
});

// Keyboard controls
document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowUp') handleDirection('up');
    if (e.key === 'ArrowDown') handleDirection('down');
    if (e.key === 'ArrowLeft') handleDirection('left');
    if (e.key === 'ArrowRight') handleDirection('right');
});

// Canvas touch/click handler
canvas.addEventListener('click', function() {
    if (gameState === 'title') {
        gameState = 'playing';
        initGame();
    } else if (gameState === 'gameover') {
        gameState = 'title';
    }
});

canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
});
canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
});
canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
});

// Start game
requestAnimationFrame(gameLoop);
</script>
</body>
</html>