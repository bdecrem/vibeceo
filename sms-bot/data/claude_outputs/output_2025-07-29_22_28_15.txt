I'll create a mobile-friendly Tetris game with touch controls. The game will use swipe gestures for movement and rotation.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            background: #111;
            max-height: 90vh;
        }
        
        .score {
            color: white;
            font-size: 24px;
            position: absolute;
            top: 20px;
            left: 20px;
        }
    </style>
</head>
<body>
    <div class="score">Score: <span id="scoreValue">0</span></div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const BLOCK_SIZE = Math.floor(window.innerHeight / 24);
const GRID_WIDTH = 10;
const GRID_HEIGHT = 20;

// Set canvas size
canvas.width = BLOCK_SIZE * (GRID_WIDTH + 6); // Extra space for next piece
canvas.height = BLOCK_SIZE * GRID_HEIGHT;

// Game state
let score = 0;
let grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
let currentPiece = null;
let nextPiece = null;
let gameOver = false;
let touchStartX = 0;
let touchStartY = 0;

// Tetromino shapes
const SHAPES = [
    [[1,1,1,1]], // I
    [[1,1],[1,1]], // O
    [[1,1,1],[0,1,0]], // T
    [[1,1,1],[1,0,0]], // L
    [[1,1,1],[0,0,1]], // J
    [[1,1,0],[0,1,1]], // S
    [[0,1,1],[1,1,0]]  // Z
];

const COLORS = [
    '#00f0f0', // cyan
    '#f0f000', // yellow
    '#a000f0', // purple
    '#f0a000', // orange
    '#0000f0', // blue
    '#00f000', // green
    '#f00000'  // red
];

class Piece {
    constructor(shape = null, color = null) {
        const idx = shape === null ? Math.floor(Math.random() * SHAPES.length) : shape;
        this.shape = SHAPES[idx];
        this.color = COLORS[idx];
        this.x = Math.floor((GRID_WIDTH - this.shape[0].length) / 2);
        this.y = 0;
    }

    rotate() {
        const newShape = Array(this.shape[0].length).fill()
            .map(() => Array(this.shape.length).fill(0));
        
        for(let y = 0; y < this.shape.length; y++) {
            for(let x = 0; x < this.shape[0].length; x++) {
                newShape[x][this.shape.length - 1 - y] = this.shape[y][x];
            }
        }
        
        const oldShape = this.shape;
        this.shape = newShape;
        
        if(this.collides()) {
            this.shape = oldShape;
            return false;
        }
        return true;
    }

    collides() {
        for(let y = 0; y < this.shape.length; y++) {
            for(let x = 0; x < this.shape[0].length; x++) {
                if(this.shape[y][x]) {
                    const gridY = this.y + y;
                    const gridX = this.x + x;
                    
                    if(gridY < 0 || gridY >= GRID_HEIGHT || 
                       gridX < 0 || gridX >= GRID_WIDTH ||
                       grid[gridY][gridX]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
}

function drawPiece(piece, offsetX = 0, offsetY = 0) {
    for(let y = 0; y < piece.shape.length; y++) {
        for(let x = 0; x < piece.shape[0].length; x++) {
            if(piece.shape[y][x]) {
                drawBlock(piece.x + x + offsetX, piece.y + y + offsetY, piece.color);
            }
        }
    }
}

function drawGrid() {
    for(let y = 0; y < GRID_HEIGHT; y++) {
        for(let x = 0; x < GRID_WIDTH; x++) {
            if(grid[y][x]) {
                drawBlock(x, y, grid[y][x]);
            }
        }
    }
}

function drawNextPiece() {
    const offsetX = GRID_WIDTH + 1;
    const offsetY = 1;
    
    ctx.fillStyle = '#222';
    ctx.fillRect(BLOCK_SIZE * (GRID_WIDTH + 0.5), 0, 
                 BLOCK_SIZE * 5, BLOCK_SIZE * 4);
    
    for(let y = 0; y < nextPiece.shape.length; y++) {
        for(let x = 0; x < nextPiece.shape[0].length; x++) {
            if(nextPiece.shape[y][x]) {
                drawBlock(offsetX + x, offsetY + y, nextPiece.color);
            }
        }
    }
}

function clearLines() {
    let linesCleared = 0;
    
    for(let y = GRID_HEIGHT - 1; y >= 0; y--) {
        if(grid[y].every(cell => cell !== 0)) {
            grid.splice(y, 1);
            grid.unshift(Array(GRID_WIDTH).fill(0));
            linesCleared++;
            y++; // Check the same row again
        }
    }
    
    if(linesCleared > 0) {
        score += [40, 100, 300, 1200][linesCleared - 1];
        document.getElementById('scoreValue').textContent = score;
    }
}

function mergePiece() {
    for(let y = 0; y < currentPiece.shape.length; y++) {
        for(let x = 0; x < currentPiece.shape[0].length; x++) {
            if(currentPiece.shape[y][x]) {
                grid[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
            }
        }
    }
}

function newPiece() {
    currentPiece = nextPiece || new Piece();
    nextPiece = new Piece();
    
    if(currentPiece.collides()) {
        gameOver = true;
    }
}

// Touch controls
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    
    // Determine swipe direction
    if(Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if(Math.abs(deltaX) > 30) { // Minimum swipe distance
            const oldX = currentPiece.x;
            currentPiece.x += deltaX > 0 ? 1 : -1;
            if(currentPiece.collides()) {
                currentPiece.x = oldX;
            }
        }
    } else {
        // Vertical swipe
        if(deltaY > 30) { // Downward swipe
            while(!currentPiece.collides()) {
                currentPiece.y++;
            }
            currentPiece.y--;
            mergePiece();
            clearLines();
            newPiece();
        } else if(deltaY < -30) { // Upward swipe
            currentPiece.rotate();
        }
    }
}, {passive: false});

// Game loop
let lastTime = 0;
let dropInterval = 1000;
let dropCounter = 0;

function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;
    
    if(!gameOver) {
        dropCounter += deltaTime;
        if(dropCounter > dropInterval) {
            currentPiece.y++;
            if(currentPiece.collides()) {
                currentPiece.y--;
                mergePiece();
                clearLines();
                newPiece();
            }
            dropCounter = 0;
        }
        
        // Clear canvas
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw game elements
        drawGrid();
        drawPiece(currentPiece);
        drawNextPiece();
    } else {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over!', canvas.width/2, canvas.height/2);
    }
    
    requestAnimationFrame(update);
}

// Start game
newPiece();
update();
</script>
</body>
</html>
```

This implementation includes:

1. Mobile-optimized touch controls:
   - Swipe left/right to move piece
   - Swipe up to rotate
   - Swipe down for hard drop

2. Responsive canvas sizing based on screen height

3. Next piece preview

4. Score system:
   - 40 points for 1 line
   - 100 points for 2 lines
   - 300 points for 3 lines
   - 1200 points for 4 lines

5. Game over detection and display

6. Smooth animations using requestAnimationFrame

To play:
1. The game automatically starts when loaded
2. Use swipe gestures to control the falling pieces
3. Try to complete lines to score points
4. The game ends when pieces stack to the top

The game is optimized for mobile devices with:
- Proper viewport settings
- Touch event handling with preventDefault()
- Responsive sizing
- Clear visual feedback
- No external dependencies

The controls are intuitive and work well on touch screens, with sufficient swipe detection thresholds to prevent accidental moves.