I'll create a mobile-friendly Breakout game with touch controls, particle effects, and progressive difficulty. Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Breakout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const BRICK_ROWS = 6;
        const BRICK_COLS = 8;
        const BRICK_PADDING = 4;
        const BALL_SPEED_INCREMENT = 0.2;
        const INITIAL_BALL_SPEED = 7;

        // Game state
        const game = {
            score: 0,
            lives: 3,
            isPlaying: false,
            particles: [],
            powerUps: []
        };

        // Paddle properties
        const paddle = {
            width: 100,
            height: 20,
            x: 0,
            y: 0
        };

        // Ball properties
        const ball = {
            size: 10,
            x: 0,
            y: 0,
            dx: INITIAL_BALL_SPEED,
            dy: -INITIAL_BALL_SPEED,
            speed: INITIAL_BALL_SPEED
        };

        // Bricks array
        let bricks = [];

        // Responsive sizing
        function resizeCanvas() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const scale = Math.min(screenWidth / 400, screenHeight / 600);
            
            canvas.width = 400 * scale;
            canvas.height = 600 * scale;

            // Adjust game elements based on canvas size
            paddle.width = canvas.width * 0.25;
            paddle.height = canvas.height * 0.033;
            ball.size = canvas.width * 0.025;
            
            // Position paddle
            paddle.x = (canvas.width - paddle.width) / 2;
            paddle.y = canvas.height - paddle.height - 10;

            // Reset ball position
            resetBall();

            // Initialize bricks
            initializeBricks();
        }

        function initializeBricks() {
            bricks = [];
            const brickWidth = (canvas.width - BRICK_PADDING * (BRICK_COLS + 1)) / BRICK_COLS;
            const brickHeight = canvas.height * 0.04;

            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLS; c++) {
                    const brickX = (c * (brickWidth + BRICK_PADDING)) + BRICK_PADDING;
                    const brickY = (r * (brickHeight + BRICK_PADDING)) + BRICK_PADDING + canvas.height * 0.1;
                    
                    bricks.push({
                        x: brickX,
                        y: brickY,
                        width: brickWidth,
                        height: brickHeight,
                        color: `hsl(${360 * r / BRICK_ROWS}, 70%, 50%)`,
                        visible: true
                    });
                }
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = paddle.y - ball.size;
            ball.dx = INITIAL_BALL_SPEED * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = -INITIAL_BALL_SPEED;
            ball.speed = INITIAL_BALL_SPEED;
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                game.particles.push({
                    x,
                    y,
                    dx: Math.cos(angle) * 3,
                    dy: Math.sin(angle) * 3,
                    size: 3,
                    color,
                    life: 1
                });
            }
        }

        function updateParticles() {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const particle = game.particles[i];
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.life -= 0.02;
                
                if (particle.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            game.particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.fillRect(
                    particle.x - particle.size/2,
                    particle.y - particle.size/2,
                    particle.size,
                    particle.size
                );
            });
            ctx.globalAlpha = 1;
        }

        function update() {
            if (!game.isPlaying) return;

            // Update ball position
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Ball collision with walls
            if (ball.x + ball.size > canvas.width || ball.x - ball.size < 0) {
                ball.dx = -ball.dx;
            }
            if (ball.y - ball.size < 0) {
                ball.dy = -ball.dy;
            }

            // Ball collision with paddle
            if (ball.y + ball.size > paddle.y &&
                ball.x > paddle.x &&
                ball.x < paddle.x + paddle.width) {
                ball.dy = -ball.dy;
                // Adjust angle based on where ball hits paddle
                const hitPos = (ball.x - paddle.x) / paddle.width;
                ball.dx = ball.speed * (hitPos - 0.5) * 2;
            }

            // Ball out of bounds
            if (ball.y + ball.size > canvas.height) {
                game.lives--;
                if (game.lives <= 0) {
                    game.isPlaying = false;
                } else {
                    resetBall();
                }
            }

            // Ball collision with bricks
            bricks.forEach((brick, index) => {
                if (!brick.visible) return;

                if (ball.x > brick.x &&
                    ball.x < brick.x + brick.width &&
                    ball.y > brick.y &&
                    ball.y < brick.y + brick.height) {
                    
                    brick.visible = false;
                    ball.dy = -ball.dy;
                    game.score += 10;
                    ball.speed += BALL_SPEED_INCREMENT;
                    createParticles(ball.x, ball.y, brick.color);
                }
            });

            updateParticles();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw paddle
            ctx.fillStyle = '#fff';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

            // Draw ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.closePath();

            // Draw bricks
            bricks.forEach(brick => {
                if (!brick.visible) return;
                ctx.fillStyle = brick.color;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
            });

            // Draw particles
            drawParticles();

            // Draw score and lives
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${game.score}`, 10, 30);
            ctx.fillText(`Lives: ${game.lives}`, canvas.width - 80, 30);

            // Game over message
            if (!game.isPlaying && game.lives <= 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width/2, canvas.height/2);
                ctx.font = '20px Arial';
                ctx.fillText('Tap to play again', canvas.width/2, canvas.height/2 + 40);
                ctx.textAlign = 'left';
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Touch handling
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            paddle.x = touchX - paddle.width/2;

            // Keep paddle within canvas bounds
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
        }, { passive: false });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!game.isPlaying) {
                game.isPlaying = true;
                game.lives = 3;
                game.score = 0;
                resetBall();
                initializeBricks();
            }
        }, { passive: false });

        // Initialize game
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        gameLoop();
    </script>
</body>
</html>
```

This implementation includes:

1. Responsive canvas sizing that works on all mobile devices
2. Touch controls for paddle movement
3. Particle effects when bricks are destroyed
4. Progressive difficulty (ball speeds up as you play)
5. Score tracking and lives system
6. Colorful bricks with different colors per row
7. Proper collision detection and ball physics
8. Game over screen with restart functionality

To play:
- Drag your finger left and right to move the paddle
- Bounce the ball to break all the bricks
- You have 3 lives
- The ball speeds up as you break more bricks
- Tap to start a new game when game over

The game features:
- Smooth animations
- Particle effects
- Progressive difficulty
- Touch-optimized controls
- Responsive design that works on any screen size
- Visual feedback for all actions

The game will automatically adjust its size to fit any screen while maintaining playable proportions. All touch events have preventDefault() to prevent unwanted scrolling or zooming during gameplay.