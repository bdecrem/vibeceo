I'll create a mobile-friendly Snake game with touch controls and a clean design. Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            margin: auto;
            background-color: #000;
        }
        
        .score-container {
            color: white;
            text-align: center;
            padding: 10px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div class="score-container">Score: <span id="score">0</span></div>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        
        // Game constants
        const GRID_SIZE = 20;
        let CELL_SIZE;
        let touchStartX = 0;
        let touchStartY = 0;
        
        // Game state
        const game = {
            snake: [{x: 10, y: 10}], // Snake starts with one segment
            food: {x: 15, y: 15},
            direction: 'right',
            nextDirection: 'right',
            score: 0,
            speed: 150,
            isPlaying: true
        };
        
        function resizeCanvas() {
            const minDimension = Math.min(window.innerWidth, window.innerHeight - 50);
            canvas.width = Math.floor(minDimension / GRID_SIZE) * GRID_SIZE;
            canvas.height = canvas.width;
            CELL_SIZE = canvas.width / GRID_SIZE;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Touch controls
        canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
        canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
        
        function handleTouchStart(e) {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!touchStartX || !touchStartY) return;
            
            const touchEndX = e.touches[0].clientX;
            const touchEndY = e.touches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Determine swipe direction based on which delta is larger
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0 && game.direction !== 'left') game.nextDirection = 'right';
                else if (deltaX < 0 && game.direction !== 'right') game.nextDirection = 'left';
            } else {
                if (deltaY > 0 && game.direction !== 'up') game.nextDirection = 'down';
                else if (deltaY < 0 && game.direction !== 'down') game.nextDirection = 'up';
            }
            
            touchStartX = touchEndX;
            touchStartY = touchEndY;
        }
        
        // Keyboard controls (for testing)
        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': if (game.direction !== 'down') game.nextDirection = 'up'; break;
                case 'ArrowDown': if (game.direction !== 'up') game.nextDirection = 'down'; break;
                case 'ArrowLeft': if (game.direction !== 'right') game.nextDirection = 'left'; break;
                case 'ArrowRight': if (game.direction !== 'left') game.nextDirection = 'right'; break;
            }
        });
        
        function spawnFood() {
            while (true) {
                const newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
                
                // Check if food spawned on snake
                let onSnake = false;
                for (let segment of game.snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        onSnake = true;
                        break;
                    }
                }
                
                if (!onSnake) {
                    game.food = newFood;
                    break;
                }
            }
        }
        
        function update() {
            if (!game.isPlaying) return;
            
            // Update direction
            game.direction = game.nextDirection;
            
            // Calculate new head position
            const head = {...game.snake[0]};
            switch(game.direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            
            // Check for wall collision
            if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                gameOver();
                return;
            }
            
            // Check for self collision
            for (let segment of game.snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }
            
            // Add new head
            game.snake.unshift(head);
            
            // Check for food collision
            if (head.x === game.food.x && head.y === game.food.y) {
                game.score += 10;
                scoreElement.textContent = game.score;
                spawnFood();
                // Speed up the game
                game.speed = Math.max(50, game.speed - 2);
            } else {
                game.snake.pop();
            }
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw snake
            ctx.fillStyle = '#00ff00';
            game.snake.forEach((segment, index) => {
                ctx.fillRect(
                    segment.x * CELL_SIZE + 1,
                    segment.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
                
                // Draw eyes on head
                if (index === 0) {
                    ctx.fillStyle = '#000';
                    const eyeSize = CELL_SIZE / 6;
                    const eyeOffset = CELL_SIZE / 4;
                    
                    // Position eyes based on direction
                    let eyeX1, eyeX2, eyeY1, eyeY2;
                    switch(game.direction) {
                        case 'right':
                            eyeX1 = eyeX2 = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset;
                            eyeY1 = segment.y * CELL_SIZE + eyeOffset;
                            eyeY2 = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset;
                            break;
                        case 'left':
                            eyeX1 = eyeX2 = segment.x * CELL_SIZE + eyeOffset;
                            eyeY1 = segment.y * CELL_SIZE + eyeOffset;
                            eyeY2 = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset;
                            break;
                        case 'up':
                            eyeY1 = eyeY2 = segment.y * CELL_SIZE + eyeOffset;
                            eyeX1 = segment.x * CELL_SIZE + eyeOffset;
                            eyeX2 = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset;
                            break;
                        case 'down':
                            eyeY1 = eyeY2 = segment.y * CELL_SIZE + CELL_SIZE - eyeOffset;
                            eyeX1 = segment.x * CELL_SIZE + eyeOffset;
                            eyeX2 = segment.x * CELL_SIZE + CELL_SIZE - eyeOffset;
                            break;
                    }
                    
                    ctx.fillRect(eyeX1, eyeY1, eyeSize, eyeSize);
                    ctx.fillRect(eyeX2, eyeY2, eyeSize, eyeSize);
                    ctx.fillStyle = '#00ff00';
                }
            });
            
            // Draw food
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(
                game.food.x * CELL_SIZE + CELL_SIZE/2,
                game.food.y * CELL_SIZE + CELL_SIZE/2,
                CELL_SIZE/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }
        
        function gameOver() {
            game.isPlaying = false;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', canvas.width/2, canvas.height/2);
            ctx.font = '20px Arial';
            ctx.fillText('Tap to restart', canvas.width/2, canvas.height/2 + 40);
            
            canvas.addEventListener('touchstart', restartGame, {once: true});
        }
        
        function restartGame() {
            game.snake = [{x: 10, y: 10}];
            game.direction = 'right';
            game.nextDirection = 'right';
            game.score = 0;
            game.speed = 150;
            game.isPlaying = true;
            scoreElement.textContent = '0';
            spawnFood();
        }
        
        // Game loop
        function gameLoop() {
            update();
            render();
            if (game.isPlaying) {
                setTimeout(gameLoop, game.speed);
            }
        }
        
        // Start game
        gameLoop();
    </script>
</body>
</html>
```

This implementation includes:

1. Responsive canvas that scales to fit the screen
2. Touch controls using swipe gestures
3. Visual feedback with snake eyes that follow direction
4. Smooth gameplay with progressive difficulty
5. Score tracking
6. Game over screen with restart functionality
7. Collision detection for walls and self
8. Food spawning that avoids snake body
9. Keyboard controls for testing

To play:
- Swipe in any direction to control the snake
- Collect red food dots to grow and increase score
- Avoid walls and your own tail
- Game speeds up as you collect more food
- Tap to restart after game over

The game is optimized for mobile devices with:
- Proper viewport settings
- Touch event handling
- Responsive sizing
- Clear visual feedback
- Simple controls

The snake has eyes that follow its direction of movement, and the food is displayed as red circles for better visibility. The game gets progressively faster as you collect more food, increasing the challenge.