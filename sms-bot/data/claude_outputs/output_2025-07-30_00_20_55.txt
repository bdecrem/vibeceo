I'll create a mobile-friendly Tetris game with touch and keyboard controls. Here's the complete implementation:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            background: #111;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #000;
        }
        
        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0,0,0,0.5);
        }
        
        .btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 10px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        #score {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div class="controls">
        <div class="btn" id="leftBtn">←</div>
        <div class="btn" id="rotateBtn">↻</div>
        <div class="btn" id="downBtn">↓</div>
        <div class="btn" id="rightBtn">→</div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game constants
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = Math.floor(Math.min(window.innerHeight - 100, window.innerWidth) / COLS);
const BOARD_WIDTH = BLOCK_SIZE * COLS;
const BOARD_HEIGHT = BLOCK_SIZE * ROWS;

// Set canvas size
canvas.width = BOARD_WIDTH;
canvas.height = BOARD_HEIGHT;

// Tetromino shapes
const SHAPES = [
    [[1,1,1,1]], // I
    [[1,1,1],[0,1,0]], // T
    [[1,1,1],[1,0,0]], // L
    [[1,1,1],[0,0,1]], // J
    [[1,1],[1,1]], // O
    [[1,1,0],[0,1,1]], // S
    [[0,1,1],[1,1,0]] // Z
];

const COLORS = [
    '#00f0f0', // cyan
    '#f0a000', // orange
    '#f0f000', // yellow
    '#a000f0', // purple
    '#00f000', // green
    '#f00000', // red
    '#0000f0'  // blue
];

// Game state
let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
let score = 0;
let currentPiece = null;
let currentPieceX = 0;
let currentPieceY = 0;
let currentPieceColor = '';
let gameOver = false;
let dropInterval = 1000;
let lastDrop = 0;

class Piece {
    constructor(shape, color) {
        this.shape = shape;
        this.color = color;
    }
}

function createNewPiece() {
    const randomIndex = Math.floor(Math.random() * SHAPES.length);
    return new Piece(SHAPES[randomIndex], COLORS[randomIndex]);
}

function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
}

function drawBoard() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);
    
    for(let y = 0; y < ROWS; y++) {
        for(let x = 0; x < COLS; x++) {
            if(board[y][x]) {
                drawBlock(x, y, board[y][x]);
            }
        }
    }
}

function drawCurrentPiece() {
    if(!currentPiece) return;
    
    currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if(value) {
                drawBlock(currentPieceX + x, currentPieceY + y, currentPiece.color);
            }
        });
    });
}

function collision(pieceX, pieceY, piece = currentPiece) {
    return piece.shape.some((row, dy) => {
        return row.some((value, dx) => {
            let x = pieceX + dx;
            let y = pieceY + dy;
            return (
                value && (
                    x < 0 || 
                    x >= COLS ||
                    y >= ROWS ||
                    (y >= 0 && board[y][x])
                )
            );
        });
    });
}

function mergePiece() {
    currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if(value) {
                board[currentPieceY + y][currentPieceX + x] = currentPiece.color;
            }
        });
    });
}

function clearLines() {
    let linesCleared = 0;
    
    for(let y = ROWS - 1; y >= 0; y--) {
        if(board[y].every(cell => cell !== 0)) {
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
        }
    }
    
    if(linesCleared > 0) {
        score += linesCleared * 100;
        document.getElementById('score').textContent = `Score: ${score}`;
        dropInterval = Math.max(100, 1000 - Math.floor(score / 1000) * 100);
    }
}

function rotatePiece() {
    const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[row.length - 1 - i])
    );
    
    if(!collision(currentPieceX, currentPieceY, {shape: rotated, color: currentPiece.color})) {
        currentPiece.shape = rotated;
    }
}

function moveLeft() {
    if(!collision(currentPieceX - 1, currentPieceY)) {
        currentPieceX--;
    }
}

function moveRight() {
    if(!collision(currentPieceX + 1, currentPieceY)) {
        currentPieceX++;
    }
}

function moveDown() {
    if(!collision(currentPieceX, currentPieceY + 1)) {
        currentPieceY++;
        return true;
    }
    return false;
}

function hardDrop() {
    while(moveDown()) {}
    mergePiece();
    clearLines();
    spawnPiece();
}

function spawnPiece() {
    currentPiece = createNewPiece();
    currentPieceX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
    currentPieceY = 0;
    
    if(collision(currentPieceX, currentPieceY)) {
        gameOver = true;
    }
}

function update(timestamp) {
    if(gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);
        ctx.fillStyle = 'white';
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over!', BOARD_WIDTH/2, BOARD_HEIGHT/2);
        ctx.font = '20px Arial';
        ctx.fillText('Tap to restart', BOARD_WIDTH/2, BOARD_HEIGHT/2 + 40);
        return;
    }
    
    if(timestamp - lastDrop > dropInterval) {
        if(!moveDown()) {
            mergePiece();
            clearLines();
            spawnPiece();
        }
        lastDrop = timestamp;
    }
    
    drawBoard();
    drawCurrentPiece();
    requestAnimationFrame(update);
}

// Controls
document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveLeft();
});

document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveRight();
});

document.getElementById('downBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    hardDrop();
});

document.getElementById('rotateBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    rotatePiece();
});

// Keyboard controls
document.addEventListener('keydown', (e) => {
    if(gameOver) {
        init();
        return;
    }
    
    switch(e.key) {
        case 'ArrowLeft':
            moveLeft();
            break;
        case 'ArrowRight':
            moveRight();
            break;
        case 'ArrowDown':
            moveDown();
            break;
        case 'ArrowUp':
            rotatePiece();
            break;
        case ' ':
            hardDrop();
            break;
    }
});

// Touch restart
canvas.addEventListener('touchstart', (e) => {
    if(gameOver) {
        e.preventDefault();
        init();
    }
});

function init() {
    board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    score = 0;
    gameOver = false;
    dropInterval = 1000;
    document.getElementById('score').textContent = 'Score: 0';
    spawnPiece();
    requestAnimationFrame(update);
}

// Start game
init();
</script>
</body>
</html>
```

This implementation includes:

1. Mobile-friendly controls with touch buttons
2. Keyboard support for desktop play
3. Responsive canvas sizing
4. Score tracking and increasing difficulty
5. All standard Tetris features:
   - Piece rotation
   - Hard drop
   - Line clearing
   - Score system
   - Game over detection
   - Progressive speed increase

Controls:
- Mobile: Use the on-screen buttons
  - Left/Right arrows to move
  - Rotate button to rotate piece
  - Down arrow for hard drop
- Desktop:
  - Arrow keys to move/rotate
  - Spacebar for hard drop

The game automatically adjusts to screen size while maintaining the proper Tetris grid ratio. The speed increases as you score more points, and the game can be restarted by tapping/clicking when game over.

Features:
- 7 standard Tetromino pieces
- Different colors for each piece type
- Score tracking
- Progressive difficulty
- Collision detection
- Line clearing
- Game over detection
- Touch and keyboard controls
- Responsive design

The game is optimized for mobile devices with touch controls positioned at the bottom of the screen, but it's equally playable on desktop with keyboard controls.